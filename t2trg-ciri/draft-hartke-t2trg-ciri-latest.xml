<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC3986 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.3986.xml">
  <!ENTITY RFC3987 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.3987.xml">
  <!ENTITY RFC5952 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.5952.xml">
  <!ENTITY RFC6690 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.6690.xml">
  <!ENTITY RFC7049 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7049.xml">
  <!ENTITY RFC7228 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7228.xml">
  <!ENTITY RFC7230 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7230.xml">
  <!ENTITY RFC7252 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7252.xml">
  <!ENTITY RFC8174 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.8174.xml">
  <!ENTITY I-D.ietf-cbor-cddl SYSTEM "http://www.rfc-editor.org/refs/bibxml3/reference.I-D.ietf-cbor-cddl.xml">
  <!ENTITY W3C.REC-html52-20171214 SYSTEM "http://www.rfc-editor.org/refs/bibxml4/reference.W3C.REC-html52-20171214.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>

<rfc category="exp" docName="draft-hartke-t2trg-ciri-00" ipr="trust200902">

  <front>

    <title abbrev="Constrained IRIs">
      Constrained Internationalized Resource Identifiers (CIRIs)
    </title>

    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Torshamnsgatan 23</street>
          <city>Stockholm</city>
          <code>SE-16483</code>
          <country>Sweden</country>
        </postal>
        <email>klaus.hartke@ericsson.com</email>
      </address>
    </author>

    <date/>

    <workgroup>Thing-to-Thing Research Group</workgroup>

    <abstract>

      <t>
        TODO.
      </t>

    </abstract>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction" anchor="introduction">

      <t>
        <xref target="RFC3986">URI references</xref> and, albeit less
        prevalently, <xref target="RFC3987">IRI references</xref> are the
        standard way to link to resources in hypertext formats like <xref
        target="W3C.REC-html52-20171214">HTML</xref> and the <xref
        target="RFC6690">CoRE Link Format</xref>. They encode the components of
        a resource reference either as an absolute URI/IRI or as a relative
        reference that must be resolved against a base URI/IRI to receive an
        absolute URI/IRI.
      </t>

      <t>
        URI and IRI references are strings of characters where the characters
        are chosen from a limited subset of the repertoires of US-ASCII and
        Unicode characters, respectively. The individual components of a URI or
        IRI reference are delimited by a number of reserved characters, which
        necessitates the use of percent-encoding when these reserved characters
        are used in a non-delimiting function. The resolution of references
        involves parsing URI/IRI references into their components, combining
        those components with the components of the base URI/IRI, merging paths,
        removing dot segments, and recomposing the result back into a character
        string.
      </t>

      <t>
        Altogether, the proper processing of URIs is quite complex. This can be
        a problem particularly in <xref target="RFC7228">constrained
        environments</xref>, where devices often have severe code size
        limitations. As a result, many implementations in these environments
        choose to implement only an ad-hoc, informally-specified, bug-ridden,
        non-interoperable subset of less than half of RFC 3986.
      </t>

      <t>
        This document specifies Constrained IRI References, a serialization
        format for IRI references that encodes the IRI components as <xref
        target="RFC7049">Concise Binary Object Representation (CBOR)</xref> data
        items rather than as a string of characters. Assuming that a CBOR
        implementation is already present on a device, typical operations on
        Constrained IRI references such as parsing, reference resolution, and
        comparison can be implemented much more easily than with the original
        format. A full implementation that covers all corner cases of the
        specification can be implemented in a relatively small amount of code.
      </t>

      <t>
        Constrained IRI References are not capable of expressing all IRI
        references permitted by the syntax of <xref target="RFC3987">RFC
        3987</xref>. The supported subset is capable of expressing all <xref
        target="RFC7252">CoAP URIs</xref> and most <xref target="RFC7230">HTTP
        URIs</xref>.
      </t>

      <section title="Requirements Notation">

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
          "OPTIONAL" in this document are to be interpreted as described in
          <xref target="RFC2119">BCP 14</xref> <xref target="RFC8174"/> when,
          and only when, they appear in all capitals, as shown here.
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Data Model">

      <t>
        The encoding is very similar to the <xref target="RFC7252">encoding of
        the request URI in CoAP messages</xref>. The components of an IRI
        reference are encoded as a sequence of <spanx>options</spanx>. Each
        option consists of an <spanx>option number</spanx> identifying the type
        of option (scheme, host name, etc.) and the <spanx>option value</spanx>.
      </t>

      <section title="Options">

        <t>
          The following options are defined:
          <list style="hanging">
            <t hangText="scheme">
              <vspace/>Specifies the IRI scheme. IRI schemes have the same
              syntax as URI schemes. The option value therefore MUST match the
              "scheme" rule defined in Section 3.1 of RFC 3986.
            </t>
            <t hangText="host.name">
              <vspace/>Specifies the host of the IRI authority as a registered
              name.
            </t>
            <t hangText="host.ip">
              <vspace/>Specifies the host of the IRI authority as an IPv4
              address (4&nbsp;bytes) or an IPv6 address (16&nbsp;bytes).
            </t>
            <t hangText="port">
              <vspace/>Specifies the port number. The option value MUST be an
              unsigned integer in the range 0 to 65535 (inclusive).
            </t>
            <t hangText="path.type">
              <vspace/>Specifies the type of the IRI path for reference
              resolution. Possible values are 0 (absolute-path), 1
              (append-path), 2 (relative-path), and 3 (append-relation).
            </t>
            <t hangText="path">
              <vspace/>Specifies one segment of the IRI path. This option can
              occur more than once.
            </t>
            <t hangText="query">
              <vspace/>Specifies one argument of the IRI query. This option can
              occur more than once.
            </t>
            <t hangText="fragment">
              <vspace/>Specifies the fragment identifier.
            </t>
          </list>
          The value of a "host.name", "path", "query", and "fragment" option can
          be any Unicode string. No percent-encoding is performed.
        </t>

      </section>

      <section title="Option Sequences">

        <t>
          A sequence of options is considered <spanx>well-formed</spanx> if:
          <list style="symbols">
            <t>
              the sequence of options is empty or starts with a "scheme",
              "host.name", "host.ip", "port", "path.type", "path", "query",
              or "fragment" option;
            </t>
            <t>
              a "scheme" option is followed by either a "host.name" or a
              "host.ip" option;
            </t>
            <t>
              a "host.name" option is followed by a "port" option;
            </t>
            <t>
              a "host.ip" option is followed by a "port" option;
            </t>
            <t>
              a "port" option is followed by a "path", "query", or "fragment"
              option or is at the end of the sequence;
            </t>
            <t>
              a "path.type" option is followed by a "path", "query", or
              "fragment" option or is at the end of the sequence;
            </t>
            <t>
              a "path" option is followed by a "path", "query", or "fragment"
              option or is at the end of the sequence;
            </t>
            <t>
              a "query" option is followed by a "query" or "fragment" option or
              is at the end of the sequence; and
            </t>
            <t>
              a "fragment" option is at the end of the sequence.
            </t>
          </list>
        </t>

        <t>
          A well-formed sequence of options is considered
          <spanx>absolute</spanx> if the sequence of options starts with a
          "scheme" option. A well-formed sequence of options is considered
          <spanx>relative</spanx> if the sequence of options is empty or starts
          with an option other than the "scheme" option.
        </t>

        <t>
          An absolute sequence of options is considered
          <spanx>normalized</spanx> if the result of resolving the sequence of
          options against any base IRI reference is equal to the input. (It
          doesn't matter what it is resolved against, since it is already
          absolute.)
        </t>

        <t>
          The following operations can be performed on a sequence of options:
          <list style="hanging">
            <t hangText="Resolve(href, base)">
              <vspace/>Resolves a well-formed sequence of options `href` against
              an absolute sequence of options `base`. This operation MUST be
              performed by applying any algorithm that is functionally
              equivalent to the reference implementation in <xref
              target="py-resolve"/>.
            </t>
            <t hangText="Recompose(href)">
              <vspace/>Recomposes a IRI reference string from an absolute
              sequence of options `href`. This operation MUST be performed by
              applying any algorithm that is functionally equivalent to the
              reference implementation in <xref target="py-recompose"/>.
            </t>
            <t>
              To reduce variability, it is RECOMMENDED that the hexadecimal
              notation when percent-encoding octets use uppercase letters <xref
              target="RFC3986"/> and the text representation of IPv6 addresses
              follow the recommendations of Section 4 of <xref
              target="RFC5952">RFC 5952</xref>.
            </t>
            <t hangText="Decompose(iri)">
              <vspace/>Decomposes a IRI reference string into a sequence of
              options. This operation MUST be performed by applying any
              algorithm that returns a sequence of options such that
              `Recompose(Decompose(x))` is equivalent to `x`.
            </t>
            <t hangText="CoAP(href)">
              <vspace/>Constructs CoAP options from an absolute, normalized
              sequence of options. This operation MUST be performed by
              recomposing the sequence of options to an IRI reference string,
              mapping the IRI to an URI (Section 3.1 of RFC 3987), and
              decomposing the URI into CoAP options (Section 6.4 of RFC 7252).
              This process is illustrated in <xref target="py-coap"/>.
            </t>
          </list>
        </t>

      </section>

    </section>

    <section title="CBOR">

      <t>
        A sequence of options is serialized as an array in <xref
        target="RFC7049">Concise Binary Object Representation (CBOR)</xref>. The
        structure of this array is as follows and presented in the <xref
        target="I-D.ietf-cbor-cddl">Concise Data Definition Language
        (CDDL)</xref>.
      </t>

<figure><artwork><![CDATA[
   iri = [?(scheme:    1, text),
          ?(host.name: 2, text //
            host.ip:   3, bytes .size 4 / bytes .size 16),
          ?(port:      4, uint .size 2),
          ?(path.type: 5, path-type),
          *(path:      6, text),
          *(query:     7, text),
          ?(fragment:  8, text)]
]]></artwork></figure>

<figure><artwork><![CDATA[
   path-type = &(absolute-path:   0,
                 append-path:     1,
                 relative-path:   2,
                 append-relation: 3)
]]></artwork></figure>      

    </section>

    <section title="Python">

      <section title="Reference Resolution" anchor="py-resolve">

        <t>
          The following Python 3.5 code defines how to resolve a sequence of
          options that might be relative to a given base IRI.
        </t>

<figure><artwork><![CDATA[
<CODE BEGINS>

   def resolve(base, href, relation=None):
     if not is_absolute(base) or not is_well_formed(href):
       return None
     result = []
     type = PathType.RELATIVE_PATH
     (option, value) = href[0]
     if option == Option.HOST_IP:
       option = Option.HOST_NAME
     elif option == Option.PATH_TYPE:
       href = href[1:]
       type = value
       option = Option.PATH
     if option != Option.PATH or type == PathType.ABSOLUTE_PATH:
       _copy_until(base, result, option)
     else:
       _copy_until(base, result, Option.QUERY)
       if type == PathType.APPEND_RELATION:
         _append_and_normalize(result, Option.PATH,
                               format(relation, "x"))
         return result
       if type == PathType.RELATIVE_PATH:
         _remove_last_path_segment(result)
     _copy_until(href, result, Option.END)
     _append_and_normalize(href, Option.END, None)
     return result

   def _copy_until(input, output, end):
     for (option, value) in input:
       if option >= end:
         break
       _append_and_normalize(output, option, value)

   def _append_and_normalize(output, option, value):
     if option == Option.PATH:
       if value == ".":
         return
       if value == "..":
         _remove_last_path_segment(output)
         return
     elif option > Option.PATH:
       if len(output) >= 2 and                                      \
           output[-1] == (Option.PATH, "") and                      \
           (output[-2][0] < Option.PATH_TYPE or                     \
           output[-2] == (Option.PATH_TYPE, PathType.ABSOLUTE_PATH)):
         _remove_last_path_segment(output)
       if option >= Option.END:
         return
     output.append((option, value))

   def _remove_last_path_segment(output):
     if len(output) >= 1 and output[-1][0] == Option.PATH:
       del output[-1]

<CODE ENDS>
]]></artwork></figure>

      </section>

      <section title="IRI Recomposition" anchor="py-recompose">

        <t>
          The following Python 3.5 code defines how to recompose an IRI from a
          sequence of options that encodes an absolute IRI reference.
        </t>

<figure><artwork><![CDATA[
<CODE BEGINS>

   def recompose(href):
     if not is_absolute(href):
       return None
     result = ""
     no_path = True
     first_query = True
     for (option, value) in href:
       if option == Option.SCHEME:
         result += value + ":"
       elif option == Option.HOST_NAME:
         result += "//" + _encode_ireg_name(value)
       elif option == Option.HOST_IP:
         result += "//" + _encode_ip_address(value)
       elif option == Option.PORT:
         result += ":" + str(value)
       elif option == Option.PATH:
         result += "/" + _encode_path_segment(value)
         no_path = False
       elif option == Option.QUERY:
         if no_path:
           result += "/"
           no_path = False
         result += "?" if first_query else "&"
         result += _encode_query_argument(value)
         first_query = False
       elif option == Option.FRAGMENT:
         if no_path:
           result += "/"
           no_path = False
         result += "#" + _encode_fragment(value)
     if no_path:
       result += "/"
       no_path = False
     return result

   def _encode_ireg_name(s):
     return "".join(c if _is_ireg_name_char(c) else
         _encode_pct(c) for c in s)

   def _encode_ip_address(b):
     if len(b) == 4:
       return ".".join(str(c) for c in b)
     elif len(b) == 16:
       return "[" + ... + "]"  # see RFC 5952

   def _encode_path_segment(s):
     return "".join(c if _is_isegment_char(c) else
         _encode_pct(c) for c in s)

   def _encode_query_argument(s):
     return "".join(c if _is_iquery_char(c) and c != "&" else
         _encode_pct(c) for c in s)

   def _encode_fragment(s):
     return "".join(c if _is_ifragment_char(c) else
         _encode_pct(c) for c in s)

   def _encode_pct(s):
     return "".join(
         "%{0:0>2X}".format(c) for c in s.encode("utf-8"))

   def _is_ireg_name_char(c):
     return _is_iunreserved(c) or _is_sub_delim(c)

   def _is_isegment_char(c):
     return _is_ipchar(c)

   def _is_iquery_char(c):
     return _is_ipchar(c) or _is_iprivate(c) or c == "/" or c == "?"

   def _is_ifragment_char(c):
     return _is_ipchar(c) or c == "/" or c == "?"

   def _is_ipchar(c):
     return _is_iunreserved(c) or _is_sub_delim(c) or               \
            c == ":" or c == "@"

   def _is_iunreserved(c):
     return _is_alpha(c) or _is_digit(c) or                         \
            c == "-" or c == "." or c == "_" or c == "~" or         \
            _is_ucschar(c)

   def _is_alpha(c):
     return c >= "A" and c <= "Z" or c >= "a" and c <= "z"

   def _is_digit(c):
     return c >= "0" and c <= "9"

   def _is_sub_delim(c):
     return c == "!" or c == "$" or c == "&" or c == "'" or         \
            c == "(" or c == ")" or c == "*" or c == "+" or         \
            c == "," or c == ";" or c == "="

   def _is_ucschar(c):
     return c >= "\U000000A0" and c <= "\U0000D7FF" or              \
            c >= "\U0000F900" and c <= "\U0000FDCF" or              \
            c >= "\U0000FDF0" and c <= "\U0000FFEF" or              \
            c >= "\U00010000" and c <= "\U0001FFFD" or              \
            c >= "\U00020000" and c <= "\U0002FFFD" or              \
            c >= "\U00030000" and c <= "\U0003FFFD" or              \
            c >= "\U00040000" and c <= "\U0004FFFD" or              \
            c >= "\U00050000" and c <= "\U0005FFFD" or              \
            c >= "\U00060000" and c <= "\U0006FFFD" or              \
            c >= "\U00070000" and c <= "\U0007FFFD" or              \
            c >= "\U00080000" and c <= "\U0008FFFD" or              \
            c >= "\U00090000" and c <= "\U0009FFFD" or              \
            c >= "\U000A0000" and c <= "\U000AFFFD" or              \
            c >= "\U000B0000" and c <= "\U000BFFFD" or              \
            c >= "\U000C0000" and c <= "\U000CFFFD" or              \
            c >= "\U000D0000" and c <= "\U000DFFFD" or              \
            c >= "\U000E1000" and c <= "\U000EFFFD"

   def _is_iprivate(c):
     return c >= "\U0000E000" and c <= "\U0000F8FF" or              \
            c >= "\U000F0000" and c <= "\U000FFFFD" or              \
            c >= "\U00100000" and c <= "\U0010FFFD"

<CODE ENDS>
]]></artwork></figure>

      </section>

      <section title="CoAP Encoding" anchor="py-coap">

        <t>
          The following Python 3.5 code shows how to construct CoAP options from
          an absolute sequence of options. For simplicity, the code does not
          omit CoAP options with their default value in a CoAP request.
        </t>

<figure><artwork><![CDATA[
<CODE BEGINS>

   def coap(href, to_proxy=False):
     if not is_absolute(href):
       return None
     result = b""
     previous = 0
     for (option, value) in href:
       if option == Option.SCHEME:
         pass
       elif option == Option.HOST_NAME:
         opt = 3  # Uri-Host
         val = value.encode("utf-8")
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.HOST_IP:
         opt = 3  # Uri-Host
         if len(value) == 4:
           val = ".".join(str(c) for c in b).encode("utf-8")
         elif len(value) == 16:
           val = b"[" + ... + b"]"  # see RFC 5952
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.PORT:
         opt = 7  # Uri-Port
         val = value.to_bytes((value.bit_length() + 7) // 8, "big")
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.PATH:
         opt = 11  # Uri-Path
         val = value.encode("utf-8")
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.QUERY:
         opt = 15  # Uri-Query
         val = value.encode("utf-8")
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.FRAGMENT:
         pass
     if to_proxy:
       (option, value) = href[0]
       opt = 39  # Proxy-Scheme
       val = value.encode("utf-8")
       result += _encode_coap_option(opt - previous, val)
       previous = opt
     return result

   def _encode_coap_option(delta, value):
     length = len(value)
     delta_nibble = _encode_coap_option_nibble(delta)
     length_nibble = _encode_coap_option_nibble(length)
     result = bytes([delta_nibble << 4 | length_nibble])
     if delta_nibble == 13:
       delta -= 13
       result += bytes([delta])
     elif delta_nibble == 14:
       delta -= 256 + 13
       result += bytes([delta >> 8, delta & 255])
     if length_nibble == 13:
       length -= 13
       result += bytes([length])
     elif length_nibble == 14:
       length -= 256 + 13
       result += bytes([length >> 8, length & 255])
     result += value
     return result

   def _encode_coap_option_nibble(n):
     if n < 13:
       return n
     elif n < 256 + 13:
       return 13
     elif n < 65536 + 256 + 13:
       return 14

<CODE ENDS>
]]></artwork></figure>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Security Considerations" anchor="security">
    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="IANA Considerations">
    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC2119;
      &RFC3986;
      &RFC3987;
      &RFC7049;
      &RFC8174;

      &I-D.ietf-cbor-cddl;

    </references>

    <references title="Informative References">

      &RFC5952;
      &RFC6690;
      &RFC7228;
      &RFC7230;
      &RFC7252;

      &W3C.REC-html52-20171214;

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <!--
    <section title="Acknowledgements" numbered="no">
    </section>
    -->

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
