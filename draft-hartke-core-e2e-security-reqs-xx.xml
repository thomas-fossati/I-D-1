<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
  <!ENTITY RFC4949 SYSTEM "reference.RFC.4949.xml">
  <!ENTITY RFC6347 SYSTEM "reference.RFC.6347.xml">
  <!ENTITY RFC7228 SYSTEM "reference.RFC.7228.xml">
  <!ENTITY RFC7252 SYSTEM "reference.RFC.7252.xml">
  <!ENTITY RFC7258 SYSTEM "reference.RFC.7258.xml">
  <!ENTITY RFC7641 SYSTEM "reference.RFC.7641.xml">
  <!ENTITY I-D.ietf-cose-msg SYSTEM "reference.I-D.ietf-cose-msg.xml">
  <!ENTITY I-D.mattsson-core-coap-actuators SYSTEM "reference.I-D.mattsson-core-coap-actuators.xml">
  <!ENTITY I-D.koster-core-coap-pubsub SYSTEM "reference.I-D.koster-core-coap-pubsub.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>

<rfc category="info" docName="draft-hartke-core-e2e-security-reqs-01" ipr="trust200902">
    
    <front>

    <title>Requirements for CoAP End-To-End Security</title>

    <author initials="G." surname="Selander" fullname="Goeran Selander">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>goran.selander@ericsson.com</email>
      </address>
    </author>
    
    <author initials="F." surname="Palombini" fullname="Francesca Palombini">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>francesca.palombini@ericsson.com</email>
      </address>
    </author>
   
    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63905</phone>
        <email>hartke@tzi.org</email>
      </address>
    </author>
    
    <!--
    <author initials="L." surname="Seitz" fullname="Ludwig Seitz">
      <organization>SICS Swedish ICT AB</organization>
      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <city>Lund</city>
          <code>223 70</code>
          <country>Sweden</country>
        </postal>
        <email>ludwig@sics.se</email>
      </address>
    </author>
    -->
    
    <date />


    <area>Applications</area>

    <workgroup>CoRE Working Group</workgroup>

    <abstract>

      <t>
        This document analyses threats to CoAP message 
        exchanges traversing proxies and derives the security requirements
        for mitigating those threats.
      </t>

    </abstract>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction">

      <t>
        The <xref target="RFC7252">Constrained Application Protocol
        (CoAP)</xref> is a Web application protocol designed for
        <xref target="RFC7228">constrained nodes and networks</xref>.
      </t>

      <t>
        CoAP uses <xref target="RFC6347">Datagram Transport Layer
        Security (DTLS)</xref> for security.  At the same time, CoAP
        relies on proxies for scalability and
        efficiency.  These proxies are specified to perform a
        number of operations on CoAP messages which requires
        DTLS to be terminated at the proxy.  The proxy therefore
        not only has access to the data required for performing the
        desired proxy functionality, but is also able to eavesdrop on
        or manipulate any part of the CoAP payload and metadata in
        transit between client and server or inject new CoAP messages
        without being protected or
        detected by DTLS.
      </t>

      <t>
        One way to mitigate this threat is to secure CoAP communication
        at the application layer using an object-based security
        mechanism such as <xref target="I-D.ietf-cose-msg">CBOR
        Encoded Message Syntax</xref> instead of or in addition to
        the security mechanisms at the network layer or transport
        layer. Such a mechanism can provide "end-to-end security" at
        the application layer in contrast to the "hop-by-hop security"
        provided by DTLS.
      </t>

      <t>
        This document analyses security requirements for CoAP requests and
        responses of sensor and actuator deployments involving proxies and
        other similar intermediaries.  The analysis is based on identifying
        the assets associated to sensor- and actuator-based communication
        patterns and considering the potential threats executed through
        proxies to these assets.  The threat analysis provides the basis for
        defining the security requirements that an end-to-end security
        mechanism for CoAP needs to meet.
      </t>

      <section title="Terminology">

        <!--
        <t>
          This document makes use of the terminology defined in
          <xref target="RFC4949"/>.
        </t>
        -->

        <t>
          Readers are expected to be familiar with the terms and
          concepts described in <xref target="RFC7252"/> and
          <xref target="RFC7641"/>.
        </t>

        <!--
        <t>
          Additionally, the following terms are used in this document:
          <list style="hanging">
            <t hangText="...:">...</t>
          </list>
        </t>
        -->

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to
          be interpreted as described in <xref target="RFC2119"/>.
          The key word "NOT REQUIRED" is interpreted as synonymous with
          the key word "OPTIONAL".
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Scope and Assumptions">
    
    <t>
      This document analyzes security aspects of various kinds of intermediary
      nodes involved in sensor and actuator communications over CoAP.
      The intermediaries are responsible, for example, for reducing response time and
      network bandwidth use by serving responses from a cache or for enabling
      the client to make requests that it otherwise could not make.
    </t>
    
    <t>
      In general, there are the following types of assets that
      need to be protected:
      <list style="format A%d:" counter="my_count">
        <t>
          The devices at the two ends, the data generated and stored in
          these devices, and their (often very
          constrained) system resources such as available memory, storage,
          processing capacity, and energy.
        </t>
        <t>
          The physical environment of the devices fitted with sensors
          and actuators.  Access to the physical environment is
          provided through CoAP resources that allow a remote entity
          to retrieve information about the physical environment
          (such as the current temperature) or to produce an effect
          on the physical environment (such as the activation of a
          heater).
        </t>
        <t>
          The communication infrastructure linking the two devices
          (which often contains some very constrained parts) and the data
          stored in the message processing devices.
        </t>
      </list>
    </t>
    
    <t>
      The purpose of this document is to analyze threats executed through
      intermediary nodes. An intermediary may directly affect assets of
      type A3, e.g. by dropping messages. An intermediary node may also
      manipulate the messages exchanged between the endpoints and thereby
      have an impact also on the assets A1 and A2, for example: flooding a
      device with messages has impact on its
      system resources, and successful manipulation of an actuator command,
      carried in a message, has an impact on the physical environment.
    </t>
    
    <t>
      An intermediate node handling unprotected messages may be an attractive
      target for an attack, since such nodes are aggregation points for message flows
      (see <xref target="sec-cons"/>) and, furthermore, may be an easier target from the
      Internet than the sensors/actuators residing behind them.  An intermediary
      may become subject to intrusion or infected by malware and perform
      the attacks of a man-in-the-middle; the attack vectors for
      compromise are out of scope for this document.
    </t>
    
    <t>
      The scope of the analysis is
      restricted to threats from intermediaries to single client to server
      interactions.  Threats resulting from collusion between multiple
      intermediaries are also out of scope (see <xref target="sec-cons"/>).
    </t>
    
    <t>
      To assess what impact various threats have to the assets, we need to specify
      and analyse how the intermediary nodes operate.
    </t>
    
    
    </section>
    
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Intermediary Node Operations" anchor="node-operations">
      
      <t>
        An intermediary node receives a request from a client intended for a
        certain origin server, and sends a response back to the client, see
        <xref target="fig-intermediary"/>.
      </t>
      
      <figure anchor="fig-intermediary" title="The Client Request and Response.">
        <artwork align="left">
          <![CDATA[
 ________            ____ _ _
|        | Request  |
|        |--------->| Inter-
| Client |          | mediary
|        |<---------| Node
|________| Response |____ _ _
          ]]>
        </artwork>
      </figure>
      
      <t>
        There are two different ways for the intermediary node to operate:
        <list style="format %d." counter="case-count">
          <t>
            The intermediary constructs and sends a request to the origin server,
            receives a response, and uses the
            received data to construct the response to the client, see
            <xref target="fig-server-req"/>.
          </t>
        </list>
      </t>
  
      <figure anchor="fig-server-req" title="Server Request/Response">
        <artwork align="left">
          <![CDATA[
 ________            _________            ________
|        | Request  |         | Request  |        |
|        |--------->| Inter-  |--------->| Origin |
| Client |          | mediary |          | Server |
|        |<---------| Node    |<---------|        |
|________| Response |_________| Response |________|
          ]]>
        </artwork>
      </figure>
      
      <t>
      <list style="format %d." counter="case-count">
      <t>
        The intermediary uses cached or stored data to construct the
        response to the client, see <xref target="fig-cache"/>.
      </t>
      </list>
      </t>
    
      <figure anchor="fig-cache" title="Cached Response">
        <artwork align="left">
          <![CDATA[
 ________            ___________________
|        | Request  |                   |
|        |--------->| Inter-  +-------+ |
| Client |          | mediary | Cache | |
|        |<---------| Node    +-------+ |
|________| Response |___________________|
          ]]>
        </artwork>
      </figure>
      
      <t>
        In case 2, the cache may be populated with previous responses of
        resource requests to the origin server as in
        <xref target="fig-server-req"/>. Alternatively, the cache may be
        populated from a "source node" acting client and interfacing the
        intermediary as in <xref target="fig-cache"/>;
        pushing resource representations to the intermediary
        (see <xref target="pubsub-case"/>).
      </t>
      
      <t>
        In general, the intermediary node needs to read some parts of the
        messages from client and origin server
        to accomplish its task. Also, if the intermediary sends a request
        to the origin server, this request is not necessarily identical to the
        request received from the client, and analogously for the response.
      </t>
      
      <t>
        The intermediary may in turn make a request to another intermediary.
        In the case of hop-by-hop security (<xref target="fig-hopbyhop"/>) each node
        has a security association with its nearest hop neighbour.
      </t>

      <figure anchor="fig-hopbyhop" title="Hop-by-Hop Security">
        <artwork align="left">
<![CDATA[
     __________       _________       _________       __________
    |          |     |         |     |         |     |          |
    |          |---->| Inter-  |---->| Inter-  |---->|  Origin  |
    |  Client  |     | mediary |     | mediary |     |  Server  |
    |          |<----| Node    |<----| Node    |<----|          |
    |__________|     |_________|     |_________|     |__________|
          :             :   :           :   :             :
          '-------------'   '-----------'   '-------------'
             Security         Security         Security
            Association      Association      Association
                 A                B                C]]>
        </artwork>
      </figure>

      <!-- <t>
        <vspace blankLines="3"/>
      </t> -->
      
      <t>
        In the case of end-to-end security (<xref target="fig-endtoend"/>) the
        client has a security association with the origin server/source node,
        and the intermediaries are only trusted with performing its
        intended operations.
      </t>
 

      <figure anchor="fig-endtoend" title="End-to-End Security">
        <artwork align="left">
          <![CDATA[
     __________       _________       _________       __________
    |          |     |         |     |         |     |          |
    |          |---->| Inter-  |---->| Inter-  |---->|  Origin  |
    |  Client  |     | mediary |     | mediary |     |  Server  |
    |          |<----| Node    |<----| Node    |<----|          |
    |__________|     |_________|     |_________|     |__________|
          :                                               :
          '-----------------------------------------------'
                        Security Association
          ]]>
        </artwork>
      </figure>
      
    </section>
    
    <!-- **************************************************************** -->
    
    <section title="Threats and Mitigation" anchor="threat-mit">
      
      <t>
        In this section we consider threats to authenticity, availability and
        confidentiality from intermediate nodes.
      </t>
      
      <section title="Threats to Authenticity and Availability">
        
        <section title="Client" anchor="client-end">
          
          <t>
            In this section we focus on threats to a client interacting
            with an intermediary node, see <xref target="fig-client"/>.
          </t>
          
          <figure anchor="fig-client" title="The Client End">
            <artwork align="left">
              <![CDATA[
     __________             __ _ _
    |          | Request   |
    |          |---------->|  Inter-
    |  Client  |           |  mediary
    |          |<----------|  Node
    |__________|  Response |__ _ _]]>
            </artwork>
          </figure>
          
          
          <t>
            The client sends a request and waits for a response.
            There are three possible flows and associated threats:
            <list style="symbols">
              <t>
                The client receives a response.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The request is duly processed and a response is received
                    based on data from the origin server.
                  </t>
                  <t>
                    The client receives an error response from an
                    intermediate node according to specification
                    (e.g., 5.02 Bad Gateway or 5.03 Service Unavailable).
                  </t>
                  <t>
                    (Spoofing:) The response is spoofed by an intermediate node.
                  </t>
                </list>
              </t>
              <t>
                The client does not receive a response.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The client times out too early, for example because a
                    link is down, or a message is lost and re-transmission
                    failed, or that a server takes too long responding.
                  </t>
                  <t>
                    (Withholding:) A message is withheld by an intermediate
                    node, e.g. intentionally dropped or delayed.
                  </t>
                </list>
              </t>
              <t>
                The client receives too many responses.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    (Spoofing:) An intermediate node injects spoofed responses.
                  </t>
                  <t>
                    (Flooding:) An intermediate node floods the client with
                    responses.
                  </t>
                </list>
              </t>
            </list>
            If the client observes a resource, the same threats applies to
            each response.
          </t>
          <t>
            Note that "cache poisioning" - the case of caching injected
            incorrect responses  - is covered from the
            point of view of the client: it may result in the client receiving a
            spoofed message, or too many responses, or that the
            proxy or other node is affected such that the client is impacted,
            e.g. times out too early.
          </t>
        </section>
        
        
        <section title="Server" anchor="server-end">
          
          <t>
            In this section we focus on threats to a server interacting
            with an intermediary node, see <xref target="fig-server-pull"/>.
          </t>
          
          <figure anchor="fig-server-pull" title="The Server End">
            <artwork align="center">
              <![CDATA[
                 _ _ __             __________
                       | Request   |          |
               Inter-  |---------->|  Origin  |
               mediary |           |  Server  |
               Node    |<----------|          |
                 _ _ __|  Response |__________|
              ]]>
            </artwork>
          </figure>
          
          
          <t>
            <vspace blankLines="1"/>
          </t>
          
          <t>
            A server listens for a request and returns a response. There are
            three possible flows and associated threats:
            <list style="symbols">
              <t>
                The server receives a request.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The request was sent according to
                    specification.
                  </t>
                  <t>
                    (Spoofing:) An intermediate node spoofs a request.
                  </t>
                </list>
              </t>
              <t>
                The server does not receive a request.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    A request has not been sent.
                  </t>
                  <t>
                    (Withholding:) An intermediate node withholds a request.
                  </t>
                </list>
              </t>
              <t>
                The server receives too many requests.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    (Spoofing:) An intermediate node injects spoofed requests.
                  </t>
                  <t>
                    (Flooding:) An intermediate node floods the server with
                    requests.
                  </t>
                </list>
              </t>
              
            </list>
          </t>
        </section>
      </section>
      
      <section title="Threats to Confidentiality" anchor="threat-conf">
        <t>
          An intermediate node may eavesdrop or infer information from
          messages it operates on. Such information can be used
          for targeted attacks as well as pervasive monitoring.
          
          <list style="symbols">
            <t>
              (Eavesdropping:) Data in the request or the response
              is eavesdropped by an intermediate node.
            </t>
            <t>
              (Traffic Analysis:) Data in the request or the
              response is used by an intermediate node to
              infer information about the nature or content of the request or the
              response, e.g. by measuring
              message size, frequency or distribution of incoming requests
              or outgoing responses.
            </t>
          </list>
        </t>
      </section>
      
      
      <section title="Mitigation">
        
        <section title="Spoofing" anchor="authentic-1">
          <t>
            Except as specified below, this threat is REQUIRED to be
            mitigated by the security solution; client and server MUST
            verify that a received message is
            <spanx>authentic</spanx> before processing it.
          </t>
          
          <t>
            The definition of an "authentic request" or "authentic response"
            depends on the intermediate node and use case
            (<xref target="proxy-scenarios"/> and
            <xref target="pubsub-case"/>).
          </t>
          
          <section title="Authentic Request">
            
            <t>
              The server can verify that a request is authentic by
              integrity protecting data proving some or all of the following:
              <list style="symbols">
                <t>that the data originates from the client and has not been altered on the way;</t>
                <t>that a proxy has acted on behalf of a client;</t>
                <t>that the request has not been received previously;</t>
                <t>that the data has been recently generated by the client.</t>
              </list>
              
            </t>
            <t>
              Note that in the case of a CoAP proxy, it may be allowed to make a
              validation request to a resource without it being possible to
              prove that it acts on behalf of a client. Since such a
              request does not originate from the client, the server cannot
              tell if the proxy sends the request according to specification
              or if it spoofs the request.  If the proxy allows this
              functionality, then this threat is NOT REQUIRED to be mitigated
              by the security solution.
            </t>
            
          </section>
          <section title="Authentic Response">
            
            <t>
              The server can verify that a request is authentic by
              integrity protecting data proving some or all of the following:
              <list style="symbols">
                <t>that the requested action was executed by the origin server;
                </t>
                <t>that the data originates from the origin server and has not
                  been altered on the way;</t>
                <t>that the data matches the specifications of the request
                  (such as the target resource);</t>
                <t>that the data is fresh (when the data is cacheable);</t>
                <t>that the data is in sequence (when observing a resource).</t>
              </list>
              
            </t>
            <t>
              Note that intermediary nodes are specified to return an error
              response when it encounters an error condition. A CoAP proxy may
              return e.g. 5.02 Bad Gateway or 5.04 Gateway Timeout. A pubsub broker
              may e.g. return 4.04 Not Found or 5.03 Service Unavailable.
              Since the condition occurs at the intermediary and not at the origin
              server, the response will not be "authentic"
              according to the above definition. Thus a client cannot
              tell if the intermediary sends the response according to
              specification or if it spoofs the response. Hence the security
              solution is NOT REQUIRED to mitigate spoofing in this case.
            </t>
          </section>
        </section>
        
        
        <section title="Withholding">
          <t>
            This threat is NOT REQUIRED to be mitigated by the
            security solution because a CoAP client or server cannot tell if an
            intermediate node does not send
            a message because it is busy, or if it intentionally drops a
            message.
          </t>
          <t>
            Applications sensitive to delay of requests, e.g. certain actuator
            applications, must protect against this kind of threats,
            see <xref target="I-D.mattsson-core-coap-actuators"/>.
            That is out of scope for this document.
          </t>
        </section>
        
        <section title="Flooding">
          
          <t>
            A CoAP client is specified to reject any response that
            it does not expect. This can happen before the client
            verifies if the response is authentic. Therefore a flood of
            responses is primarily a threat to
            the system resources. A CoAP server  . . . TODO
          </t>
          <t>
            This threat is NOT REQUIRED to be mitigated by the
            security solution in particular, but a client or server SHOULD
            generally defend against flooding attacks.
          </t>

          
        </section>
        
        <section title="Eavesdropping" anchor="eavesdrop">
          <t>
            This threat is REQUIRED to be mitigated by the security
            solution; clients and servers MUST confidentiality protect the
            data in the requests and responses they send.
          </t>
          <t>
            The definition of what needs to be protected depends on the scenario
            (<xref target="proxy-scenarios"/>), but is RECOMMENDED to
            encompass all data that is not needed to be read by the intermediate
            node to perform its function.
          </t>
          <t>
            A solution may, for example, encrypt only payload, or encrypt payload
            and selected options.
          </t>
        </section>
        
        
        <section title="Traffic Analysis" anchor="traffic">
          <t>
            This threat is NOT REQUIRED to be mitigated by the security
            solution.
          </t>
          <t>
            It is RECOMMENDED that applications analyse the risks
            associated with application information leaking from the
            messages flow and assess the feasibility to protect against
            various threats, e.g. by obfuscating parameters transported
            in plain text, aligning message flow and traffic between the
            different cases, adding padding so different messages become
            indistinguishable, etc.
          </t>
          
        </section>
        
      </section>
      
      <section title="Conclusions">
        
        <t>
          The security solution MUST protect against threats to authenticity
          and confidentiality as defined in relation to the legimitate
          intermediate node operations (<xref target="proxy-scenarios"/> and
          <xref target="pubsub-case"/>).
        </t>
        <t>
          Mitigation of spoofing of error messages or other legitimate messages
          originating from the intermediate node is not in scope of the security
          solution.
        </t>
        <t>
          Plain text of message data SHOULD be restricted to a need-to-know basis
          for intermediate nodes, and traffic analysis SHOULD be mitigated.
        </t>
        
      </section>
      
    </section>
    
    
    <!-- **************************************************************** -->
    
    <section title="Proxy Cases" anchor="proxy-scenarios">
      
      <t>
        In this section we study end-to-end security properties across
        different kinds of proxies. For each kind of proxy, we present
        <list style="symbols">
          <t>the functional requirements of the proxy;</t>
          <t>the processing rules of the proxy;</t>
          <t>the required authenticity properties of the messages;</t>
          <t>the required confidentiality properties of the messages; and</t>
          <t>the resulting security requirements for message transfer
            between the endpoints.</t>
        </list>
      </t>
      <t>
        Multiple intermediary nodes of different kinds may used in one
        deployment. This is FFS.
      </t>
      <t>
        Note that since CoAP was not designed for end-to-end security;
        solutions complying with these security requirements extend the
        applicability of CoAP beyond its original scope.
      </t>
      
      <section title="Forwarding" anchor="onereq-oneres" >
        
        <t>
          In this case we study forwarding functionality of a CoAP
          forward proxy, and assume that caching is disabled.
          This is applicable to many
          security critical use cases where a response needs to be securely
          linked to a unique request from a client and cannot be re-used with
          another request.
        </t>
        <t>
          There may be a unique response for each request
          (see <xref target="figure-1"/>) or multiple responses for each
          request (see <xref target="figure-2"/>).
        </t>
        
        <section title="Examples" >
          <t>
            Examples of the need for unique response for each request include
            alarm status retrieval and actuator command confirmation.
          </t>
          
          <figure anchor="figure-1" title="Message Flow with a Unique Response for Each Request">
            <artwork align="center">
              <![CDATA[
Client          Proxy          Server
|               |               |
|    Request    |    Request    |
|-------------->|-------------->|--.
|               |               |  |
|<--------------|<--------------|<-'
|    Response   |    Response   |
|               |               |]]>
            </artwork>
          </figure>
          
          
          <t>
            <list style="hanging">
              <t hangText="Example: Alarm status retrieval">
                <vspace blankLines="1"/>
                <xref target="figure-1"/> can be seen as an illustration of a
                message exchange for a client requesting the alarm status (e.g.,
                GET /alarm_status) from a server.  Since the client wants to ensure
                that the alarm status received is reflecting the current alarm
                status and not a cached or spoofed response to the same
                resource, it must be able to verify that the received response is
                a response to this particular request made by the client.
                Therefore the response must be securely linked to the request.
              </t>
              <t hangText="Example: Actuation confirmation">
                <vspace blankLines="1"/>
                Another example for which <xref target="figure-1"/> serves as
                illustration is the confirmation of an actuator request.  In this
                case a client, say in an industrial control system, requests a
                server that a valve should be turned to a certain level, e.g. PUT
                /valve_42/level with payload "3".  In order for the client to
                correctly evaluate the result of a potential changed valve level,
                it is important that the client gets a confirmation how the
                server responded to the requested change, e.g., whether the request
                was performed or not.  Again, the client wants to ensure that the
                response is reflecting the result of this particular actuation
                request made by the client and not a cached or spoofed response.
                Therefore the response must be securely linked to the request.
              </t>
            </list>
          </t>
          <t>
            An example of the use of multiple responses for each request is
            in security critical monitoring scenarios where time synchronization
            cannot be guaranteed. By avoiding repeated requests from the same
            client to the same resource, constrained node resources and bandwidth
            is saved.
          </t>
          
          
          <figure anchor="figure-2" title="Message Flow of Notifications of
            Linked to a Unique Request">
            <artwork align="center">
              <![CDATA[
Client          Proxy          Server
|               |               |
|    Request    |    Request    |
|-------------->|-------------->|--.
|               |               |  |
|<--------------|<--------------|<-'
|  Notification |  Notification |
|               |               |
|<--------------|<--------------|
|  Notification |  Notification |
|               |               |
|<--------------|<--------------|
|  Notification |  Notification |
|               |               |]]>
            </artwork>
          </figure>
          
          <t>
            
            <list style="hanging">
              <t hangText="Example: Secure parameter monitoring">
                <vspace blankLines="1"/>
                <xref target="figure-2"/> can be seen as an illustration of a
                message exchange for a client monitoring an important parameter
                measured by the
                server, e.g., in a medical or process industry application.
                The client makes a subscription request for a resource
                and the server responds with notifications, e.g. providing
                updates to the parameter on regular time intervals.
              </t>
              <t>
                The client wants to ensure that the first received notification
                reflects the current parameter value and that subsequent
                notifications are timely updates of the initial request.  Since
                notifications may be lost or reordered, the client needs to be
                able to verify the order of the messages, as sent by the server.
                By monitoring the received messages and the time they are
                received, the client can detect missing notifications and take
                appropriate action.
              </t>
            </list>
          </t>
          
        </section>
        
        
        <section anchor="FR1" title="Functional Requirement">
          
          <t>
            <list style="format FR1.%d">
              <t>
                The caching functionality MUST be inhibited;
                the CoAP option Max-Age of the responses SHALL be 0
                (see Section 5.7.1 of <xref target="RFC7252"/>).
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="PR1" title="Processing Rules">
          <t>
            In this scenario, the desired proxy functionality is
            to forward a translated request to the determined destination.
            There are two modes of operation for requests:
            Either using the Proxy-Uri option (PR1.1) or using the
            Proxy-Scheme option together with the Uri-Host, Uri-Port,
            Uri-Path and Uri-Query options (PR1.2).
            <list style="format PR1.%d">
              <t>
                The Proxy-Uri option contains the request URI
                including request scheme (e.g. "coaps://"); the
                Proxy-Scheme and Uri-* options are not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another proxy, then it keeps the Proxy-Uri
                option; otherwise, it splits the option into its
                components, adds the corresponding Uri-* options and
                removes the Proxy-Uri option.
                Then it makes the request using the request scheme
                indicated in the Proxy-Uri.
              </t>
              <t>
                The Proxy-Scheme option
                and the Uri-* options together contain the request URI;
                the Proxy-Uri option is not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another forwarding proxy, then it keeps the
                Proxy-Scheme and Uri-* options; otherwise, it removes
                the Proxy-Scheme option.  Then it makes the request
                using the request scheme indicated in the removed
                Proxy-Scheme option.
              </t>
              <t>
                Responses are forwarded by the proxy, without any modification.
              </t>
            </list>
          </t>
        </section>
        
        
        
        <!-- *************************************************************** -->
        <section anchor="auth-1" title="Authenticity">
          <t>
            This section defines when
            a message is considered authentic (see
            <xref target="authentic-1"/>).
          </t>
          <t>
            The request is considered authentic by the server if:
            <list style="format A1.%d" counter="A1_count">
              <t>
                The request originates from the client
              </t>
              <t>
                The CoAP payload of the request has not been altered.
              </t>
              <t>
                The CoAP options of the request have not been altered in any
                other way than defined in <xref target="PR1" />.
              </t>
              <t>
                The effective URI of the request is not changed.
              </t>
              <t>
                The CoAP header fields Version and Code of the request have not
                been altered.
              </t>
              <t>
                The request has not been previously received.
              </t>
              <t>
                The request was recently sent by the client.
              </t>
            </list>
          </t>
          <t>
            <vspace blankLines="1"/>
          </t>
          <t>
            The response is considered authentic by the client if:
            <list style="format A1.%d" counter="A1_count">
              <t>
                The response originates from the server.
              </t>
              <t>
                The CoAP payload, options and header fields Version and Code of
                the response have not been altered.
              </t>
              <t>
                The response has not been previously received.
              </t>
              <t>
                The response was recently sent by the server.
              </t>
              <t>
                The response corresponds to a unique request
                sent by the client.
              </t>
              <t>
                If there are multiple responses, the client should
                be able to verify that
                is the case, as well as the order of the responses.
              </t>
              
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        <section anchor="conf-1" title="Confidentiality">
          
          <t>
            This section defines when a message is considered confidentiality
            protected (cf. Threat 4 in <xref target="threat-mit"/>).
          </t>
          <t>
            A message is considered confidentiality protected if:
            <list style="format C1.%d">
              <t>
                The CoAP payload (if present) is confidentiality protected
              </t>
              <t>
                All CoAP options of the request and response, except
                Uri-Host/Port and Proxy-Uri/Scheme, are confidentiality
                protected.
              </t>
              <t>
                The keys used for confidentiality protection provides forward
                security.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section anchor="R1" title="Security Requirements">
          <t>
            This section contains the security requirements for this scenario.
            For each requirement the associated functional requirement,
            processing rule, authenticity property, or confidentiality
            property is listed.  The security requirements are:
            <list style="format R1.%d">
              
              <t>
                The server MUST authenticate a message coming
                from a requesting client (A1.1).
              </t>
              
              <t>
                The CoAP payload MUST be integrity protected and encrypted
                between client and server (A1.2, C1.1).
              </t>
              
              <t>
                The CoAP options except Uri-* and Proxy-* MUST be integrity
                protected in the request.  The effective request URI
                MUST be integrity protected in the request (PR1.1, PR1.2, A1.3,
                A1.4).
              </t>
              
              <t>
                The CoAP header fields Version and Code MUST be integrity
                protected in requests and responses.  All other header fields
                must not be integrity protected.  The header fields MUST not be
                encrypted (A1.5).
              </t>
              
              <t>
                The server MUST verify that it has not received this request
                previously (A1.6).
              </t>
              
              <t>
                The client MUST verify that the received response
                originates from the requested server (A1.8).
              </t>
              
              <t>
                The client MUST be able to verify that multiple response to a
                request are allowed as well as the order of the responses. (A.13)
              </t>
              
              <t>
                All CoAP options in the response MUST be integrity protected.
                Max-Age MUST be set to 0 (FR1.1, PR1.3).
              </t>
              
              <t>
                The client MUST verify that a response corresponds to
                a unique previous request that the client has made (A1.12).
              </t>
              
              <t>
                The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the
                request MUST not be encrypted.  The Max-Age option of the
                response MUST not be encrypted.  All other options MUST be
                encrypted (C1.2).
              </t>
              
              
              <t>
                The communication protocol MUST provide forward secrecy (C1.3).
              </t>
              
            </list>
            
          </t>
        </section>
        
      </section>
      
      
      <section title="Caching">
        
        <t>
          In this case we study caching: how a proxy may serve the same
          cached response to multiple clients requesting the same resource.
        </t>
        <t>
          The caching functionality protects communication-constrained servers
          from repeated requests for the same resources, possibly originating
          from different clients. This saves system resources, bandwidth, and
          round-trip time.
        </t>
        
        <t>
          There may be one response for each request
          (see <xref target="figure-3"/>) or multiple responses for each
          request (see <xref target="figure-observe"/>).
        </t>
        
        <section title="Examples" >
          <t>
            The first example is a simple case of caching.
          </t>
          
          <figure anchor="figure-3" title="Message Flow for Cached Responses">
            <artwork align="left">
              <![CDATA[
                Client A         Proxy           Server
                |               |               |
                |    Request    |    Request    |
                |-------------->|-------------->|--.
                |               |               |  |
                |<--------------|<--------------|<-'
                |    Response   |    Response   |
                |               |               |
                |               |
             Client B           |               |
                |               |               |
                |    Request    |               |
                |-------------->|--.            |
                |               |  | from cache |
                |<--------------|<-'            |
                |    Response   |               |
                |               |               |]]>
            </artwork>
          </figure>
          
          <t>
            <list style="hanging">
              <t hangText="Example: Caching">
                <vspace blankLines="1"/>
                In <xref target="figure-3"/>, client A requests the proxy to make a
                certain request to the server and to return the server's response.
                The proxy services the request by making a request message to the
                server according to the processing rules.  If the server returns a
                cacheable response, then the proxy stores the response in its cache,
                performs any necessary translations, and forwards it to the client.
                Later, client B makes an equivalent request to the proxy that the
                proxy services by returning the response from its cache. Both
                client A and B want to verify that the response is valid.
              </t>
            </list>
          </t>
          
          <t>
            In addition to multiple clients' requests being served by one
            response, each request may result in multiple responses.
            The difference compared to <xref target="onereq-oneres"/>
            is that in this example multiple clients may be served
            with the same response, further saving server resources.
          </t>
          
          
          <figure anchor="figure-observe" title="Message Flow for Observe with Multiple Observers">
            <artwork align="left">
              <![CDATA[Client A         Proxy          Server
                |               |               |
                |    Request    |    Request    |
                |-------------->|-------------->|--.
                |               |               |  |
                |<--------------|<--------------|<-'
                |  Notification |  Notification |
                |               |               |
                |               |
             Client B           |               |
                |               |               |
                |    Request    |               |
                |-------------->|--.            |
                |               |  | from cache |
                |<--------------|<-'            |
                |  Notification |               |
                |               |               |
                |<--------------|<--------------|
                |  Notification |  Notification |
                |               |               |
                |               |
             Client A           |               |
                |               |               |
                |<--------------|               |
                |  Notification |               |
                |               |               |]]>
            </artwork>
          </figure>
          <t>
            <list style="hanging">
              <t hangText="Example: Observe with caching">
                <vspace blankLines="1"/>
                In <xref target="figure-observe"/>, the server exposes an
                observable resource (e.g., the current
                reading of a temperature sensor).  Multiple clients are
                interested in the current state of the resource and observe
                it using the <xref target="RFC7641">CoAP resource observation
                  mechanism</xref>.  The goal is to keep the state observed by
                the clients closely in sync with the actual state of the
                resource at the server.  Another goal is to minimize the
                burden on the server by moving the task to fan out
                notifications to multiple clients from the server to the
                proxy.
              </t>
            </list>
          </t>
          
          
          </section>
          
          
          <!-- *************************************************************** -->
          
          <section anchor="FR2" title="Functional Requirements">
            <t>
              TODO: Complete the functional requirements
            </t>
            
            <t>
              <list style="format FR2.%d">
                <t>
                  The proxy MUST be able to store cacheable responses in a
                  cache.  Cacheable responses are 2.05 (Content) responses and
                  all error responses.
                </t>
                <t>
                  This proxy MUST be able to read the CoAP header, options, and
                  payload and to compute the cache key for a request.
                </t>
                <t>
                  The proxy MUST be able to return a fresh response from
                  its cache without contacting the server.
                </t>
                <t>
                  The proxy MUST be able to perform validation on a request by
                  a client and a request validation to the server (see Section
                  5.6.2 of <xref target="RFC7252"/>).
                </t>
                <t>
                  The proxy MUST be able to observe a resource on behalf of
                  one or more clients.
                </t>
              </list>
            </t>
          </section>
          
          <!-- *************************************************************** -->
          
          <section anchor="PR2" title="Processing Rules">
            <t>
              TODO: Complete the processing rules
            </t>
            
            <t>
              The proxy complies with the forwarding rules PR1.1 - 1.3
              (<xref target="PR1"/>) and the rules below.  The rules below have
              priority.
              <list style="format PR2.%d">
                <t>
                  If the proxy receives a request where the cache key matches
                  that of a cached fresh response, then the proxy discards the
                  request and replies with that response, else it makes a
                  translated request.
                </t>
                
                <t>
                  The proxy caches and forwards cacheable responses.  If there is
                  already a response in the cache with the cache key of the
                  corresponding request, then the old response in the cache is
                  marked as stale.
                </t>
                
                <t>
                  If the proxy receives a request that contains an ETag option
                  and the proxy has a fresh response with the same cache key and
                  ETag, then the proxy replies to the request with a 2.03 (Valid)
                  response without payload, else it forwards a translated request.
                </t>
                
                <t>
                  The proxy updates the Max-Age option according to the
                  Max-Age associated with the resource representation it receives,
                  decreasing its value to reflect the time spent in the
                  cache.
                </t>
                
                <t>
                  If the request contains an Accept option and if there is a
                  fresh response that matches the cache key for the corresponding
                  request except for the Accept option, and if the Content-Format
                  of the response matches that of the Accept option, then the
                  proxy forwards the cached response to the requesting client.
                </t>
              </list>
            </t>
            
          </section>
          
          <!-- *************************************************************** -->
          
          <section anchor="auth-2" title="Authenticity">
            
            <t>
              TODO: Make the analysis and write this section
            </t>
            
            <t>
              This section consider the forwarding only proxy case and defines when
              a message is considered authentic (see
              <xref target="authentic-1"/>).
            </t>
            <t>
              The request is considered authentic by the server if:
              <list style="format A2.%d" counter="A2_count">
                <t>
                  The request originates from the client
                </t>
                <t>
                  The CoAP payload of the request has not been altered.
                </t>
                <t>
                  The CoAP options of the request have not been altered in any
                  other way than defined in <xref target="PR2" />.
                </t>
                <t>
                  The effective URI of the request is not changed.
                </t>
                <t>
                  The CoAP header fields Version and Code of the request have not
                  been altered.
                </t>
                <t>
                  The request has not been previously received.
                </t>
                <t>
                  The request was recently sent by the client.
                </t>
              </list>
            </t>
            <t>
              <vspace blankLines="1"/>
            </t>
            <t>
              The response is considered authentic by the client if:
              <list style="format A2.%d" counter="A2_count">
                <t>
                  The response originates from the server.
                </t>
                <t>
                  The CoAP payload, options and header fields Version and Code of
                  the response have not been altered.
                </t>
                <t>
                  The response has not been previously received.
                </t>
                <t>
                  The response was recently sent by the server.
                </t>
                <t>
                  The response corresponds to a unique request
                  sent by the client.
                </t>
                <t>
                  If there are multiple responses, the client should
                  be able to verify that
                  is the case, as well as the order of the responses.
                </t>
                
              </list>
            </t>
            
          </section>
          
          <!-- *************************************************************** -->
          
          <section anchor="conf-2" title="Confidentiality">
            
            <t>
              TODO: Make the analysis and write this section
            </t>
            
            <t>
              This section defines when a message is considered confidentiality
              protected (cf. Threat 4 in <xref target="threat-mit"/>).
            </t>
            <t>
              A messages is considered confidentiality protected if:
              <list style="format C2.%d">
                <t>
                  The CoAP payload (if present) is confidentiality protected
                </t>
                <t>
                  All CoAP options of the request and response, except
                  Uri-Host/Port and Proxy-Uri/Scheme, are confidentiality
                  protected.
                </t>
                <t>
                  The keys used for confidentiality protection provides forward
                  security.
                </t>
              </list>
            </t>
            
          </section>
          
          <!-- *************************************************************** -->
          
          
          <section anchor="R2" title="Security Requirements">
            
            <t>
              TODO: Make the analysis and write this section
            </t>
            
            <t>
              This section contains the security requirements for this scenario.
              For each requirement the associated functional requirement,
              processing rule, authenticity property, or confidentiality
              property is listed.  The security requirements are:
              <list style="format R2.%d">
                
                <t>
                  The server MUST authenticate a message coming
                  from a requesting client (A1.1).
                </t>
                
                <t>
                  The CoAP payload MUST be integrity protected and encrypted
                  between client and server (A1.2, C1.1).
                </t>
                
                <t>
                  The CoAP options except Uri-* and Proxy-* MUST be integrity
                  protected in the request.  The effective request URI
                  MUST be integrity protected in the request (PR1.1, PR1.2, A1.3,
                  A1.4).
                </t>
                
                <t>
                  The CoAP header fields Version and Code MUST be integrity
                  protected in requests and responses.  All other header fields
                  must not be integrity protected.  The header fields MUST not be
                  encrypted (A1.5).
                </t>
                
                <t>
                  The server MUST verify that it has not received this request
                  previously (A1.6).
                </t>
                
                <t>
                  The client MUST verify that the received response
                  originates from the requested server (A1.8).
                </t>
                
                <t>
                  The client MUST be able to verify that multiple response to a
                  request are allowed as well as the order of the responses. (A.13)
                </t>
                
                <t>
                  All CoAP options in the response MUST be integrity protected.
                  Max-Age must be set to 0 (FR1.2, PR1.3).
                </t>
                
                <t>
                  The client MUST verify that a response corresponds to
                  a unique previous request that the client has made (FR1.1, A1.12).
                </t>
                
                <t>
                  The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the
                  request MUST not be encrypted.  The Max-Age option of the
                  response MUST not be encrypted.  All other options MUST be
                  encrypted (C1.2).
                </t>
                
                <t>
                  The communication protocol MUST provide forward secrecy (C1.3).
                </t>
                
              </list>
              
            </t>
          </section>
        </section>          
          
          <section title="Reverse proxy">
            
            <section title="Examples">
              <t>
                TODO
              </t>
            </section>
            
            <section anchor="FR3" title="Functional Requirements">
              <t>
                TODO
              </t>
            </section>


            <section anchor="PR3" title="Processing Rules">
              <t>
                TODO
              </t>
            </section>
            
            
            <section anchor="auth-3" title="Authenticity">
              <t>
                TODO
              </t>
            </section>
            
            <section anchor="conf-3" title="Confidentiality">
              <t>
                TODO
              </t>
            </section>
            
            <section anchor="R-3" title="Security Requirements">
              <t>
                TODO
              </t>
            </section>
          </section>
          
          
          
          
          <section title="Summary">
            
            <t>
              TODO
            </t>
            <figure>
              <artwork>
                <![CDATA[
 +-------------- Forwarding
 |   +---------- Caching
 |   |   +------ Reverse Proxy
 |   |   |   +--  . . .
 |   |   |   |
 V   V   V   V]]>
            </artwork>
          </figure>
          <t>
            <list style="hanging" hangIndent="17">
              <t>--- Server ---</t>
              <t hangText="(x) (x) ( ) ( )">The server must authenticate a message coming from a requesting client. (R1.1)</t>
              <t hangText="(x) (x) ( ) ( )">The server must verify that it has not received this request previously. (R1.2)</t>
              <t>--- Client ---</t>
              <t hangText="(x) (x) (x) (x)">The client must verify that the received response originates from the requested server. (R1.3) The client must be able to verify that a received resource representation originates from the requested server. (R3.1)</t>
              <t hangText="(x) ( ) ( ) ( )">The client must verify that a response corresponds uniquely to a previous request that the client has made. (R1.4)</t>
              <t hangText="( ) (x) ( ) ( )">The client must verify that a response corresponds to a previous request that the client has made. (R2.1)</t>
              <t hangText="( ) (x) ( ) ( )">The client must verify that it has not received this response previously and whether responses for the same request are received in the wrong order. (R2.2)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to verify that a received representation is a representation of the resource requested by the client. (R3.2)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to verify the content format of the representation. (R3.3)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to detect that a received representation is fresh. (R3.4)</t>
              <t>--- Encrypted and Integrity Protected Parts ---</t>
              <t hangText="(x) (x) (x) (x)">The payload must be integrity protected and encrypted between client and server. (R1.5) The representation must be integrity protected and encrypted from the server to the client. (R3.5)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP options except Uri-* and Proxy-* must be integrity protected in the request.  The effective request URI must be integrity protected in the request. (R1.6)</t>
              <t hangText="(x) (x) ( ) ( )">All CoAP options in the response must be integrity protected. Max-Age must be set to 0. (R1.7)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the request must not be encrypted.  The Max-Age option of the response must not be encrypted.  All other options must be encrypted. (R1.8)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP header fields Version and Code must be integrity protected in requests and responses.  All other header fields must not be integrity protected. The header fields must not be encrypted. (R1.9)</t>
              <t>--- Miscellaneous ---</t>
              <t hangText="(x) (x) (x) (x)">The communication protocol must provide forward secrecy. (R1.10) (R3.7)</t>
              <t hangText="( ) ( ) (x) (x)">To protect against the proxy colluding with an authorized client, asymmetric cryptography must be used. (R3.6)</t>
            </list>
          </t>
          
        </section>
        
      </section>
    
    
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    
    
    <section title="Publish-Subscribe" anchor="pubsub-case">
      
      <t>
        The intermediate node in scope of this section is the pubsub-broker,
        see <xref target="I-D.koster-core-coap-pubsub"/>.
      </t>
      
      <section title="Broker Operations">
        <t>
          A publisher makes publications available to a
          broker and the subscriber requests and receives publications from the
          broker. This corresponds to the intermediary node operation case 2,
          with the subscriber being client, see
          <xref target="node-operations"/>.
        </t>
        <t>
          There are different ways for the broker to operate:
          <list style="format %C." counter="letter-count">
            <t>
              The broker requests a publication from the publisher and
              receives the publication in the response,
              see <xref target="fig-broker-req"/>. The publisher is origin server.
              The broker may observe
              publication resources at the publisher.
            </t>
          </list>
        </t>
        
        <figure anchor="fig-broker-req" title="Case A. Broker
          Requests Publication.">
          <artwork align="left">
            <![CDATA[
 ____________             __________             ___________
|            |  Request  |          |    GET    |           |
|            |---------->|          |---------->|           |
| Subscriber |           |  Broker  |           | Publisher |
|            |<----------|          |<----------|           |
|____________|  Response |__________|  Response |___________|

            ]]>
          </artwork>
        </figure>
        
        <t>
          <list style="format %C." counter="letter-count">
            <t>
              The broker receives a publication request with the publication from
              the publisher and responds with a confirmation response,
              see <xref target="fig-publisher-req"/>. The publisher is client.
            </t>
          </list>
        </t>
        
        <figure anchor="fig-publisher-req" title="Case B. Publisher
          Requests Publication.">
          <artwork align="left">
            <![CDATA[
 ____________             __________             ___________
|            |  Request  |          |    PUT    |           |
|            |---------->|          |<----------|           |
| Subscriber |           |  Broker  |           | Publisher |
|            |<----------|          |---------->|           |
|____________|  Response |__________|  Response |___________|

            ]]>
          </artwork>
        </figure>
        <t>
          Different trust models are possible. We consider the publisher-to-subscriber
          security setting where the brokers are not trusted except for performing its intended
          functionality. In contrast to the case with trusted brokers, the creation
          and deletion of topics and other endpoint-to-broker operations are out of scope.
        </t>
        <t>
          Trusted third parties and trust anchors may be used in this setting to
          allow the subscriber to verify publications of multiple publishers
          without having a pre-established security association with all potential
          publishers.
        </t>
      </section>
      
      <!-- **************************************************************** -->
      
      <section title="Threats and Mitigation">
        
        <t>
          The general threats and mitigation in <xref target="threat-mit"/> apply
          to the publish-subscribe setting. The threats to the subscriber carry
          over from the threats to the client, <xref target="client-end"/>.
          Case A corresponds to the publisher being server
          (<xref target="server-end"/>). We focus here on Case B, corresponding to
          the publisher being client (<xref target="client-end"/>).
        </t>
        <t>
          The same general conclusions apply:
          <list style="symbols">
            <t>
              The security solution MUST protect against threats to authenticity
              and confidentiality as defined in the next section.
            </t>
            <t>
              Mitigation for spoofing of error messages or other legitimate messages
              originating from the broker are not in scope of the security
              solution.
            </t>
            <t>
              Plain text of message data SHOULD be restricted to what the broker
              needs to read, and the application SHOULD mitigate the possibility
              to do traffic analysis.
            </t>
          </list>
          
        </t>
      </section>
      
      <section title="Brokering">
      
      <section title="Example" >
        <t>
          TODO, if necessary.
        </t>
        
      </section>
      
      <section anchor="FR4" title="Functional Requirements">
        
        <t>
          <list style="format FR4.%d">
            <t>
              The broker MUST be able to transfer the publication in the PUT request
              from the publisher to a GET response to the subscriber.
            </t>
            <t>
              The broker MUST be able to read the Uri-Path/Query of a request.
            </t>

          </list>
        </t>
      </section>
      
      <!-- *************************************************************** -->
      
      <section anchor="PR4" title="Processing Rules">
        <t>
          TODO: Complete the processing rules
        </t>
        
        <t>
          <list style="format PR4.%d">
            <t>
              If the broker receives a subcription request for one of its resources,
              then the broker associates the requesting subscriber to the topic and
              responds with the current representation.
            </t>
            
            <t>
              If the broker receives a publication request to one of its
              resources, then the broker stores the received representation
              on the topic and responds with the representation to the
              associated subscribers of that topic.
            </t>
          
          </list>
        </t>
        
      </section>
      
      <!-- *************************************************************** -->
      
      <section anchor="auth-4" title="Authenticity">
        
        <section title="Subscriber">
          
          <t>
            The publication is considered authentic by the subscriber if:
            <list style="format A4.%d" counter="A4_count">
              <t>
                The publication originates from the publisher.
              </t>
              <t>
                The publication/CoAP GET response payload has not been altered.
              </t>
              <t>
                The publication corresponds to the topic requested by the subscriber.
              </t>
              <t>
                The publication is fresh, as defined by the application.
              </t>
              <t>
                The subscriber can verify the order of the publications.
              </t>
            </list>
          </t>
          
        </section>
        
        <section title="Publisher">
          
          <t>
            In contrast to the previous section, the publisher does not receive any
            data from the subscriber. Since the only security association is
            between publisher and subscriber, the publisher cannot get
            any trustworthy information out of the communication with the broker.
          </t>
          <t>
            Thus it is not possible for the publisher to verify the response
            to the publication request. Hence mitigation of spoofing a publication
            response is not in scope.
          </t>
          
        </section>
        
      </section>
      
      <!-- *************************************************************** -->
      
      <section anchor="conf-4" title="Confidentiality">
        
        <t>
          The message is considered confidentiality
          protected if the CoAP payload with the publication is confidentiality
          protected. This applies to the the publisher PUT request and the
          subscriber GET response.
        </t>
        <t>
          Since the security association is between publisher and subscriber,
          mitigation of eavesdropping a publication response is not in scope.
        </t>
      
      </section>
      
      <!-- *************************************************************** -->
      
      
      <section anchor="R4" title="Security Requirements">
        
        <t>
          TODO: Make the analysis and write this section
        </t>
        
        <t>
            This section contains the security requirements for this scenario.
          For each requirement the associated functional requirement,
          processing rule, authenticity property, or confidentiality
          property is listed.  The security requirements are:
          <list style="format R4.%d">
            
            <t>
              The server MUST authenticate a message coming
              from a requesting client (A1.1).
            </t>
            
            <t>
              The CoAP payload MUST be integrity protected and encrypted
              between client and server (A1.2, C1.1).
            </t>
            
            <t>
              The CoAP options except Uri-* and Proxy-* MUST be integrity
              protected in the request.  The effective request URI
              MUST be integrity protected in the request (PR1.1, PR1.2, A1.3,
              A1.4).
            </t>
            
            <t>
              The CoAP header fields Version and Code MUST be integrity
              protected in requests and responses.  All other header fields
              must not be integrity protected.  The header fields MUST not be
              encrypted (A1.5).
            </t>
            
            <t>
              The server MUST verify that it has not received this request
              previously (A1.6).
            </t>
            
            <t>
              The client MUST verify that the received response
              originates from the requested server (A1.8).
            </t>
            
            <t>
              The client MUST be able to verify that multiple response to a
              request are allowed as well as the order of the responses. (A.13)
            </t>
            
            <t>
              All CoAP options in the response MUST be integrity protected.
              Max-Age must be set to 0 (FR1.2, PR1.3).
            </t>
            
            <t>
              The client MUST verify that a response corresponds to
              a unique previous request that the client has made (FR1.1, A1.12).
            </t>
            
            <t>
              The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the
              request MUST not be encrypted.  The Max-Age option of the
              response MUST not be encrypted.  All other options MUST be
              encrypted (C1.2).
            </t>
            
            <t>
              The communication protocol MUST provide forward secrecy (C1.3).
            </t>
            
          </list>
          
        </t>
          <t>
            Note that a CoAP server like the broker is specified to
            return an error response (such as 4.04 Not Found or 5.03
            Service Unavailable) when it encounters an error
            condition. Since the condition occurs at the broker and
            not at the publisher, the response will not be an
            "authentic response" according to the above definition.
            Thus a subscriber cannot tell if the broker sends the
            error response according to specification or if it spoofs
            the response. This threat is NOT REQUIRED to be mitigated
            by the security solution.
          </t>

      </section>
    
    
      </section>

    </section>


    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section anchor="sec-cons" title="Security Considerations">

      <t>
        A proxy or intermediary may be an aggregation point for message flows.
        Therefore it is an attractive target, both from a security and privacy
        point of view.
      </t>
      
      <t>
        Unless the security mechanisms provide forward secrecy, a
        compromise of long term keying material means that an attacker can
        decrypt all previously sent information and can be directly used for
        any kind of manipulation of the cyber-physical system.
      </t>
      
      <t>
        Therefore the key exchange mechanism used for establish keys to use with
        application layer security must provide forward secrecy.
      </t>
      
      <t>
        Intermediary nodes are aggregation points also for metadata and
        therefore valuable targets for signal intelligence agencies.
        Pervasive monitoring is an attack <xref target="RFC7258"/> and the 
        effect of collecting and correlating information from multitude of 
        proxies must be mitigated.
      </t>
      
      <t>
        Related to this, it is needed to delete all historical information
        from all nodes handling the plaintext data and metadata, in order
        to avoid information leakage.  The impact of this on the intermediary
        nodes can be limited by confidentiality protecting as much as
        possible between the endpoints.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    

    <section title="IANA Considerations">

      <t>
        This document includes no request to IANA.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC2119;

      &RFC7252;
      
      &RFC7258;
      
      &RFC7641;

    </references>

    <references title="Informative References">

      &RFC6347;

      &RFC7228;
      
      &I-D.ietf-cose-msg;
      
      &I-D.mattsson-core-coap-actuators;
      
      &I-D.koster-core-coap-pubsub;

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Scope and Assumptions">

      <t>
        This document presents a number of scenarios involving sensor
        and actuator communications over CoAP.  Common to all scenarios is the
        presence of at least one CoAP intermediary, typically in the form
        of a proxy between
        a client requesting a resource and a server hosting a resource
        (see <xref target="figure-0"/>).
        The proxy is responsible, for example, for reducing response time and
        network bandwidth use by serving responses from a cache or for enabling 
        the client to make requests that it otherwise could not make.
      </t>

      <figure anchor="figure-0" title="CoAP Message Exchanges Through A Proxy">
        <artwork align="center">
<![CDATA[ __________   Request    _________              __________
|          | ---------> |         |  Request   |          |
|          |            |         | ---------> |          |
|  Client  |            |  Proxy  |            |  Server  |
|          |            |         | <--------- |          |
|__________| <--------- |_________|  Response  |__________|
               Response]]>
        </artwork>
      </figure>
      
      <t>
        The basic function of a proxy
        is to forward translated messages according to certain processing rules.
        For example:
        
        <list style="symbols">
          <t>
            Forward a message to the next proxy when the link is up
          </t>
          <t>
            Only forward a request if there is no fresh cached response
          </t>
          <t>
            Forward a new publication to all subscribing clients
          </t>
        </list>
      </t>
 
      <t>
        In order to perform its function, a proxy may be required to read or
        change certain parts of a CoAP message as defined in <xref target="RFC7252"/>.
        For example, a forward proxy is defined to transform
        the Proxy-Uri option to Uri-Host, Uri-Port, Uri-Path and Uri-Query
        options. A proxy caching responses needs to read the Cache Key and
        must be able to change the Max-Age option in the responses.
      </t>
      
      <t>
        Since a proxy might not be fully trusted, a security solution is needed
        that protects the client, the server and the message exchanges against
        certain threats while still allowing the proxy to assume its normal
        functionality. The client and server are assumed to have a security
        association, but the proxy is neither assumed to have a security 
        association with the client nor with the server.  
      </t>
      
      <figure anchor="fig-forward-proxy" 
              title="Security Association Between Client and Server">
        <artwork align="center">
<![CDATA[ __________     ___________                     __________
|          | > |           | Requests >        |          |
|  Client  |___|  Forward  |___________________|  Origin  |
|          |   |   Proxy   |                   |  Server  |
|__________| < |___________|       < Responses |__________|
      :                                             :
      '---------------------------------------------'
                   Security Association]]>
        </artwork>
      </figure>
      
      <t>
        For a start, this document considers the following two cases:
        Forward proxies (as specified in <xref target="RFC7252"/>;
        <xref target="fig-forward-proxy"/>)
        and publish-subscribe brokers (as specified in
        <xref target="I-D.koster-core-coap-pubsub"/>;
        <xref target="fig-broker"/>).  The functionality 
        assumed by these nodes is summarized in the 
        respective scenarios analyzed in this document (<xref
        target="analysis"/>).
      </t>
    
      <figure anchor="fig-broker" 
              title="Security Association Between Publisher and Subscriber">
        <artwork align="center">
<![CDATA[ ____________            __________            ___________
|            |    >     |          |     <    |           |
| Subscriber |__________|  Broker  |__________| Publisher |
|  (Client)  |          | (Server) |          | (Client)  |
|___________ |    <     |__________|     >    |___________|
     :                                              :
     '----------------------------------------------'
                   Security Association]]>
        </artwork>
      </figure>

      <t>
        [TODO: Reverse proxy and cross-protocol proxies will be added
        in a future version of this document.]
      </t>
      
      <t>
        To identify the threats in scope, we first consider what assets need to
        be protected.  In general, there are the following types of assets to
        protect:
        <list style="format A%d:" counter="my_count">
          <t>
            The devices at the two ends, the data generated and stored in
            these devices, and their (often very
            constrained) system resources such as available memory, storage,
            processing capacity, and energy.
          </t>
          <t>
            The physical environment of the devices fitted with sensors
            and actuators.  Access to the physical environment is
            provided through CoAP resources that allow a remote entity
            to retrieve information about the physical environment
            (such as the current temperature) or to produce an effect
            on the physical environment (such as the activation of a
            heater).
          </t>
          <t>
            The communication infrastructure linking the two devices
            (which often contains some very constrained parts) and the data
            stored in the message processing devices.
          </t>
        </list>
      </t>
      
      <t>
        The scope of this document is to analyze threats executed through
        proxies and brokers, and this is only directly affecting the assets of
        type A3, e.g., if a proxy is dropping all messages.
      </t>
      
      <t>
        However, the intermediary node may manipulate the messages exchanged
        between the endpoints and thereby have an impact also on the assets A1 
        and A2, for example: flooding a device with messages has impact on its 
        system resources, and successful manipulation of an actuator command, 
        carried in a message, has an impact on the physical environment.  We 
        therefore define a fourth asset, which is the main target being evaluated
        in this document:
      </t>
      
      <t>
        <list style="format A%d:" counter="my_count">
          <t>
            The messages exchanged between a client and a server, through the
            proxy.  This includes the CoAP header and options in
            request and response messages (such as the requested method
            or the target URI) and the CoAP resource representations,
            encapsulated in the message payload.
          </t>
        </list>
      </t>
      
      <t>
        A fully trusted proxy, handling unprotected messages, is an attractive 
        target, since proxies are aggregation points for message flows (see 
        <xref target="sec-cons"/>) and they may be an easier target from the 
        Internet than the sensors/actuators residing behind them.  A proxy may 
        become subject to intrusion or become infected by malware and perform 
        the attacks of a man-in-the-middle.  The attack vectors for 
        compromising a proxy are out of scope for this
        document.
      </t>
      
      <t>
        The scope of the threat analysis is
        restricted to threats from proxies to single client to server
        interactions.  Threats resulting from collusion between multiple
        proxies are also out of scope (see <xref target="sec-cons"/>).
      </t>
      
      <t>
        On a high level, there are the following threats from proxies
        to consider:
        <list style="format T%d:">
          <t>
            The proxy illegitimately modifies a message.
          </t>
          <t>
            The proxy illegitimately sends a message,
            including replay, flooding, etc.
          </t>
          <t>
            The proxy illegitimately inhibits sending of a message,
            including delay, reordering, etc.
          </t>
          <t>
            The proxy illegitimately reads part of a message.
          </t>
        </list>
      </t>
      
      <t>
        To assess how such threats impact the assets, we need to specify
        the processing rules of the intermediary nodes in different scenarios
        and define the associated security objectives.
      </t>
      
      
     
    </section>
    
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    
    <section anchor="analysis" 
             title="Scenarios, Threats and Security Requirements">
      
      <t>
        In this section we consider a set of scenarios involving proxies and 
        brokers, with different processing rules and security objectives.  We 
        study the associated threats and derive the security requirements for 
        message transfer between client and server, in the different scenarios.
      </t>
      
      <t>
        Note that, since CoAP was not designed for end-to-end security,
        solutions complying with these security requirements extend the 
        applicability of CoAP beyond its original scope.
      </t>
      
      <t>
        To simplify the analysis, the scenarios are structured according to how
        requests and responses are related to each other:
        <list style="hanging">
          <t hangText="One Request - One Response">
            <vspace />
            There is a one-to-one relation between request and response.
          </t>
          <t hangText="One Request - Multiple Responses">
            <vspace />
            A request may have multiple responses, but each response is securely
            linked to a unique request.
          </t>
          <t hangText="Multiple Requests - One Response">
            <vspace />
            One response may serve multiple requests, but each request has a 
            single response.
          </t>
          <t hangText="Multiple Requests - Multiple Responses">
            <vspace />
            One response may serve multiple requests, and each request may have
            multiple responses.
          </t>
        </list>
      
      </t>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
      
      <section anchor="onereq-oneres-" title="One Request - One Response">
        
        <t>
          In this scenario we study use cases where it is important that a 
          response sent from one endpoint is the response to a particular
          request to that endpoint.  Many security critical use cases require
          that responses are in this way "securely linked" to requests, such as
          alarm status retrieval and actuator command confirmation.
        </t>
        <t>
          In this scenario there must be a unique response for each request.
        </t>
        
        
        <figure anchor="figure-x" title="Message Flow with a Unique Response for Each Request">
          <artwork align="center">
<![CDATA[Client          Proxy          Server
  |               |               |
  |    Request    |    Request    |
  |-------------->|-------------->|--.
  |               |               |  |
  |<--------------|<--------------|<-'
  |    Response   |    Response   |
  |               |               |]]>
          </artwork>
        </figure>
        
        
        <t>
          <list style="hanging">
            <t hangText="Example: Alarm status retrieval">
            <vspace blankLines="1"/>
              <xref target="figure-1"/> can be seen as an illustration of a 
              message exchange for a client requesting the alarm status (e.g.,
              GET /alarm_status) from a server.  Since the client wants to ensure
              that the alarm status received is reflecting the current alarm
              status and not a cached or spoofed response to the same
              resource, it must be able to verify that the received response is
              a response to this particular request made by the client.
              Therefore the response must be securely linked to the request.
            </t>
            <t hangText="Example: Actuation confirmation">
            <vspace blankLines="1"/>
              Another example for which <xref target="figure-1"/> serves as
              illustration is the confirmation of an actuator request.  In this 
              case a client, say in an industrial control system, requests a 
              server that a valve should be turned to a certain level, e.g. PUT
              /valve_42/level with payload "3".  In order for the client to 
              correctly evaluate the result of a potential changed valve level,
              it is important that the client gets a confirmation how the 
              server responded to the requested change, e.g., whether the request
              was performed or not.  Again, the client wants to ensure that the 
              response is reflecting the result of this particular actuation 
              request made by the client and not a cached or spoofed response.
              Therefore the response must be securely linked to the request.
            </t>
          </list>
        </t>
        
        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              Since each response is intended to be securely linked to a 
              particular request, the response must not be used with any 
              other request.  Hence, as much as possible of the caching 
              functionality must be inhibited.  Therefore the CoAP option 
              Max-Age of the responses is set to 0 (see Section 5.7.1 of 
              <xref target="RFC7252"/>).
            </t>
          </list>
        </t>
        

        <!-- *************************************************************** -->
        
        <section anchor="PRx" title="Processing Rules">
          <t>
            In this scenario, the desired proxy functionality is
            to forward a translated request to the determined destination.
            There are two modes of operation for requests:
            Either using the Proxy-Uri option (PR1.1) or using the
            Proxy-Scheme option together with the Uri-Host, Uri-Port,
            Uri-Path and Uri-Query options (PR1.2).
            <list style="format PR1.%d">
              <t>
                The Proxy-Uri option contains the request URI
                including request scheme (e.g. "coaps://"); the
                Proxy-Scheme and Uri-* options are not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another proxy, then it keeps the Proxy-Uri
                option; otherwise, it splits the option into its
                components, adds the corresponding Uri-* options and
                removes the Proxy-Uri option.
                Then it makes the request using the request scheme
                indicated in the Proxy-Uri.
              </t>
              <t>
                The Proxy-Scheme option
                and the Uri-* options together contain the request URI;
                the Proxy-Uri option is not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another forwarding proxy, then it keeps the
                Proxy-Scheme and Uri-* options; otherwise, it removes
                the Proxy-Scheme option.  Then it makes the request
                using the request scheme indicated in the removed
                Proxy-Scheme option.
              </t>
              <t>
               Responses are forwarded by the proxy, without any modification.
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="SOx" title="Security Objectives">
          <t>
            In this scenario there is a unique response for each request, so the
            client should be able to verify that a certain response is made in
            response to a specific request sent by the client.
          </t>
          <t>
            The server should be able to verify that the proxy only has
            performed the message modifications intended
            by the client according to the processing rules.
          </t>
          <t>
            The proxy should be prevented from reading or making modifications
            to messages apart from what is necessary to perform the processing 
            rules (cf. <xref target="RFC7258"/>).
          </t>
          <t>
            The security objectives are:
            <list style="format SO1.%d">
              <t>
                The server is able to verify that a received request originates
                from a client with which it has a security association, and that
                the request has not been received before.
              </t>
              <t>
                The server is able to verify that the received request either
                has not been altered in transfer, or that the request is 
                modified according to the processing rule PR1.1 or PR1.2 (<xref target="PR1"/>).
              </t>
              <t>
                The server is able to protect the response such that only
                authorized clients can read the response.
              </t>
              <t>
                The client is able to verify that the received response
                originates from the requested server and resource,
                that it has not been altered in transfer, and that it was
                generated as the unique response to the request.
              </t>
              <t>
                The proxy is only able to read data needed to perform
                the processing rules.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now list potential threats and discuss candidate mitigation 
            mechanisms.
          </t>
          
          <section anchor="T1:1" 
                   title="T1:The proxy illegitimately modifies a message">
            <t>
              <list style="format T1:1.%d">
                <t>
                  The proxy forwards a request with modified payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The proxy forwards a response with modified payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The proxy forwards a request with modified CoAP option
                  <vspace blankLines="1"/>
                  Note that the proxy is entitled to change certain options by
                  processing rules PR1.1 and PR1.2.  Since the change is
                  predictable, the effective request URI can be
                  integrity protected by the client and verified by the server.
                  The other CoAP options in the request can be integrity
                  protected.
                </t>

                <t>
                  The proxy forwards a response with modified CoAP option
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  CoAP options. Since Max-Age is set to 0 the proxy is not 
                  entitled to change any options in the response so they can 
                  all be integrity protected.
                </t>
                
                <t>
                  The proxy forwards a request with changed CoAP header fields
                  <vspace blankLines="1"/>
                  The proxy is entitled to change certain header fields (e.g., the
                  token) as part of its normal operations.  Malicious changes to
                  message layer parameters may cause a denial-of-service,
                  equivalent of dropping a message or sending spoofed messages.
                  This is difficult to mitigate.  However, changing the CoAP
                  header Code (e.g., from GET to DELETE) may result in an error
                  or wrong interpretation of the request which can have other
                  security implications.  A change to the Version header field
                  may result in security errors in the interaction between
                  different versions of CoAP.  These threats can be mitigated
                  by integrity protecting the Code and Version header fields.
                </t>
                
                <t>
                  The proxy forwards a response with changed CoAP header fields
                  <vspace blankLines="1"/>
                  Similar to previous threat. Some aspects of this threat can 
                  be mitigated by integrity protecting the Code and Version 
                  header fields.
                </t>
                
                <t>
                  The proxy forwards a different request
                  <vspace blankLines="1"/>
                  If the forwarded request is from another client it can be 
                  mitigated by having different security associations with 
                  different clients.  If the forwarded request is from the same
                  client but with differences in payload, options or header, 
                  then this coincides with previously listed threats.  A proxy 
                  sending old requests (or reordering requests) from the same 
                  client to the same server resource can be mitigated by
                  integrity protecting a freshness parameter (timestamp, 
                  counter, etc.) from which the order of requests can be 
                  deduced (replay/reordering protection).
                </t>
                
                <t>
                  The proxy forwards a different response 
                  <vspace blankLines="1"/>
                  By integrity protecting uniquely identifying information of 
                  the request in the response, the client can verify that the
                  response was generated in reply to a particular request.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section anchor="T2:1" 
                   title="T2:The proxy illegitimately sends a message">
            <t>
              <list style="format T2:1.%d">
                
                <t>
                  The proxy sends a request to the server without a previous
                  request from the client
                  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity- and replay
                  protection.
                </t>
                
                <t>
                  The proxy sends a response to the client without a previous
                  response from the server
                  <vspace blankLines="1"/>
                  Error messages from the proxy such as 5.02 (Bad Gateway)
                  originate from the proxy.  A proxy maliciously sending error
                  messages is a denial-of-service attack similar to not
                  forwarding a message (T3:1.1) and is difficult to mitigate.
                  However, responses claiming to be from the server may be
                  mitigated with integrity protection uniquely identifying
                  information of the request.
                </t>
                
                <t>
                  A proxy sends a number of messages for the purpose of flooding
                  client or server
                  <vspace blankLines="1"/>
                  By verifying the integrity, the client and server may
                  mitigate certain flooding attacks.  The server can use the 
                  replay/reordering protection to verify which messages are 
                  legitimate and the client can verify if a message is a 
                  response to a previously sent request.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:1" 
            title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:1.%d">
                <t>
                  The proxy does not forward a message
                  <vspace blankLines="1"/>
                  This is a denial-of-service attack. While these kind of 
                  threats may be difficult to mitigate, applications should 
                  have a readiness for this kind of issues and a client
                  is able to detect a missing response.
                </t>
                
                <t>
                  The proxy delays forwarding of a received message
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so they
                  may be difficult to detect and mitigate.
                  However, delayed requests and responses can also be used in
                  attacks against actuators; see 
                  <xref target="I-D.mattsson-core-coap-actuators"/>.  These 
                  attacks can be performed by an on-path attacker and are not 
                  restricted to proxies. The proposed mitigation is based on
                  verifying the timeliness of the request, for example, by using 
                  time stamps or with an additional round-trip. These 
                  mitigations can be supported by a new CoAP option containing 
                  time stamp or binding the response in a first round-trip to a
                  request of the second, as specified in 
                  <xref target="I-D.mattsson-core-coap-actuators"/>.
                  By integrity protecting that new CoAP option, the threat can 
                  be mitigated.
                </t>
                
                <t>
                  The proxy reorders the requests
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting a freshness parameter from which the
                  order of requests can be deduced.
                </t>
                
                <t>
                  The proxy reorders the responses
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting information specifying to which request a
                  response belongs.
                </t> 
              </list>
            </t>
          </section>
          
          <section anchor="T4:1" 
                   title="T4:The proxy illegitimately reads part of a message">
            <t>
              <list style="format T4:1.%d">
                <t>
                  The proxy reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the payload.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP options
                  <vspace blankLines="1"/>
                  The proxy only needs to read the Uri-Host/Uri-Port and
                  Proxy-Uri/Proxy-Scheme options of a request.  The information
                  revealed by these parameters is public on network layer.
                  The proxy only needs to read Max-Age of the response, which is
                  set to 0 as indicated in the functional requirements.
                  This threat can be mitigated by encrypting all other options.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP header fields
                  <vspace blankLines="1"/>
                  The header fields needs to be transferred in plain text to 
                  allow normal CoAP operations.  The Code parameter reveals 
                  information about what RESTful action is requested.  This 
                  information leakage is difficult to mitigate.
                </t>
                
                <t>
                  The proxy reads and stores all message exchanges and can
                  deduce information about the entire history of the corresponding
                  interactions
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encrypting as much as possible
                  of the data transferred between client and server.
                  The case of long term key compromise can be mitigated with
                  forward secrecy.
                  
                  
                </t>

              </list>
            </t>
          </section>

        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="Rx" title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for this scenario.  For each requirement and non-requirement the
            associated threats are listed.  The security requirements are:
            <list style="format R1.%d">
              
              <t>
                The server must authenticate a message coming
                from a requesting client (T1:1.1, T1:1.3, T1:1.5, T2:1.1).
              </t>
              
              <t>
                The server must verify that it has not received this request
                previously (T1:1.7, T3:1.3).
              </t>
              
              <t>
                The client must verify that the received response
                originates from the requested server (T1:1.2, T1:1.4, T1:1.6, 
                T2:1.2).
              </t>
              
              <t>
                The client must verify that a response corresponds uniquely to
                a previous request that the client has made (T1:1.8, T3:1.4).
              </t>
              
              <t>
                The payload must be integrity protected and encrypted
                between client and server (T1:1.1-6,T4:1.1, T2:1.3, T4:1.1, 
                <xref target="RFC7258"/>).
              </t>
              
              <t>
                The CoAP options except Uri-* and Proxy-* must be integrity
                protected in the request.  The effective request URI
                must be integrity protected in the request (T1:1.3).
              </t>
              
              <t>
                All CoAP options in the response must be integrity protected.
                Max-Age must be set to 0 (T1:1.4).
              </t>
              
              <t>
                The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the 
                request must not be encrypted.  The Max-Age option of the 
                response must not be encrypted.  All other options must be
                encrypted (T4:1.2).
              </t>
              
              
              <t>
                The CoAP header fields Version and Code must be integrity 
                protected in requests and responses.  All other header fields 
                must not be integrity protected.  The header fields must not be
                encrypted (T1:1.5, T4:1.3).
              </t>
              
              <t>
                The communication protocol must provide forward secrecy (T4:1.4).
              </t>
              
            </list>
            
            The security non-requirements of this scenario are:
            
            <list style="format NR1.%d">
              <t>
                The proxy may drop messages without the endpoint being able to
                infer that the message is lost due to the proxy (T3:1.1).
              </t>
              
              <t>
                The proxy may delay messages without being detected 
                (T3:1.1, T3:1.2).
              </t>
              
              <t>
                The proxy may read the CoAP header including message layer
                parameters and Code, revealing the kind of RESTful action being
                requested and the response code (T4:1.3).
              </t>
            </list>
            
          </t>
        </section>
        
        
      </section>
      
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      <section anchor="onereq-mulres" title="One Request - Multiple Responses">
        
        <t>
          In this scenario we study use cases where it is important that a 
          response is securely linked to a request as in the previous
          scenario, but where there may be multiple responses for each request.
          This functionality protects communication-constrained servers from
          repeated requests from the same client and thus saves system
          resources and bandwidth.  This is useful in security critical
          monitoring scenarios where time synchronization cannot be
          guaranteed.
        </t>
        
        <figure anchor="figure-y" title="Message Flow of a Notification">
          <artwork align="center">
<![CDATA[Client          Proxy          Server
  |               |               |
  |    Request    |    Request    |
  |-------------->|-------------->|--.
  |               |               |  |
  |<--------------|<--------------|<-'
  |  Notification |  Notification |
  |               |               |
  |<--------------|<--------------|
  |  Notification |  Notification |
  |               |               |
  |<--------------|<--------------|
  |  Notification |  Notification |
  |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          
          
          <list style="hanging">
            <t hangText="Example: Secure parameter monitoring">
              <vspace blankLines="1"/>
              <xref target="figure-2"/> can be seen as an illustration of a
              message exchange for a client monitoring an important parameter measured by the
              server, e.g., in a medical or process industry application.
              The client makes a subscription request for a resource
              and the server responds with notifications, thereby providing
              updates to the parameter in regular time intervals.
            </t>
            <t>
              The client wants to ensure that first received notification 
              reflects the current parameter value and that subsequent 
              notifications are timely updates of the initial request.  Since 
              notifications may be lost or reordered, the client needs to be 
              able to verify the order of the messages, as sent by the server.
              By monitoring the received messages and the time they are
              received, the client can detect missing notifications and take
              appropriate action.
            </t>
          </list>
        </t>
        
        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              The same functional requirement apply as in the previous scenario
              (<xref target="onereq-oneres"/>).
            </t>
          </list>
        </t>
        
        
        <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          
          <t>
            The processing rules are identical to PR 1.1 - 1.3 of the previous
            scenario (<xref target="PR1"/>).
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          <t>
            The security
            objectives are similar to the previous scenario.  Each response
            maps to a unique request, but there may be multiple responses to
            one request.  By ordering the responses, each message in this 
            exchange can be made unique.
          </t>
          <t>
            The security objectives of the previous scenario
            (<xref target="SOx"/>) are valid except for SO1.4 which is replaced by
            the following objectives:
            <list style="format SO2.%d">
              <t>
                The client is able to verify that the received response
                originates from the requested server and resource,
                that it has not been altered in transfer, and that it was
                generated as one in a sequence of responses to the request.
              </t>
              <t>
                The client is able to verify the order of the responses and if
                a response is missing.
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            The threat analysis from the previous scenario carries over
            with a few exceptions.
          </t>
          
          <section anchor="T1:2"
                   title="T1:The proxy illegitimately modifies a message">
            <t>
              Similar conclusions apply as in the previous scenario 
              (<xref target="T1:1"/>).  However, note that in T1:1.8, a proxy 
              may maliciously reorder the responses to the same request without
              being detected.  The mitigation specified in the previous
              scenario (that the client verifies the response is linked to the
              request) is not sufficient since there may be multiple responses.
            </t>
            <t>
              However, analogous to how requests are protected against
              replay/reordering in the previous scenario, by additionally
              integrity protecting a parameter from which the
              order of responses can be deduced, this threat can be mitigated.
            </t>
          </section>
          
          
          <section title="T2:The proxy illegitimately sends a message">
            <t>
              Similar conclusions apply as in the previous scenario 
              (<xref target="T2:1"/>).  T2:1.3 can be mitigated with the
              additional replay/reordering protection of responses as mentioned
              in <xref target="T1:2"/>.
           </t>
          </section>
          
          <section 
              title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              Similar conclusions apply as in the previous scenario 
              (<xref target="T3:1"/>).  T3:1.4 can be mitigated with the
              additional replay/reordering protection of responses as mentioned
              in <xref target="T1:2"/>.
            </t>
          </section>
          
          <section title="T4:The proxy illegitimately reads part of a message">
            <t>
              The same conclusions apply as in the previous scenario 
              (<xref target="T4:1"/>).
            </t>
          </section>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            The security requirements of the previous scenario
            (<xref target="R1"/>) are valid except for R1.4 which is replaced by
            the following requirements:
          </t>
          
          
          <t>
            <list style="format R2.%d">
              
              <t>
                The client must verify that a response corresponds to a
                previous request that the client has made (T1:1.8, T3:1.4).
              </t>
              
              <t>
                The client must verify that it has not received this response
                previously and whether responses for the same request are received
                in the wrong order (T1:1.8, T3:1.3).
              </t>
              
            </list>
          </t>
          
        </section>
        
      </section>
      
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
    
      <section anchor="mulreq-oneres" title="Multiple Requests - One Response">
        
        <t>
          In this scenario we study caching: how a proxy may serve the same
          cached response to multiple clients requesting the same resource.
        </t>
        <t>
          The caching functionality protects communication-constrained servers
          from repeated requests for the same resources, possibly originating
          from different clients. This saves system resources, bandwidth, and
          round-trip time.
        </t>
        
        <figure anchor="figure-z" title="Message Flow for Cached Responses">
          <artwork align="center">
<![CDATA[
Client A         Proxy           Server
   |               |               |
   |    Request    |    Request    |
   |-------------->|-------------->|--.
   |               |               |  |
   |<--------------|<--------------|<-'
   |    Response   |    Response   |
   |               |               |
                   |               |
Client B           |               |
   |               |               |
   |    Request    |               |
   |-------------->|--.            |
   |               |  | from cache |
   |<--------------|<-'            |
   |    Response   |               |
   |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          In <xref target="figure-3"/>, Client A requests the proxy to make a 
          certain request to the server and to return the server's response.
          The proxy services the request by making a request message to the
          server according to the processing rules.  If the server returns a
          cacheable response, then the proxy stores the response in its cache, 
          performs any necessary translations, and forwards it to the client.
          Later, client B makes an equivalent request to the proxy that the
          proxy services by returning the response from its cache.
        </t>
        <t>
          Cacheable responses are 2.05 (Content) responses and all error
          responses.
        </t>
        <t>
          Functional Requirements:
          <list style="symbols">
            <t>
              The proxy must be able to store cacheable responses in a
              cache.  This requires the proxy to read the CoAP header, options, and
              payload and to compute the cache key for a request.
            </t>
            <t>
              The proxy must be able to return a fresh response from
              its cache without contacting the server.
            </t>
            <t>
              The proxy must be able to perform validation on a request by
              a client and a request validation to the server (see Section 5.6.2 of
              <xref target="RFC7252"/>).
            </t>
          </list>
        </t>
        
        <!-- *************************************************************** -->
        
        <section anchor="PRz" title="Processing Rules">
          
          <t>
            The proxy complies with the forwarding rules PR1.1 - 1.3 
            (<xref target="PR1"/>) and the rules below.  The rules below have 
            priority.
            <list style="format PR3.%d">
              <t>
                If the proxy receives a request where the cache key matches 
                that of a cached fresh response, then the proxy discards the 
                request and replies with that response, else it makes a 
                translated request.
              </t>
              
              <t>
                The proxy caches and forwards cacheable responses.  If there is
                already a response in the cache with the cache key of the 
                corresponding request, then the old response in the cache is
                marked as stale.
              </t>
              
              <t>
                If the proxy receives a request that contains an ETag option
                and the proxy has a fresh response with the same cache key and
                ETag, then the proxy replies to the request with a 2.03 (Valid)
                response without payload, else it forwards a translated request.
              </t>
              
              <t>
                The proxy updates the Max-Age option according to the
                Max-Age associated with the resource representation it receives,
                decreasing its value to reflect the time spent in the
                cache.
              </t>
              
              <t>
                If the request contains an Accept option and if there is a 
                fresh response that matches the cache key for the corresponding
                request except for the Accept option, and if the Content-Format
                of the response matches that of the Accept option, then the 
                proxy forwards the cached response to the requesting client.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">

          <t>
            A caching proxy has an active role in the resource request/response
            procedure, so it is not surprising that it is necessary to make a
            trade-off between caching functionality and the protection of
            client-server interaction.  Comparing with the scenario in
            <xref target="onereq-oneres"/>, most of the security objectives in
            <xref target="SOx"/> cannot be met:
            <list style="symbols">
              <t>
                The caching functionality decouples responses from requests.
                This implies that a client is not able to verify that a received
                response is generated by the server in response to a specific
                request.
              </t>
              <t>
                A client may receive a response without the server being aware
                that the client has made a request.  A proxy could proactively
                generate requests or observe resources in order to keep the
                cache up-to-date.  Thus the server cannot in general verify
                that a request originates from a client as a precondition
                to provide a response.
              </t>
            </list>
          </t>
          <t>
            Since a proxy can autonomously make requests for resource
            representations and there is no security association between proxy and
            server, the server cannot verify those requests. If a request needs
            to be verified then the solution to the scenario in <xref
            target="onereq-oneres"/> can be re-used. Therefore we do not
            consider the protection of requests and focus here on enabling the
            caching functionality and providing security to cacheable resource
            representations.
          </t>
          
          <t>
            The security objectives for this scenario are:
            <list style="format SO3.%d">
              <t>
                The client is able to verify that a received response contains a
                resource representation to a requested server and resource, and
                that it has not been altered between server and client.
              </t>
              <t>
                The client is able to verify that a received resource
                representation is fresh.
              </t>
              
              <t>
                The server is able to protect a resource representation such
                that only authorized clients can read the representation.
              </t>
            </list>
          </t>
          
        </section>
    
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now list potential threats and discuss candidate mitigation 
            mechanisms.
          </t>
          
          <section anchor="T1:3" 
                   title="T1:The proxy illegitimately modifies a message">
            <t>
              <list style="format T1:3.%d">
                <t>
                  The proxy forwards a request with modified payload
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy forwards a response with modified payload
                  <vspace blankLines="1"/>
                  This threat that may be mitigated with integrity protection of
                  resource representation.
                </t>
                
                <t>
                  The proxy forwards a request with modified CoAP options
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy forwards a response with modified CoAP options
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  For example, a proxy is
                  entitled to change Max-Age.  However, changing Content-Format
                  may result in an error or the wrong interpretation of a
                  representation.  That kind of threat may be mitigated by
                  securely associating resource information (such as 
                  Content-Format) to the representation in the response.
                </t>
                
                <t>
                  The proxy forwards a request with changed CoAP header fields
                  <vspace blankLines="1"/>
                  As mentioned in <xref target="onereq-oneres"/>, this is not
                  necessarily a threat and it is not in scope of the security
                  objectives to mitigate.
                </t>
                
                <t>
                  The proxy forwards a response with changed CoAP header fields
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since message layer 
                  parameters may be changed by a proxy.  A change of Code in 
                  the response may be misinterpreted. But as long as the
                  responses allow verification of resource information, such a
                  change will be detected. Thus this threat is mainly a
                  denial-of-service.  Threats arising from modification of 
                  Version are difficult to predict.  A future version of CoAP 
                  must consider security implications of a proxy manipulating 
                  the version number.
                </t>
                
                <t>
                  The proxy forwards a request different from the translated 
                  request
                 <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>


                <t>
                  The proxy forwards a response to a non-equivalent request
                  <vspace blankLines="1"/>
                  If the response is from another server, then it can be 
                  mitigated by having different security associations with
                  different servers.  If the response is that of another
                  resource of the same server, it can be mitigated by having
                  different security associations of different resources, or by
                  securely associating a resource identifier to the
                  representation in the response.  If the response is from the 
                  right server and resource, then the modifications of payload, 
                  options and header are considered previously.
                </t>
                
                <t>
                  The proxy forwards an old response to the same resource
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  The proxy is supposed to
                  send a cached response, if fresh.  However, if the proxy
                  serves a stale response and manipulates the Max-Age option,
                  then it may trick the client into believing that this is a
                  fresh response.  Since the proxy is entitled to make such
                  changes, this is not possible to prevent.  The server may
                  however provide other freshness information (timestamp,
                  counter, etc.)  integrity protected together with the
                  resource representation and associated resource information
                  from which the client may infer that Max-Age is not correct.
                  Note that in case time synchronization cannot be assumed
                  the information about age is limited to the order of the
                  responses. 
                </t>
                
                <t>
                  The proxy maliciously serves a 2.03 (Valid) response
                  to a request with an ETag option
                  <vspace blankLines="1"/>
                  This is not possible to prevent, since the proxy is entitled
                  to perform such operation without involving the server.
                  [TODO: Since the response must not include a payload
                  (see Section 5.9.1.3 of RFC 7252), it is not clear how a server could
                  enforce the proxy to include any integrity protected freshness
                  information unless we define new proxy processing rules.]
                </t>
                
                <t>
                  The proxy colludes with a legitimate client having access to
                  the key used to generate and verify Message Authentication
                  Codes (MAC) of responses/resource representations to generate
                  a valid MAC.
                  <vspace blankLines="1"/>
                  This threat applies to responses containing a message
                  authentication code (MAC) for integrity protecting the 
                  resource representation.  The threat may be mitigated by the 
                  server digitally signing the representation with its private
                  key instead of using a MAC.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section anchor="T2:3" 
                   title="T2:The proxy illegitimately sends a message">
            <t>
              <list style="format T2:3.%d">
                
                <t>
                  The proxy sends a request to the server without a previous
                  request from the client
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since the proxy may want to
                  keep the cache updated with fresh representations to allow
                  short round-trip time.  A proxy maliciously making requests
                  for the purpose of gaining information about the resources
                  may to some extent be mitigated by encryption, but
                  encrypting data in the cache key has an impact on how the
                  cache can perform its legitimate operation.  This is out of
                  scope for the security objectives.
                </t>
                
                <t>
                  The proxy sends a response to the client without a previous
                  response from the server
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since the proxy is allowed
                  to respond with a fresh, cached response.  Other cases of
                  responding inappropriately to a client request are covered in
                  the previous section.  The client can detect the case of
                  receiving a response without having sent a request.
                </t>
                
                <t>
                  A proxy sends a number of messages for the purpose of flooding
                  client or server
                  <vspace blankLines="1"/>
                  Considering that a proxy is entitled to make resource
                  requests, it may be difficult to protect the server against
                  this kind of denial-of-service attacks.  As for responses, by
                  verifying the integrity and freshness of requested 
                  information, the client may mitigate certain flooding attacks.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:3" 
            title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:3.%d">
                <t>
                  The proxy does not forward a message
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  According to the
                  processing rule, the proxy must not forward a request if
                  there is a fresh cached response.  If the proxy does not
                  forward a request although there is no valid cache response
                  or if the proxy does not propagate a response,
                  then this is a denial-of-service attack.  While these threats may
                  be difficult to mitigate, missing messages are common in
                  lossy environments so applications should be prepared
                  for this kind of issue.
                </t>
                
                <t>
                  The proxy delays forwarding of a received message
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so it
                  is difficult to detect and mitigate this.
                  Delayed requests and responses can also be used in
                  attacks against actuators as is discussed in
                  <xref target="onereq-oneres"/>,
                  but that is out of scope for this scenario.
                </t>
                
                <t>
                  The proxy reorders the requests
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy reorders the responses
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting a freshness parameter together with the response.
                </t>
                
                
              </list>
            </t>
          </section>
          
          <section anchor="T4:3" 
                   title="T4:The proxy illegitimately reads part of a message">
            <t>
              <list style="format T4:3.%d">
                <t>
                  The proxy reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the
                  representation, and other potential payload data.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP options and header fields.
                  <vspace blankLines="1"/>
                  The proxy needs to read the cache key for performing caching
                  operations.  Information leaking that can be inferred from 
                  such data cannot be prevented.
                </t>
                
                <t>
                  The proxy reads and stores all message exchanges and can
                  deduce information about the entire history of resource
                  access.
                  <vspace blankLines="1"/>
                  Since the cache key and other metadata is not in scope of the
                  security objectives, the mitigation is restricted to encrypting
                  the resource representations.
                  The case of long term key compromise would nevertheless reveal
                  the history of the resource, but this can be mitigated with
                  forward secrecy.
                </t>
                
              </list>
            </t>
          </section>

        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="R3" title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for the caching scenario.  For each requirement and non-requirement
            the associated threats are listed.  The security requirements are:
            
            <list style="format R3.%d">
              <t>
                The client must be able to verify that a received resource
                representation originates from the requested server (T1:3.2, 
                T1:3.8).
              </t>
              
              <t>
                The client must be able to verify that a received representation
                is a representation of the resource requested by the client
                (T1:3.2, T1:3.4, T1:3.8).
              </t>
              
              <t>
                The client must be able to verify the content format of the 
                representation (T1:3.4).
              </t>
              
              <t>
                The client must be able to detect that a received representation
                is fresh (T1:3.9, T3:3.4).
              </t>
              
              <t>
                The representation must be integrity protected and encrypted
                from the server to the client (T1:3.2, T1:3.11, T2:3.3, T4:3.1).
              </t>
              
              <t>
                To protect against the proxy colluding with an authorized 
                client, asymmetric cryptography must be used (T1:3.11).
              </t>
              <t>
                The communication protocol must provide forward secrecy (T4:3.3).
              </t>
            </list>
            The security non-requirements of the caching scenario are:
            
            <list style="format NR3.%d">
              
              <t>
                The request is not protected (see Security Objectives).
              </t>
              
              <t>
                The header and options of the response are not protected
                (see Security Objectives, compare R3.3).
              </t>
              
              <t>
                The proxy may eavesdrop on metadata (including the cache key) or
                may make requests on behalf of alleged clients (T2:3.1, T4:3.2).
              </t>
              
              <t>
                The proxy may drop messages without the endpoint being able to
                infer that the message is lost due to the proxy (T3:3.1).
              </t>
              
              <t>
                The proxy may delay messages without being detected (T3:3.2).
              </t>
              
              <t>
                The client may not be able to verify validity information 
                provided by proxy when using ETag (T1:3.10).
              </t>
            </list>
            
          </t>
        </section>
        
      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->

      
      <section title="Multiple Requests - Multiple Responses: Observe">
        
        <t>
          This scenario is about replicating a resource state from a
          server to a client.  The client observes a
          resource and receives notifications which may be cached.
          The difference compared to the previous scenario
          (<xref target="mulreq-oneres"/>) is the capability
          to send multiple responses in reply to a single request.
          The difference compared to <xref target="onereq-mulres"/>
          is that in this scenario multiple clients may be served
          with the same response.
        </t>
        
        <t>
          This functionality protects communication-constrained servers from
          repeated requests, which may come from different clients, when the
          resource is unchanged. This saves system resources and bandwidth.
        </t>
        
        <t>
          In addition to multiple clients' requests being served by one
          response, each request may result in multiple responses.
        </t>

        
        <figure anchor="figure-observe-" title="Message Flow for Observe with Multiple Observers">
          <artwork align="center">
<![CDATA[Client A         Proxy          Server
   |               |               |
   |    Request    |    Request    |
   |-------------->|-------------->|--.
   |               |               |  |
   |<--------------|<--------------|<-'
   |  Notification |  Notification |
   |               |               |
                   |               |
Client B           |               |
   |               |               |
   |    Request    |               |
   |-------------->|--.            |
   |               |  | from cache |
   |<--------------|<-'            |
   |  Notification |               |
   |               |               |
   |<--------------|<--------------|
   |  Notification |  Notification |
   |               |               |
                   |               |
Client A           |               |
   |               |               |
   |<--------------|               |
   |  Notification |               |
   |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          The server exposes an observable resource (e.g., the current
          reading of a temperature sensor).  Multiple clients are
          interested in the current state of the resource and observe
          it using the <xref target="RFC7641">CoAP resource observation
            mechanism</xref>.  The goal is to keep the state observed by
          the clients closely in sync with the actual state of the
          resource at the server.  Another goal is to minimize the
          burden on the server by moving the task to fan out
          notifications to multiple clients from the server to the
          proxy.
        </t>
        
        <t>
          Functional Requirements:
          <vspace blankLines="1"/>
          The functional requirements of the previous scenario
          (<xref target="mulreq-oneres"/>) apply, and additionally:
          <list style="symbols">
            <t>
              The proxy must be able to observe a resource on behalf of
              one or more clients.
            </t>
            <t>
              When a client registers interest in a resource with the
              proxy, the proxy must be able to return a response containing
              the current state of the resource without contacting the
              server.
            </t>
          </list>
        </t>
        
        <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          <t>
            The proxy complies with the processing rules PR3.1 - 3.5
            of the previous scenario (<xref target="PR3"/>).
            
            In addition, the following processing rules apply:
            <list style="format PR4.%d">
              <t>
                If the proxy receives a notification from the server
                that is out of sequence (as indicated by the Observe
                option), then the proxy discards the notification.
                Otherwise, the proxy proceeds to notify the registered
                observers.
              </t>
              <t>
                When notifying an observer, the proxy modifies the
                Observe option to indicate the sequence of
                notifications from the proxy to the observer.
              </t>
              
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Security Objectives">
          <t>
            The security objectives are identical to the previous scenario.
          </t>
        </section>
        
        <!-- *************************************************************** -->

        <section title="Threat Analysis and Mitigation">
          <t>
            The threat analysis from the previous scenario carries over to this
            scenario.
          </t>
          
          <section anchor="T1:4" 
                   title="T1:The proxy illegitimately modifies a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T1:3"/>).  For example in T1:3.4, a proxy may
              maliciously modify the Observe option to indicate a different 
              order of notifications without being detected.  However, the
              mitigation specified in the previous scenario applies: the server
              integrity protects a freshness parameter with the response.
            </t>
          </section>
          
          <section title="T2:The proxy illegitimately sends a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T2:3"/>).
            </t>
          </section>
          
          <section 
              title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T3:3"/>).  The threat in T3:3.4 may be combined 
              with manipulation of the Observe option, but the same mitigation 
              as mentioned in (<xref target="T1:4"/>) applies.
            </t>
          </section>
          
          <section title="T4:The proxy illegitimately reads part of a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T4:3"/>).
            </t>
          </section>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            Since the security objectives and threat mitigations carry over from
            the previous scenario (<xref target="mulreq-oneres"/>), the same
            security requirements are valid (<xref target="R3"/>).
          </t>
          
        </section>

      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->

      
      <section 
          title="Multiple Requests - Multiple Responses: Publish-Subscribe">
        
        <t>
          The intermediary node in the publish-subscribe scenario is a broker 
          for messages from a publisher to subscriber.  A subscriber subscribes
          to a "topic" and receives a publication.  The broker fans out
          subsequent publications on that topic to all subscribers.
        </t>
        
        <t>
          In this scenario a single request may result in multiple responses
          and a single response may reach multiple clients.
        </t>
        
        
        <figure anchor="figure-4" title="Message Flow for Publish-Subscribe">
          <artwork align="center">
<![CDATA[Subscriber       Broker          Publisher
(Client A)      (Server)         (Client)
    |               |               |
    |               |    Publish    |
    |            .--|<--------------|
    |   to store |  |               |
    |            '--|-------------->|
    |               |               |
    |   Subscribe   |               |
    |-------------->|--.            |
    |               |  | from store |
    |<--------------|<-'            |
    |  Notification |               |
                    |               |
(Client B)          |               |
    |               |               |
    |   Subscribe   |               |
    |-------------->|--.            |
    |               |  | from store |
    |<--------------|<-'            |
    |  Notification |               |
    |               |               |
    |               |    Publish    |
    |            .--|<--------------|
    |   to store |  |               |
    |            '--|-------------->|
    |               |               |
    |<--------------|               |
    |  Notification |               |
    |               |               |
                    |               |
(Client A)          |               |
    |               |               |
    |<--------------|               |
    |  Notification |               |
    |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          The broker maintains a number of topics that a publisher can publish
          to and a subscriber subscribe to. Topics are represented as URIs at 
          the broker. <xref target="figure-4"/> illustrates the publication to 
          a topic, implemented as a PUT request of a representation to a
          resource at the broker.</t>

        <t>
          Subscribers can make a GET request with the Observe option to the 
          topic URI at the broker in order to initiate the subscription on the
          topic.  The broker provides a notification in the form of a stored
          representation as response to the request. Further publications of
          representations to this URI are provided as notification responses to
          the subscription request.
        </t>

        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              The publication must be able to be transferred in a PUT request
              from the publisher and in a GET response to the subscriber.
            </t>
          </list>
        </t>
        
       <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          
          <t>
            <list style="format PR5.%d">
              
              <t>
                If the broker receives a subscription request to one of its
                resources, then the broker associates the requesting subscriber
                to the topic and responds with the current representation.
              </t>
              
              <t>
                If the broker receives a publication request to one of its
                resources, then the broker stores the received representation
                on the topic and responds with the representation to the
                associated subscribers of that topic.
              </t>
 
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          
          <t>
            In this scenario, there may be multiple publishers to one topic.
            A security objective of the subscriber is to be able to verify
            that a publication on a certain topic is from a publisher authorized
            to publish on this topic. In general that requires authentication
            of publication. How the subscriber knows which publications are
            authorized is out of scope.
          </t>
          
          <t>
            The security objectives for this scenario are:
            <list style="format SO5.%d">
              <t>
                A subscriber is able to verify that a received response
                contains a resource representation by an authorized publisher,
                and of a requested topic, and
                that it has not been altered between publisher and subscriber.
              </t>
              
              <t>
                A subscriber is able to verify that a received
                resource representation is fresh.
              </t>
              
              <t>
                The publisher is able to protect a resource representation such
                that only authorized subscribers can read the representation.
              </t>
              
            </list>

          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now analyze the potential threats relevant to this scenario.
          </t>
          
          
          <section title="T1:The broker illegitimately modifies a message">
            <t>
              <list style="format T1:5.%d">

                <t>
                  The broker responds to a subscriber request with a 
                  publication containing a modified payload
                  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The broker responds to a subscriber request with a
                  publication containing a modified CoAP option
                  <vspace blankLines="1"/>
                  Since the security objective is to protect the resource
                  representation, only options in the GET response that
                  influence the interpretation of the resource representations
                  have an impact.  A broker is entitled to change Max-Age and
                  may do so maliciously.  The broker is not entitled to change 
                  Content-Format, but may anyway do so maliciously.  To mitigate
                  these, the subscriber needs to be able to verify information
                  about freshness and content format provided by the publisher.
                </t>
                
                
                <t>
                  The broker responds to a subscriber request with modified 
                  CoAP header fields
                  <vspace blankLines="1"/>
                  Since the security objective is to protect the resource
                  representation, only header fields in the GET response that 
                  influence the interpretation of the resource representations
                  have an impact.  Changing of Code such as e.g. 2.05 (Content) 
                  to some error code is a denial-of-service.
                </t>
                
                
                <t>
                  The broker modifies the publication before or during storage
                  <vspace blankLines="1"/>
                  This threat is analogous to the previous threats and is
                  mitigated in the same way.
                </t>
              
                
                <t>
                  The broker responds to a subscriber request with the wrong 
                  message
                  <vspace blankLines="1"/>
                  Modifications of payload, options, and header are considered 
                  previously.  To mitigate wrong a interpretation of a response
                  resulting from a broker sending old messages or reordering 
                  messages from the same publisher to the same subscriber, the
                  message may integrity protect a freshness parameter 
                  (timestamp, counter, etc.) from which the age/order can be 
                  deduced (replay/reordering protection).
                </t>
                
                
                <t>
                  The broker colludes with a legitimate subscriber having 
                  access to the key used to create Message Authentication Codes
                  (MAC) of publications in order to generate a valid MAC of a
                  modified publication
                  <vspace blankLines="1"/>
                  This threat applies to publications containing a message
                  authentication code (MAC) for integrity protecting the 
                  resource representation.  The threat may be mitigated by the 
                  publisher digitally signing the representation with a private
                  key instead of using a MAC.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section title="T2:The broker illegitimately sends a message">
            <t>
              <list style="format T2:5.%d">
                
                <t>
                  The broker sends a response to a subscriber request without a
                  previous publication from the publisher
                  <vspace blankLines="1"/>
                  Most cases of responding inappropriately to a subscriber
                  request are covered in the previous section.  In general,
                  authentication of publisher in combination with
                  replay/reordering protection will mitigate this threat.
                </t>
                
                <t>
                  A broker sends a number of messages for the purpose of 
                  flooding the subscriber
                  <vspace blankLines="1"/>
                  By verifying the integrity and freshness information, the 
                  subscriber may mitigate certain flooding attacks.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:5" 
            title="T3:The broker illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:5.%d">
                <t>
                  The broker does not store or forward a publication
                  <vspace blankLines="1"/>
                  This is a denial-of-service attack.  While these threats may
                  be difficult to mitigate, missing messages are common in
                  lossy environments so applications should have a readiness
                  for this kind of issue.
                </t>
                
                <t>
                  The broker does not respond to a publication request
                  <vspace blankLines="1"/>
                  This may be a denial-of-service attack on
                  the publisher.  While such a threat may be difficult to 
                  mitigate, missing messages are common in lossy environments
                  so applications should have a readiness for this kind of
                  issue.
                </t>
              
                <t>
                  The broker delays forwarding of a received publication
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so it
                  may be difficult to detect and mitigate.
                </t>
                
                <t>
                  The broker reorders the publications
                  <vspace blankLines="1"/>
                  This threat may be mitigated by
                  the publisher integrity protecting the message and including
                  a freshness parameter.
                </t>
        
              </list>
            </t>
          </section>
          
          <section title="T4:The broker illegitimately reads part of a message">
            <t>
              <list style="format T4:5.%d">
                <t>
                  The broker reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the
                  representation and other potential payload data
                </t>
                
                <t>
                  The broker infers information about the nature and state of 
                  the publication from CoAP options and header fields.
                  <vspace blankLines="1"/>
                  This metadata is not in scope of confidentiality.  
                  Information leaking that can be inferred from such data 
                  cannot be prevented.
                </t>
                
                <t>
                  The broker reads and stores all publications and can
                  deduce information about the entire history of the publications
                  and subscriptions
                  <vspace blankLines="1"/>
                  Since the protection of metadata related to subscription and
                  publication is not in scope of the security objectives,
                  the mitigation is restricted to encrypting
                  the resource representations.
                  The case of long term key compromise would nevertheless reveal
                  the history of a publication, but this can be mitigated with
                  forward secrecy.
                </t>
                
              </list>
            </t>
          </section>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for the publish-subscribe scenario.  For each requirement and 
            non-requirement the associated threats are listed.  The security
            requirements are:
            
            <list style="format R5.%d">
              <t>
                The subscriber must be able to verify that a received resource
                representation originates from an authorized publisher (T1:5.1,
                T2:5.1).
              </t>
              
              <t>
                The subscriber must be able to verify that a received 
                representation is a representation of the resource requested by
                the subscriber (T1:5.1, T1:5.4, T1:5.5, T1:5.6).
              </t>
              
              <t>
                The subscriber must be able to verify the content format of the 
                representation (T1:5.2)
              </t>
              
              <t>
                The subscriber must be able to detect that the received resource
                representation is older than a previously received
                representation of this resource (T1:5.5, T2:5.1, T3:5.4).
              </t>
              
              <t>
                The representation must be integrity protected and encrypted
                from publisher to subscriber  (T1:5.1, T1:5.5, T2:5.2, T4:5.1).
              </t>
              
              <t>
                To protect against the proxy colluding with an authorized 
                subscriber, asymmetric cryptography must be used  (T1:5.6).
              </t>
              <t>
                The communication protocol must provide forward secrecy (T4:5.3).
              </t>
            </list>
            The security non-requirements of the pub-sub scenario are:
            
            <list style="format NR5.%d">
              
              <t>
                The subscription request is not protected (see Security 
                Objectives).
              </t>
              
              <t>
                The header and options of the notification response are not 
                protected (see Security Objectives, compare R5.3).
              </t>
              <t>
                The broker may change and eavesdrop on certain metadata without
                being detected (T1:5.2, T1:5.3, T4:5.2).
              </t>
              
              <t>
                The broker may drop messages without being detected (T3:5.1, 
                T3:5.2).
              </t>
              
              <t>
                The broker may delay messages without being detected (T3:5.3).
              </t>
            </list>
            
          </t>
          
        </section>
        
      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
      
    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Acknowledgments" numbered="no">

      <!-- sorted by last name -->
      <t>
        Thanks to
        Ari Keranen,
        John Mattsson,
        Jim Schaad, and
        Ludwig Seitz
        for helpful comments and discussions that have shaped the
        document.
      </t>

    </section>
   
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
