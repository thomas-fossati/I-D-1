<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
  <!ENTITY RFC4949 SYSTEM "reference.RFC.4949.xml">
  <!ENTITY RFC6347 SYSTEM "reference.RFC.6347.xml">
  <!ENTITY RFC7228 SYSTEM "reference.RFC.7228.xml">
  <!ENTITY RFC7252 SYSTEM "reference.RFC.7252.xml">
  <!ENTITY RFC7258 SYSTEM "reference.RFC.7258.xml">
  <!ENTITY RFC7641 SYSTEM "reference.RFC.7641.xml">
  <!ENTITY I-D.ietf-cose-msg SYSTEM "reference.I-D.ietf-cose-msg.xml">
  <!ENTITY I-D.mattsson-core-coap-actuators SYSTEM "reference.I-D.mattsson-core-coap-actuators.xml">
  <!ENTITY I-D.koster-core-coap-pubsub SYSTEM "reference.I-D.koster-core-coap-pubsub.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>

<rfc category="info" docName="draft-hartke-core-e2e-security-reqs-01" ipr="trust200902">
    
    <front>

    <title>Requirements for CoAP End-To-End Security</title>

    <author initials="G." surname="Selander" fullname="Goeran Selander">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>goran.selander@ericsson.com</email>
      </address>
    </author>
    
    <author initials="F." surname="Palombini" fullname="Francesca Palombini">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>francesca.palombini@ericsson.com</email>
      </address>
    </author>
   
    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63905</phone>
        <email>hartke@tzi.org</email>
      </address>
    </author>
    
    <!--
    <author initials="L." surname="Seitz" fullname="Ludwig Seitz">
      <organization>SICS Swedish ICT AB</organization>
      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <city>Lund</city>
          <code>223 70</code>
          <country>Sweden</country>
        </postal>
        <email>ludwig@sics.se</email>
      </address>
    </author>
    -->
    
    <date />


    <area>Applications</area>

    <workgroup>CoRE Working Group</workgroup>

    <abstract>

      <t>
        This document analyses threats to CoAP message 
        exchanges traversing proxies and derives the security requirements
        for mitigating those threats.
      </t>

    </abstract>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction">

      <t>
        The <xref target="RFC7252">Constrained Application Protocol
        (CoAP)</xref> is a Web application protocol designed for
        <xref target="RFC7228">constrained nodes and networks</xref>.
      </t>

      <t>
        CoAP uses <xref target="RFC6347">Datagram Transport Layer
        Security (DTLS)</xref> for security.  At the same time, CoAP
        relies on proxies for scalability and
        efficiency.  These proxies are specified to perform a
        number of operations on CoAP messages which requires
        DTLS to be terminated at the proxy.  The proxy therefore
        not only has access to the data required for performing the
        desired proxy functionality, but is also able to eavesdrop on
        or manipulate any part of the CoAP payload and metadata in
        transit between client and server or inject new CoAP messages
        without being protected or
        detected by DTLS.
      </t>

      <t>
        One way to mitigate this threat is to secure CoAP communication
        at the application layer using an object-based security
        mechanism such as <xref target="I-D.ietf-cose-msg">CBOR
        Encoded Message Syntax</xref> instead of or in addition to
        the security mechanisms at the network layer or transport
        layer. Such a mechanism can provide "end-to-end security" at
        the application layer in contrast to the "hop-by-hop security"
        provided by DTLS.
      </t>

      <t>
        This document analyses security requirements for CoAP requests and
        responses of sensor and actuator deployments involving proxies and
        other similar intermediaries.  The analysis is based on identifying
        the assets associated to sensor- and actuator-based communication
        patterns and considering the potential threats executed through
        proxies to these assets.  The threat analysis provides the basis for
        defining the security requirements that an end-to-end security
        mechanism for CoAP needs to meet.
      </t>

      <section title="Terminology">

        <!--
        <t>
          This document makes use of the terminology defined in
          <xref target="RFC4949"/>.
        </t>
        -->

        <t>
          Readers are expected to be familiar with the terms and
          concepts described in <xref target="RFC7252"/> and
          <xref target="RFC7641"/>.
        </t>

        <!--
        <t>
          Additionally, the following terms are used in this document:
          <list style="hanging">
            <t hangText="...:">...</t>
          </list>
        </t>
        -->

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to
          be interpreted as described in <xref target="RFC2119"/>.
          The key word "NOT REQUIRED" is interpreted as synonymous with
          the key word "OPTIONAL".
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Scope and Assumptions"></section>
    
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Proxying" anchor="proxying">
      
      
      <figure anchor="fig-proxy" title="A Proxy">
        <artwork align="left">
          <![CDATA[ _ _ __             ___________             __ _ _
                 | Request   |           | Request   |
                 |---------->|           |---------->|
         Client  |           |   Proxy   |           |  Server
                 |<----------|           |<----------|
           _ _ __|  Response |___________|  Response |__ _ _]]>
        </artwork>
      </figure>
      
      <t>
        In the simplest setting, the proxy receives a request from the client
        and sends a response back to the client. There are two legitimate ways
        for the proxy to do this:
        <list style="symbols">
          <t>
            The proxy constructs and sends a request to the server,
            receives a response from the server and uses the
            received data to construct the response to the client.
          </t>
          <t>
            The proxy uses cached data to construct the response to
            the client.
          </t>
        </list>
        In both cases, the proxy needs to read some parts of the
        request from the client and the response from the server
        to accomplish its task.
      </t>
      
      <t>
        The proxy may in turn make a request to another proxy, or
        receive a request from another proxy as in
        <xref target="fig-hopbyhop"/> and <xref target="fig-endtoend"/>.
      </t>


      <figure anchor="fig-hopbyhop" title="Hop-by-Hop Security">
        <artwork align="left">
<![CDATA[     __________       _________       _________       __________
    |          |     |         |     |         |     |          |
    |          |---->|         |---->|         |---->|          |
    |  Client  |     |  Proxy  |     |  Proxy  |     |  Server  |
    |          |<----|         |<----|         |<----|          |
    |__________|     |_________|     |_________|     |__________|
          :             :   :           :   :             :
          '-------------'   '-----------'   '-------------'
             Security         Security         Security
            Association      Association      Association
                 A                B                C]]>
        </artwork>
      </figure>

      <t>
        <vspace blankLines="3"/>
      </t>

      <figure anchor="fig-endtoend" title="End-to-End Security">
        <artwork align="left">
<![CDATA[     __________       _________       _________       __________
    |          |     |         |     |         |     |          |
    |          |---->|         |---->|         |---->|          |
    |  Client  |     |  Proxy  |     |  Proxy  |     |  Server  |
    |          |<----|         |<----|         |<----|          |
    |__________|     |_________|     |_________|     |__________|
          :                                               :
          '-----------------------------------------------'
                        Security Association]]>
        </artwork>
      </figure>
      
      <t>
        In this document, we focus on threats to client and server performed
        by proxies or other intermediary nodes on the path between client and
        server. Without loss of generality, this includes threats agents acting
        between the nodes.
        <vspace blankLines="100"/>
      </t>

      <!-- **************************************************************** -->

      <section title="Threats and Mitigation">

        <section title="Client">

          <figure anchor="fig-client" title="The Client End">
            <artwork align="left">
<![CDATA[     __________             __ _ _
    |          | Request   |
    |          |---------->|
    |  Client  |           |   Proxy
    |          |<----------|
    |__________|  Response |__ _ _]]>
            </artwork>
          </figure>
          
          <t>
            The client sends a request to a proxy and waits for a response.
          </t>
          
          
          <section title="Threats to Authenticity and Availability">
            <t>
              From the perspective of the client, there are three possible
              flows:
              <list style="symbols">
                <t>
                  The client receives a response.
                  <vspace/>Reasons include:
                  <list style="symbols">
                    <t>
                      The request is duly processed and a response is received
                      based on data from the origin server.
                    </t>
                    <t>
                      The client receives an error response from the proxy
                      according to specification
                      (e.g., 5.02 Bad Gateway or 5.04 Gateway Timeout).
                    </t>
                    <t>
                      (Threat 1:) The response is spoofed by an intermediate node.
                    </t>
                  </list>
                </t>
                <t>
                  The client does not receive a response.
                  <vspace/>Reasons include:
                  <list style="symbols">
                    <t>
                      The client times out too early, for example because a
                      link is down, or a message is lost and re-transmission
                      failed, or that the server takes too long responding.
                    </t>
                    <t>
                      (Threat 2:) A message is withheld by an intermediate
                      node, e.g. intentionally dropped or delayed.
                    </t>
                  </list>
                </t>
                <t>
                  The client receives too many responses.
                  <vspace/>Reasons include:
                  <list style="symbols">
                    <t>
                      (Threat 3:) An intermediate node floods the client with
                      responses.
                    </t>
                  </list>
                </t>
              </list>
              If there are mulitple responses to a request, as in the case of
              Observe, then the same threat applies to each response.
              TBD: Remove this sentence - I don't see what it adds.
            </t>
            <t>
              Note: "cache poisioning" - the case of a proxy caching incorrect
              responses injected by an intermediate node - is covered from the
              point of view of the client: it may result in the client receiving a
              spoofed message (Threat 1), or too many (Threat 3), or that the
              proxy or other node is affected such that the client is impacted,
              e.g. times out too early.
            </t>
          </section>
          
          <section title="Threats to Confidentiality" anchor="threat-conf">
            <t>
              An intermediate node may eavesdrop or infer information from
              messages between client and server. Such information can be used
              for targeted attacks as well as pervasive monitoring.
              
              <list style="symbols">
                <t>
                  (Threat 4:) Data in the request from the client or the response
                  from the server is eavesdropped by an intermediate node.
                </t>
                <t>
                  (Threat 5:) Data in the request from the client or the
                  response from the server is used by an intermediate node to
                  infer information about the nature of the request from the
                  client or the response from the server e.g. by measuring the
                  message size, frequency and distribution of incoming requests
                  or outgoing responses.
                </t>
              </list>
            </t>
          </section>
          
          <section title="Mitigation">
            <section title="Threat 1: Spoofing">
              <t>
                Except as specified below, this threat is REQUIED to be
                mitigated by the security solution; the client MUST
                verify that the response is
                <spanx>authentic</spanx> before processing it.
              </t>
              <t>
                The definition of an "authentic response"
                depends on the scenario
                (<xref target="proxy-scenarios"/>),
                but usually means that the client can obtain proof for
                some or all of the following things:
                <list style="symbols">
                  <t>that the requested action was executed by the origin server;
                  </t>
                  <t>that the data originates from the origin server and has not
                    been altered on the way;</t>
                  <t>that the data matches the specifications of the request
                    (such as the target resource);</t>
                  <t>that the data is fresh (when the data is cacheable);</t>
                  <t>that the data is in sequence (when observing a resource).</t>
                </list>
                The proof can, for example, involve a message
                authentication code by the origin
                server included in the response.
              </t>
              <t>
                Note that a CoAP proxy is specified to return an error
                response (such as 5.02 Bad Gateway or 5.04 Gateway
                Timeout) when it encounters an error condition. Since the
                condition occurs at the proxy and not at the origin
                server, the response will not be "authentic"
                according to the above definition. Thus a client cannot
                tell if the proxy sends the response according to
                specification or if it spoofs the response. Hence the security
                solution is NOT REQUIRED to mitigate spoofing in this case.
              </t>
              
            </section>
            
          
            <section title="Threat 2: Withholding">
              <t>
                This threat is NOT REQUIRED to be mitigated by the
                security solution because a CoAP client cannot tell if an
                intermediate node does not send
                a response because it is busy, or if it intentionally drops a
                message.
              </t>
              <t>
                Applications sensitive to delay of requests, e.g. certain actuator
                applications, must protect against this kind of threats,
                see <xref target="I-D.mattsson-core-coap-actuators"/>.
                That is out of scope for this document.
              </t>
            </section>
            
            <section title="Threat 3: Flooding">
              <t>
                A CoAP client is specified to reject any response that
                it does not expect. This can happen before the client
                verifies if the response is authentic.
                Therefore a flood of responses is primarily a threat to
                the system resources of the client, in particular to its
                energy.
                This threat is NOT REQUIRED to be mitigated by the
                security solution in particular, but a client SHOULD
                generally defend against flooding attacks.
              </t>
              
            </section>
            
            <section title="Threat 4: Eavesdropping" anchor="eavesdrop">
              <t>
                This threat is REQUIRED to be mitigated by the security
                solution; clients and servers MUST confidentiality protect the
                data in the requests and responses they send.
              </t>
              <t>
                The definition of what needs to be protected depends on the scenario
                (<xref target="proxy-scenarios"/>), but is RECOMMENDED to
                encompass all data that is not needed to be read by a proxy to
                perform its function.
              </t>
              <t>
                A solution may, for example, encrypt only payload, encrypt payload
                and selected options, or encrypt payload and almost all options.
              </t>
            </section>
            
            
            <section title="Threat 5: Traffic Analysis" anchor="traffic">
              <t>
                This threat is NOT REQUIRED to be mitigated by the security
                solution.
              </t>
              <t>
                 It is RECOMMENDED that applications analyse the risks
                 associated with application information leaking from the
                 messages flow and assess the feasibility to protect  against
                 various threats, e.g. by obfuscating parameters transported
                 in plain text, aligning message flow and traffic between the
                 different cases, adding padding so different messages become
                 indistinguishable, etc.
              </t>
              
            </section>

          </section>
          
        </section>
        
        <section title="Server">
          
          <figure anchor="fig-server" title="The Server End">
            <artwork align="left">
<![CDATA[                                 _ _ __             __________
                                       | Request   |          |
                                       |---------->|          |
                               Proxy   |           |  Server  |
                                       |<----------|          |
                                 _ _ __|  Response |__________|]]>
            </artwork>
          </figure>
          
          
          <t>
            A server listens for a request and returns a response.
          </t>
          
          
          <section title="Threats to Authenticity and Availability">
            
            <t>
              From the perspective of the server, there are three possible
              flows:
              <list style="symbols">
                <t>
                  The server receives a request.
                  <vspace/>Reasons include:
                  <list style="symbols">
                    <t>
                      The request was sent according to
                      specification.
                    </t>
                    <t>
                      (Threat 6:) An intermediate node spoofs a request.
                    </t>
                  </list>
                </t>
                <t>
                  The server does not receive a request.
                  <vspace/>Reasons include:
                  <list style="symbols">
                    <t>
                      A request has not been sent.
                    </t>
                    <t>
                      (Threat 7:) An intermediate node withholds a request.
                    </t>
                  </list>
                </t>
                <t>
                  The server receives too many requests.
                  <vspace/>Reasons include:
                  <list style="symbols">
                    <t>
                      (Threat 8:) An intermediate node floods the server with
                      requests.
                    </t>
                  </list>
                </t>
                
              </list>
            </t>
            
          </section>
          
          <section title="Threats to Confidentiality">
            <t>
              Analogous threats to confidentiality applies to
              the server as well as to the client, see
              <xref target="threat-conf"/>.
              
              <list style="symbols">
                <t>
                  (Threat 9:) Eavesdropping; analogous of Threat 4.
                </t>
                <t>
                  (Threat 10:) Traffic analysis; analogous of Threat 5.
                </t>
              </list>
            </t>
            
            <t>
              <vspace blankLines="100"/>
            </t>
            
          </section>
          
          <section title="Mitigation">
            <section title="Threat 6: Spoofing">
              <t>
                This threat is REQUIRED to be mitigated by the security
                solution: the server MUST verify that the request is
                <spanx>authentic</spanx> before processing it.
              </t>
              <t>
                The definition of an "authentic request"
                depends on the scenario
                (<xref target="proxy-scenarios"/>),
                but usually means that the server can obtain proof for
                some or all of the following things:
                <list style="symbols">
                  <t>that proxies act on behalf of a client;</t>
                  <t>that the data originates from the client and has not been altered on the way;</t>
                  <t>that the request has not been received previously;</t>
                  <t>that the data has been recently generated by the client.</t>
                </list>
                The proof can, for example, involve a message
                authentication code that the proxy obtains from the
                client and includes in the request or a
                challenge-response roundtrip.
              </t>
              <t>
                Note that a CoAP proxy may be allowed to make a validation
                request to a resource, without it being possible to
                prove that it acts on behalf of a client. Since such a
                request does not originate from the client, the server cannot
                tell if the proxy sends the request according to specification
                or if it spoofs the request.  If the scenario allows this
                functionality, then this threat is NOT REQUIRED to be mitigated
                by the security solution.
              </t>
            </section>
            
            <section title="Threat 7: Withholding">
              <t>
                This threat is NOT REQUIRED to be mitigated by the
                security solution because a CoAP server cannot detect if
                the proxy does not send a request because it has no work
                to do or if it withholds a request.
              </t>
            </section>
            
            <section title="Threat 8: Flooding">
              <t>
                This threat is NOT REQUIRED to be mitigated by the
                security solution in particular, but a server SHOULD
                generally defend against flooding attacks.
              </t>
              <t>
                <vspace blankLines="100"/>
              </t>
            </section>
            
            
            <section title="Threat 9: Eavesdropping">
              <t>
                The same mitigation against eavesdropping applies to the server
                as well as to the client, see <xref target="eavesdrop"/>.
              </t>
              
            </section>
            
            <section title="Threat 10: Traffic Analysis">
              <t>
                This threat is NOT REQUIRED to be mitigated by the security
                solution, see <xref target="traffic"/>.
              </t>
              
            </section>
            
          </section>
          
        </section>
        
      </section>
      
      <!-- **************************************************************** -->

      <section title="Scenarios" anchor="proxy-scenarios">

        <section title="One Request - One Response">
        
        <t>
          In this scenario we study use cases where it is important that a
          response sent from one endpoint is the response to a particular
          request to that endpoint.  Many security critical use cases require
          that responses are in this way "securely linked" to requests, such as
          alarm status retrieval and actuator command confirmation.
        </t>
        <t>
          In this scenario there must be a unique response for each request.
        </t>
        
        
        <figure anchor="figure-1" title="Message Flow with a Unique Response for Each Request">
          <artwork align="center">
            <![CDATA[Client          Proxy          Server
              |               |               |
              |    Request    |    Request    |
              |-------------->|-------------->|--.
              |               |               |  |
              |<--------------|<--------------|<-'
              |    Response   |    Response   |
              |               |               |]]>
          </artwork>
        </figure>
        
        
        <t>
          <list style="hanging">
            <t hangText="Example: Alarm status retrieval">
              <vspace blankLines="1"/>
              <xref target="figure-1"/> can be seen as an illustration of a
              message exchange for a client requesting the alarm status (e.g.,
              GET /alarm_status) from a server.  Since the client wants to ensure
              that the alarm status received is reflecting the current alarm
              status and not a cached or spoofed response to the same
              resource, it must be able to verify that the received response is
              a response to this particular request made by the client.
              Therefore the response must be securely linked to the request.
            </t>
            <t hangText="Example: Actuation confirmation">
              <vspace blankLines="1"/>
              Another example for which <xref target="figure-1"/> serves as
              illustration is the confirmation of an actuator request.  In this
              case a client, say in an industrial control system, requests a
              server that a valve should be turned to a certain level, e.g. PUT
              /valve_42/level with payload "3".  In order for the client to
              correctly evaluate the result of a potential changed valve level,
              it is important that the client gets a confirmation how the
              server responded to the requested change, e.g., whether the request
              was performed or not.  Again, the client wants to ensure that the
              response is reflecting the result of this particular actuation
              request made by the client and not a cached or spoofed response.
              Therefore the response must be securely linked to the request.
            </t>
          </list>
        </t>
        
        
        <section anchor="FR1" title="Functional Requirements">
          
          <t>
            <list style="format FR1.%d">
              <t>
                Each response MUST to be securely linked to a
                particular request.
              </t>
              <t>
                The caching functionality SHALL be inhibited;
                the CoAP option Max-Age of the responses SHALL be 0
                (see Section 5.7.1 of <xref target="RFC7252"/>).
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="PR1" title="Processing Rules">
          <t>
            In this scenario, the desired proxy functionality is
            to forward a translated request to the determined destination.
            There are two modes of operation for requests:
            Either using the Proxy-Uri option (PR1.1) or using the
            Proxy-Scheme option together with the Uri-Host, Uri-Port,
            Uri-Path and Uri-Query options (PR1.2).
            <list style="format PR1.%d">
              <t>
                The Proxy-Uri option contains the request URI
                including request scheme (e.g. "coaps://"); the
                Proxy-Scheme and Uri-* options are not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another proxy, then it keeps the Proxy-Uri
                option; otherwise, it splits the option into its
                components, adds the corresponding Uri-* options and
                removes the Proxy-Uri option.
                Then it makes the request using the request scheme
                indicated in the Proxy-Uri.
              </t>
              <t>
                The Proxy-Scheme option
                and the Uri-* options together contain the request URI;
                the Proxy-Uri option is not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another forwarding proxy, then it keeps the
                Proxy-Scheme and Uri-* options; otherwise, it removes
                the Proxy-Scheme option.  Then it makes the request
                using the request scheme indicated in the removed
                Proxy-Scheme option.
              </t>
              <t>
                Responses are forwarded by the proxy, without any modification.
              </t>
            </list>
          </t>
        </section>
        
        

        <!-- *************************************************************** -->
        <section anchor="auth-1" title="Authenticity">
          <t>
            This section defines when a message is considered authentic (cf.
            Threats 1 and 6).
          </t>
          <t>
            The request is considered authentic by the server if:
            <list style="format A1.%d" counter="A1_count">
              <t>
                The request originates from the client
              </t>
              <t>
                The CoAP payload of the request has not been altered.
              </t>
              <t>
                The CoAP options of the request has not been altered in any
                other way than defined in <xref target="PR1" />.
              </t>
              <t>
                The CoAP header fields Version and Code of the request have not
                been altered.
              </t>
              <t>
                The effective URI of the request is not changed.
              </t>
              <t>
                The request has not been previously received.
              </t>
              <t>
                The request was recently sent by the client.
              </t>
            </list>
          </t>
          <t>
            <vspace blankLines="1"/>
          </t>
          <t>
            The response is considered authentic by the client if:
            <list style="format A1.%d" counter="A1_count">
              <t>
                The response originates from the server.
              </t>
              <t>
                The response has not been altered.
              </t>
              <t>
                The response has not been previously received.
              </t>
              <t>
                The response's sensitive fields have not been read by
                the proxy.
              </t>
              <t>
                The response is made in response to a specific request
                sent by the client.
              </t>
              <t>
                The response was recently sent by the server.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        <section anchor="conf-1" title="Confidentiality">
          
          <t>
            This section defines when a message is considered confidentiality
            protected (cf. Threat 4).
          </t>
          <t>
            The messages is considered confidentiality protected if:
            <list style="format C1.%d">
              <t>
                The CoAP payload (if present) is confidentiality protected
              </t>
              <t>
                All CoAP options of the request and response, except
                Uri-Host/Port and Proxy-Uri/Scheme, are confidentiality
                protected.
              </t>
              <t>
                The keys used to confidentiality protect provides forward
                security.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section anchor="R1" title="Security Requirements">
          <t>
            TODO: consider keeping this section.
          </t>
          <t>
            This section contains the security requirements for this scenario.
            For each requirement the associated functional requirement,
            processing rule, authenticity property, and confidentiality
            property is listed.  The security requirements are:
            <list style="format R1.%d">
              
              <t>
                The server must authenticate a message coming
                from a requesting client (A1.1).
              </t>
              
              <t>
                The server must verify that it has not received this request
                previously (A1.6).
              </t>
              
              <t>
                The client must verify that the received response
                originates from the requested server (A1.8).
              </t>
              
              <t>
                The client must verify that a response corresponds uniquely to
                a previous request that the client has made (FR1.1, A1.12).
              </t>
              
              <t>
                The payload must be integrity protected and encrypted
                between client and server (A1.2, C1.1).
              </t>
              
              <t>
                The CoAP options except Uri-* and Proxy-* must be integrity
                protected in the request.  The effective request URI
                must be integrity protected in the request (PR1.1, PR1.2, A1.3).
              </t>
              
              <t>
                All CoAP options in the response must be integrity protected.
                Max-Age must be set to 0 (FR1.2, PR1.3).
              </t>
              
              <t>
                The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the
                request must not be encrypted.  The Max-Age option of the
                response must not be encrypted.  All other options must be
                encrypted (C1.2).
              </t>
              
              
              <t>
                The CoAP header fields Version and Code must be integrity
                protected in requests and responses.  All other header fields
                must not be integrity protected.  The header fields must not be
                encrypted (A1.4).
              </t>
              
              <t>
                The communication protocol must provide forward secrecy (C1.3).
              </t>
              
            </list>
            
          </t>
        </section>
        
        </section>
        
        
        <section title="One Request - Multiple Responses"></section>
        <section title="Multiple Requests - One Response"></section>
        <section title="Multiple Requests - Multiple Responses"></section>
        
        <section title="Summary">

          <figure>
            <artwork>
<![CDATA[ +-------------- One Request - One Response
 |   +---------- One Request - Multiple Responses
 |   |   +------ Multiple Requests - One Response
 |   |   |   +-- Multiple Requests - Multiple Responses
 |   |   |   |
 V   V   V   V]]>
            </artwork>
          </figure>
          <t>
            <list style="hanging" hangIndent="17">
              <t>--- Server ---</t>
              <t hangText="(x) (x) ( ) ( )">The server must authenticate a message coming from a requesting client. (R1.1)</t>
              <t hangText="(x) (x) ( ) ( )">The server must verify that it has not received this request previously. (R1.2)</t>
              <t>--- Client ---</t>
              <t hangText="(x) (x) (x) (x)">The client must verify that the received response originates from the requested server. (R1.3) The client must be able to verify that a received resource representation originates from the requested server. (R3.1)</t>
              <t hangText="(x) ( ) ( ) ( )">The client must verify that a response corresponds uniquely to a previous request that the client has made. (R1.4)</t>
              <t hangText="( ) (x) ( ) ( )">The client must verify that a response corresponds to a previous request that the client has made. (R2.1)</t>
              <t hangText="( ) (x) ( ) ( )">The client must verify that it has not received this response previously and whether responses for the same request are received in the wrong order. (R2.2)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to verify that a received representation is a representation of the resource requested by the client. (R3.2)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to verify the content format of the representation. (R3.3)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to detect that a received representation is fresh. (R3.4)</t>
              <t>--- Encrypted and Integrity Protected Parts ---</t>
              <t hangText="(x) (x) (x) (x)">The payload must be integrity protected and encrypted between client and server. (R1.5) The representation must be integrity protected and encrypted from the server to the client. (R3.5)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP options except Uri-* and Proxy-* must be integrity protected in the request.  The effective request URI must be integrity protected in the request. (R1.6)</t>
              <t hangText="(x) (x) ( ) ( )">All CoAP options in the response must be integrity protected. Max-Age must be set to 0. (R1.7)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the request must not be encrypted.  The Max-Age option of the response must not be encrypted.  All other options must be encrypted. (R1.8)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP header fields Version and Code must be integrity protected in requests and responses.  All other header fields must not be integrity protected. The header fields must not be encrypted. (R1.9)</t>
              <t>--- Miscellaneous ---</t>
              <t hangText="(x) (x) (x) (x)">The communication protocol must provide forward secrecy. (R1.10) (R3.7)</t>
              <t hangText="( ) ( ) (x) (x)">To protect against the proxy colluding with an authorized client, asymmetric cryptography must be used. (R3.6)</t>
            </list>
          </t>
          <t>
            <vspace blankLines="100"/>
          </t>
          
        </section>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Publish-Subscribe">

      <t>
        Applying <xref target="proxying"/> to Publish-Subscribe results
        in <xref target="fig-pubsub-endtoend"/>.
      </t>

      <figure anchor="fig-pubsub-endtoend" title="End-to-End Security">
        <artwork align="left">
<![CDATA[     ___________      _      __________      _      ____________
    |           |    | |    |          |    | |    |            |
    |           |--->| |--->|          |<---| |<---|            |
    | Publisher |    | |    |  Broker  |    | |    | Subscriber |
    |           |<---| |<---|          |--->| |--->|            |
    |___________|    |_|    |__________|    |_|    |____________|
          :         Proxy       :  :       Proxy         :
          :                     :  :                     :
          '---------------------'  '---------------------'
                  Security               Security
                 Association            Association
                      A                      B]]>
        </artwork>
      </figure>

      <t>
        This section is about <xref target="fig-pubsub-ptos"/>.
      </t>

      <figure anchor="fig-pubsub-ptos" title="Publisher-to-Subscriber Security">
        <artwork align="left">
<![CDATA[     ___________      _      __________      _      ____________
    |           |    | |    |          |    | |    |            |
    |           |--->| |--->|          |<---| |<---|            |
    | Publisher |    | |    |  Broker  |    | |    | Subscriber |
    |           |<---| |<---|          |--->| |--->|            |
    |___________|    |_|    |__________|    |_|    |____________|
          :         Proxy                  Proxy         :
          :                                              :
          '----------------------------------------------'
                        Security Association]]>
        </artwork>
      </figure>

      <t>
        (But note that a key aspect of pub-sub is that the subscribers
        do not know the publishers and the publishers do not know the
        subscribers. They only have to know the broker. In
        <xref target="fig-pubsub-ptos"/> all subscribers have to know
        all publishers. That doesn't scale.)
      </t>

      <t>
        <vspace blankLines="100"/>
      </t>

      <!-- **************************************************************** -->

      <section title="Threats and Security Requirements">

        <section title="Publisher">

          <figure anchor="fig-publisher" title="The Publisher End">
            <artwork align="left">
<![CDATA[     ___________             __ _ _
    |           | Request   |
    |           |---------->|
    | Publisher |           |  Broker
    |           |<----------|
    |___________|  Response |__ _ _]]>
            </artwork>
          </figure>

          <t>
            The publisher sends a request to the broker (possibly
            via one or more proxies) and receives a response.
          </t>
          <t>
            From the perspective of the publisher, are there any
            requirements on the response?
          </t>
          <t>
            <vspace blankLines="100"/>
          </t>

        </section>

        <section title="Subscriber">

          <figure anchor="fig-subscriber" title="The Subscriber End">
            <artwork align="left">
<![CDATA[                                 _ _ __             ____________
                                       |   Request |            |
                                       |<----------|            |
                               Broker  |           | Subscriber |
                                       |---------->|            |
                                 _ _ __| Response  |____________|]]>
            </artwork>
          </figure>

          <t>
            The subscriber sends a request to the broker (possibly
            via one or more proxies) and waits for a response.
          </t>
          <t>
            From the perspective of the subscriber, there are three
            possible flows:
            <list style="symbols">
              <t>
                The subscriber receives a response.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The broker duly processed the request and returns
                    a response based on data it obtained from a
                    publisher.
                  </t>
                  <t>
                    The subscriber made a bad request and the broker
                    returns an error response accordingly (e.g., 4.04
                    Not Found).
                  </t>
                  <t>
                    The broker encountered an unexpected condition and
                    returns an error response accordingly (e.g., 5.03
                    Service Unavailable).
                  </t>
                  <t>
                    (Threat 1:) The broker spoofs a response.
                  </t>
                </list>
              </t>
              <t>
                The subscriber does not receive a response.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The subscriber times out too early.
                  </t>
                  <t>
                    (Threat 2:) The broker withholds the response.
                  </t>
                </list>
              </t>
              <t>
                The subscriber receives too many responses.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    (Threat 3:) The proxy floods the subscriber with
                    responses.
                  </t>
                </list>
              </t>
            </list>
            This is repeated as often as needed when the subscriber
            observes a topic.
          </t>

          <!--<t>
            <vspace blankLines="100"/>
          </t>-->

          <section title="Threat 1: Spoofing">
            <t>
              With one exception (see below), this threat is REQUIRED
              to be mitigated by the security solution: the subscriber
              MUST verify that the response is an
              <spanx>authentic response</spanx> before processing it.
            </t>
            <t>
              The definition of an "authentic response"
              depends on the scenario
              (<xref target="pubsub-scenarios"/>),
              but usually means that the subscriber can obtain proof
              for some or all of the following things:
              <list style="symbols">
                <t>that the data matches the specifications of the request (such as the topic);</t>
                <t>that the data originates from a publisher that is authorized to publish to the topic;</t>
                <t>that the data has not been altered on the way between publisher and subscriber;</t>
                <t>that the data is fresh (when the data is cacheable);</t>
                <t>that the data is in sequence (when observing a topic).</t>
              </list>
              The proof can, for example, involve a message
              authentication code that the proxy obtains from the origin
              server and includes in the response or an additional
              challenge-response roundtrip.
            </t>
            <t>
              Note that a CoAP server like the broker is specified to
              return an error response (such as 4.04 Not Found or 5.03
              Service Unavailable) when it encounters an error
              condition. Since the condition occurs at the broker and
              not at the publisher, the response will not be an
              "authentic response" according to the above definition.
              Thus a subscriber cannot tell if the broker sends the
              error response according to specification or if it spoofs
              the response. This threat is NOT REQUIRED to be mitigated
              by the security solution.
            </t>
          </section>

          <section title="Threat 2: Withholding">
            <t>
              This threat is NOT REQUIRED to be mitigated by the
              security solution.
            </t>
          </section>

          <section title="Threat 3: Flooding">
            <t>
              A CoAP client like the subscriber is specified to reject
              any response that it does not expect. This can happen
              before the client verifies if the response is authentic.
              Therefore a flood of responses is primarily a threat to
              the system resources of the client, in particular to its
              energy.
              This threat is NOT REQUIRED to be mitigated by the
              security solution in particular, but a subscriber SHOULD
              generally defend against flooding attacks.
            </t>
            <t>
              <vspace blankLines="100"/>
            </t>
          </section>

        </section>

        <section title="Broker">

          <figure anchor="fig-brokerend" title="A Broker">
            <artwork align="left">
<![CDATA[          _ _ __             __________             __ _ _
                | Request   |          |   Request |
                |---------->|          |<----------|
      Publisher |           |  Broker  |           | Subscriber
                |<----------|          |---------->|
          _ _ __|  Response |__________| Response  |__ _ _]]>
            </artwork>
          </figure>

          <t>
            The broker receives a request from a publisher or a
            subscriber (possibly via one or more proxies).
            <list style="symbols">
              <t>
                If the request comes from a publisher, the broker
                stores the data, notifies any subscribers and returns
                a response to the publisher.
              </t>
              <t>
                If the request comes from a subscriber, the broker
                uses the previously stored data to construct a
                response and returns the response to the client.
              </t>
            </list>
            In both cases, the broker needs to read some parts of the
            requests to accomplish its task.
          </t>
          <t>
            There are the following threats:
            <list style="symbols">
              <t>(Threat 4:) The broker reads the data in the request from the publisher or the subscriber.</t>
              <t>(Threat 5:) The broker measures the frequency and distribution of incoming requests.</t>
              <t>(Threat 6:) The broker stores and notifies subscribers of data from an unauthorized publisher.</t>
            </list>
          </t>

          <t>
            <vspace blankLines="100"/>
          </t>

          <section title="Threat 4: Reading">
            <t>
              This threat is REQUIRED to be mitigated by the security
              solution: publishers MUST protect the data in the requests
              they're sending with Authenticated Encryption.
            </t>
            <t>
              Note that this requirement is in conflict with the
              requirement that the broker needs to be able to read some
              parts of the requests in order to accomplish its task.
              Which parts can be encrypted and/or
              integrity-protected depends on the scenario
              (<xref target="pubsub-scenarios"/>).
            </t>
          </section>

          <section title="Threat 5: Measuring">
            <t>
              This threat is NOT REQUIRED to be mitigated by the
              security solution.
            </t>
          </section>

          <section title="Threat 6: Poisoning">
            <t>
              TODO.
            </t>
            <t>
              <vspace blankLines="100"/>
            </t>
          </section>

        </section>

      </section>

      <!-- **************************************************************** -->

      <section title="Scenarios" anchor="pubsub-scenarios">

        <section title="Multiple Requests - Multiple Responses"><t><vspace blankLines="100"/></t></section>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section anchor="sec-cons" title="Security Considerations">

      <t>
        A proxy or intermediary may be an aggregation point for message flows.
        Therefore it is an attractive target, both from a security and privacy
        point of view.
      </t>
      
      <t>
        Unless the security mechanisms provide forward secrecy, a
        compromise of long term keying material means that an attacker can 
        decrypt all previously sent information and can be directly used for
        any kind of manipulation of the cyber-physical system.
      </t>
      
      <t>
        Therefore the key exchange mechanism used for establish keys to use with
        application layer security must provide forward secrecy.
      </t>
      
      <t>
        Intermediary nodes are aggregation points also for metadata and
        therefore valuable targets for signal intelligence agencies.
        Pervasive monitoring is an attack <xref target="RFC7258"/> and the 
        effect of collecting and correlating information from multitude of 
        proxies must be mitigated.
      </t>
      
      <t>
        Related to this, it is needed to delete all historical information
        from all nodes handling the plaintext data and metadata, in order
        to avoid information leakage.  The impact of this on the intermediary
        nodes can be limited by confidentiality protecting as much as
        possible between the endpoints.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    

    <section title="IANA Considerations">

      <t>
        This document includes no request to IANA.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC2119;

      &RFC7252;
      
      &RFC7258;
      
      &RFC7641;

    </references>

    <references title="Informative References">

      &RFC6347;

      &RFC7228;
      
      &I-D.ietf-cose-msg;
      
      &I-D.mattsson-core-coap-actuators;
      
      &I-D.koster-core-coap-pubsub;

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Scope and Assumptions">

      <t>
        This document presents a number of scenarios involving sensor
        and actuator communications over CoAP.  Common to all scenarios is the
        presence of at least one CoAP intermediary, typically in the form
        of a proxy between
        a client requesting a resource and a server hosting a resource
        (see <xref target="figure-0"/>).
        The proxy is responsible, for example, for reducing response time and
        network bandwidth use by serving responses from a cache or for enabling 
        the client to make requests that it otherwise could not make.
      </t>

      <figure anchor="figure-0" title="CoAP Message Exchanges Through A Proxy">
        <artwork align="center">
<![CDATA[ __________   Request    _________              __________
|          | ---------> |         |  Request   |          |
|          |            |         | ---------> |          |
|  Client  |            |  Proxy  |            |  Server  |
|          |            |         | <--------- |          |
|__________| <--------- |_________|  Response  |__________|
               Response]]>
        </artwork>
      </figure>
      
      <t>
        The basic function of a proxy
        is to forward translated messages according to certain processing rules.
        For example:
        
        <list style="symbols">
          <t>
            Forward a message to the next proxy when the link is up
          </t>
          <t>
            Only forward a request if there is no fresh cached response
          </t>
          <t>
            Forward a new publication to all subscribing clients
          </t>
        </list>
      </t>
 
      <t>
        In order to perform its function, a proxy may be required to read or
        change certain parts of a CoAP message as defined in <xref target="RFC7252"/>.
        For example, a forward proxy is defined to transform
        the Proxy-Uri option to Uri-Host, Uri-Port, Uri-Path and Uri-Query
        options. A proxy caching responses needs to read the Cache Key and
        must be able to change the Max-Age option in the responses.
      </t>
      
      <t>
        Since a proxy might not be fully trusted, a security solution is needed
        that protects the client, the server and the message exchanges against
        certain threats while still allowing the proxy to assume its normal
        functionality. The client and server are assumed to have a security
        association, but the proxy is neither assumed to have a security 
        association with the client nor with the server.  
      </t>
      
      <figure anchor="fig-forward-proxy" 
              title="Security Association Between Client and Server">
        <artwork align="center">
<![CDATA[ __________     ___________                     __________
|          | > |           | Requests >        |          |
|  Client  |___|  Forward  |___________________|  Origin  |
|          |   |   Proxy   |                   |  Server  |
|__________| < |___________|       < Responses |__________|
      :                                             :
      '---------------------------------------------'
                   Security Association]]>
        </artwork>
      </figure>
      
      <t>
        For a start, this document considers the following two cases:
        Forward proxies (as specified in <xref target="RFC7252"/>;
        <xref target="fig-forward-proxy"/>)
        and publish-subscribe brokers (as specified in
        <xref target="I-D.koster-core-coap-pubsub"/>;
        <xref target="fig-broker"/>).  The functionality 
        assumed by these nodes is summarized in the 
        respective scenarios analyzed in this document (<xref
        target="analysis"/>).
      </t>
    
      <figure anchor="fig-broker" 
              title="Security Association Between Publisher and Subscriber">
        <artwork align="center">
<![CDATA[ ____________            __________            ___________
|            |    >     |          |     <    |           |
| Subscriber |__________|  Broker  |__________| Publisher |
|  (Client)  |          | (Server) |          | (Client)  |
|___________ |    <     |__________|     >    |___________|
     :                                              :
     '----------------------------------------------'
                   Security Association]]>
        </artwork>
      </figure>

      <t>
        [TODO: Reverse proxy and cross-protocol proxies will be added
        in a future version of this document.]
      </t>
      
      <t>
        To identify the threats in scope, we first consider what assets need to
        be protected.  In general, there are the following types of assets to
        protect:
        <list style="format A%d:" counter="my_count">
          <t>
            The devices at the two ends, the data generated and stored in
            these devices, and their (often very
            constrained) system resources such as available memory, storage,
            processing capacity, and energy.
          </t>
          <t>
            The physical environment of the devices fitted with sensors
            and actuators.  Access to the physical environment is
            provided through CoAP resources that allow a remote entity
            to retrieve information about the physical environment
            (such as the current temperature) or to produce an effect
            on the physical environment (such as the activation of a
            heater).
          </t>
          <t>
            The communication infrastructure linking the two devices
            (which often contains some very constrained parts) and the data
            stored in the message processing devices.
          </t>
        </list>
      </t>
      
      <t>
        The scope of this document is to analyze threats executed through
        proxies and brokers, and this is only directly affecting the assets of
        type A3, e.g., if a proxy is dropping all messages.
      </t>
      
      <t>
        However, the intermediary node may manipulate the messages exchanged
        between the endpoints and thereby have an impact also on the assets A1 
        and A2, for example: flooding a device with messages has impact on its 
        system resources, and successful manipulation of an actuator command, 
        carried in a message, has an impact on the physical environment.  We 
        therefore define a fourth asset, which is the main target being evaluated
        in this document:
      </t>
      
      <t>
        <list style="format A%d:" counter="my_count">
          <t>
            The messages exchanged between a client and a server, through the
            proxy.  This includes the CoAP header and options in
            request and response messages (such as the requested method
            or the target URI) and the CoAP resource representations,
            encapsulated in the message payload.
          </t>
        </list>
      </t>
      
      <t>
        A fully trusted proxy, handling unprotected messages, is an attractive 
        target, since proxies are aggregation points for message flows (see 
        <xref target="sec-cons"/>) and they may be an easier target from the 
        Internet than the sensors/actuators residing behind them.  A proxy may 
        become subject to intrusion or become infected by malware and perform 
        the attacks of a man-in-the-middle.  The attack vectors for 
        compromising a proxy are out of scope for this
        document.
      </t>
      
      <t>
        The scope of the threat analysis is
        restricted to threats from proxies to single client to server
        interactions.  Threats resulting from collusion between multiple
        proxies are also out of scope (see <xref target="sec-cons"/>).
      </t>
      
      <t>
        On a high level, there are the following threats from proxies
        to consider:
        <list style="format T%d:">
          <t>
            The proxy illegitimately modifies a message.
          </t>
          <t>
            The proxy illegitimately sends a message,
            including replay, flooding, etc.
          </t>
          <t>
            The proxy illegitimately inhibits sending of a message,
            including delay, reordering, etc.
          </t>
          <t>
            The proxy illegitimately reads part of a message.
          </t>
        </list>
      </t>
      
      <t>
        To assess how such threats impact the assets, we need to specify
        the processing rules of the intermediary nodes in different scenarios
        and define the associated security objectives.
      </t>
      
      
     
    </section>
    
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    
    <section anchor="analysis" 
             title="Scenarios, Threats and Security Requirements">
      
      <t>
        In this section we consider a set of scenarios involving proxies and 
        brokers, with different processing rules and security objectives.  We 
        study the associated threats and derive the security requirements for 
        message transfer between client and server, in the different scenarios.
      </t>
      
      <t>
        Note that, since CoAP was not designed for end-to-end security,
        solutions complying with these security requirements extend the 
        applicability of CoAP beyond its original scope.
      </t>
      
      <t>
        To simplify the analysis, the scenarios are structured according to how
        requests and responses are related to each other:
        <list style="hanging">
          <t hangText="One Request - One Response">
            <vspace />
            There is a one-to-one relation between request and response.
          </t>
          <t hangText="One Request - Multiple Responses">
            <vspace />
            A request may have multiple responses, but each response is securely
            linked to a unique request.
          </t>
          <t hangText="Multiple Requests - One Response">
            <vspace />
            One response may serve multiple requests, but each request has a 
            single response.
          </t>
          <t hangText="Multiple Requests - Multiple Responses">
            <vspace />
            One response may serve multiple requests, and each request may have
            multiple responses.
          </t>
        </list>
      
      </t>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
      
      <section anchor="onereq-oneres" title="One Request - One Response">
        
        <t>
          In this scenario we study use cases where it is important that a 
          response sent from one endpoint is the response to a particular
          request to that endpoint.  Many security critical use cases require
          that responses are in this way "securely linked" to requests, such as
          alarm status retrieval and actuator command confirmation.
        </t>
        <t>
          In this scenario there must be a unique response for each request.
        </t>
        
        
        <figure anchor="figure-x" title="Message Flow with a Unique Response for Each Request">
          <artwork align="center">
<![CDATA[Client          Proxy          Server
  |               |               |
  |    Request    |    Request    |
  |-------------->|-------------->|--.
  |               |               |  |
  |<--------------|<--------------|<-'
  |    Response   |    Response   |
  |               |               |]]>
          </artwork>
        </figure>
        
        
        <t>
          <list style="hanging">
            <t hangText="Example: Alarm status retrieval">
            <vspace blankLines="1"/>
              <xref target="figure-1"/> can be seen as an illustration of a 
              message exchange for a client requesting the alarm status (e.g.,
              GET /alarm_status) from a server.  Since the client wants to ensure
              that the alarm status received is reflecting the current alarm
              status and not a cached or spoofed response to the same
              resource, it must be able to verify that the received response is
              a response to this particular request made by the client.
              Therefore the response must be securely linked to the request.
            </t>
            <t hangText="Example: Actuation confirmation">
            <vspace blankLines="1"/>
              Another example for which <xref target="figure-1"/> serves as
              illustration is the confirmation of an actuator request.  In this 
              case a client, say in an industrial control system, requests a 
              server that a valve should be turned to a certain level, e.g. PUT
              /valve_42/level with payload "3".  In order for the client to 
              correctly evaluate the result of a potential changed valve level,
              it is important that the client gets a confirmation how the 
              server responded to the requested change, e.g., whether the request
              was performed or not.  Again, the client wants to ensure that the 
              response is reflecting the result of this particular actuation 
              request made by the client and not a cached or spoofed response.
              Therefore the response must be securely linked to the request.
            </t>
          </list>
        </t>
        
        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              Since each response is intended to be securely linked to a 
              particular request, the response must not be used with any 
              other request.  Hence, as much as possible of the caching 
              functionality must be inhibited.  Therefore the CoAP option 
              Max-Age of the responses is set to 0 (see Section 5.7.1 of 
              <xref target="RFC7252"/>).
            </t>
          </list>
        </t>
        

        <!-- *************************************************************** -->
        
        <section anchor="PRx" title="Processing Rules">
          <t>
            In this scenario, the desired proxy functionality is
            to forward a translated request to the determined destination.
            There are two modes of operation for requests:
            Either using the Proxy-Uri option (PR1.1) or using the
            Proxy-Scheme option together with the Uri-Host, Uri-Port,
            Uri-Path and Uri-Query options (PR1.2).
            <list style="format PR1.%d">
              <t>
                The Proxy-Uri option contains the request URI
                including request scheme (e.g. "coaps://"); the
                Proxy-Scheme and Uri-* options are not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another proxy, then it keeps the Proxy-Uri
                option; otherwise, it splits the option into its
                components, adds the corresponding Uri-* options and
                removes the Proxy-Uri option.
                Then it makes the request using the request scheme
                indicated in the Proxy-Uri.
              </t>
              <t>
                The Proxy-Scheme option
                and the Uri-* options together contain the request URI;
                the Proxy-Uri option is not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another forwarding proxy, then it keeps the
                Proxy-Scheme and Uri-* options; otherwise, it removes
                the Proxy-Scheme option.  Then it makes the request
                using the request scheme indicated in the removed
                Proxy-Scheme option.
              </t>
              <t>
               Responses are forwarded by the proxy, without any modification.
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="SOx" title="Security Objectives">
          <t>
            In this scenario there is a unique response for each request, so the
            client should be able to verify that a certain response is made in
            response to a specific request sent by the client.
          </t>
          <t>
            The server should be able to verify that the proxy only has
            performed the message modifications intended
            by the client according to the processing rules.
          </t>
          <t>
            The proxy should be prevented from reading or making modifications
            to messages apart from what is necessary to perform the processing 
            rules (cf. <xref target="RFC7258"/>).
          </t>
          <t>
            The security objectives are:
            <list style="format SO1.%d">
              <t>
                The server is able to verify that a received request originates
                from a client with which it has a security association, and that
                the request has not been received before.
              </t>
              <t>
                The server is able to verify that the received request either
                has not been altered in transfer, or that the request is 
                modified according to the processing rule PR1.1 or PR1.2 (<xref target="PR1"/>).
              </t>
              <t>
                The server is able to protect the response such that only
                authorized clients can read the response.
              </t>
              <t>
                The client is able to verify that the received response
                originates from the requested server and resource,
                that it has not been altered in transfer, and that it was
                generated as the unique response to the request.
              </t>
              <t>
                The proxy is only able to read data needed to perform
                the processing rules.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now list potential threats and discuss candidate mitigation 
            mechanisms.
          </t>
          
          <section anchor="T1:1" 
                   title="T1:The proxy illegitimately modifies a message">
            <t>
              <list style="format T1:1.%d">
                <t>
                  The proxy forwards a request with modified payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The proxy forwards a response with modified payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The proxy forwards a request with modified CoAP option
                  <vspace blankLines="1"/>
                  Note that the proxy is entitled to change certain options by
                  processing rules PR1.1 and PR1.2.  Since the change is
                  predictable, the effective request URI can be
                  integrity protected by the client and verified by the server.
                  The other CoAP options in the request can be integrity
                  protected.
                </t>

                <t>
                  The proxy forwards a response with modified CoAP option
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  CoAP options. Since Max-Age is set to 0 the proxy is not 
                  entitled to change any options in the response so they can 
                  all be integrity protected.
                </t>
                
                <t>
                  The proxy forwards a request with changed CoAP header fields
                  <vspace blankLines="1"/>
                  The proxy is entitled to change certain header fields (e.g., the
                  token) as part of its normal operations.  Malicious changes to
                  message layer parameters may cause a denial-of-service,
                  equivalent of dropping a message or sending spoofed messages.
                  This is difficult to mitigate.  However, changing the CoAP
                  header Code (e.g., from GET to DELETE) may result in an error
                  or wrong interpretation of the request which can have other
                  security implications.  A change to the Version header field
                  may result in security errors in the interaction between
                  different versions of CoAP.  These threats can be mitigated
                  by integrity protecting the Code and Version header fields.
                </t>
                
                <t>
                  The proxy forwards a response with changed CoAP header fields
                  <vspace blankLines="1"/>
                  Similar to previous threat. Some aspects of this threat can 
                  be mitigated by integrity protecting the Code and Version 
                  header fields.
                </t>
                
                <t>
                  The proxy forwards a different request
                  <vspace blankLines="1"/>
                  If the forwarded request is from another client it can be 
                  mitigated by having different security associations with 
                  different clients.  If the forwarded request is from the same
                  client but with differences in payload, options or header, 
                  then this coincides with previously listed threats.  A proxy 
                  sending old requests (or reordering requests) from the same 
                  client to the same server resource can be mitigated by
                  integrity protecting a freshness parameter (timestamp, 
                  counter, etc.) from which the order of requests can be 
                  deduced (replay/reordering protection).
                </t>
                
                <t>
                  The proxy forwards a different response 
                  <vspace blankLines="1"/>
                  By integrity protecting uniquely identifying information of 
                  the request in the response, the client can verify that the
                  response was generated in reply to a particular request.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section anchor="T2:1" 
                   title="T2:The proxy illegitimately sends a message">
            <t>
              <list style="format T2:1.%d">
                
                <t>
                  The proxy sends a request to the server without a previous
                  request from the client
                  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity- and replay
                  protection.
                </t>
                
                <t>
                  The proxy sends a response to the client without a previous
                  response from the server
                  <vspace blankLines="1"/>
                  Error messages from the proxy such as 5.02 (Bad Gateway)
                  originate from the proxy.  A proxy maliciously sending error
                  messages is a denial-of-service attack similar to not
                  forwarding a message (T3:1.1) and is difficult to mitigate.
                  However, responses claiming to be from the server may be
                  mitigated with integrity protection uniquely identifying
                  information of the request.
                </t>
                
                <t>
                  A proxy sends a number of messages for the purpose of flooding
                  client or server
                  <vspace blankLines="1"/>
                  By verifying the integrity, the client and server may
                  mitigate certain flooding attacks.  The server can use the 
                  replay/reordering protection to verify which messages are 
                  legitimate and the client can verify if a message is a 
                  response to a previously sent request.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:1" 
            title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:1.%d">
                <t>
                  The proxy does not forward a message
                  <vspace blankLines="1"/>
                  This is a denial-of-service attack. While these kind of 
                  threats may be difficult to mitigate, applications should 
                  have a readiness for this kind of issues and a client
                  is able to detect a missing response.
                </t>
                
                <t>
                  The proxy delays forwarding of a received message
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so they
                  may be difficult to detect and mitigate.
                  However, delayed requests and responses can also be used in
                  attacks against actuators; see 
                  <xref target="I-D.mattsson-core-coap-actuators"/>.  These 
                  attacks can be performed by an on-path attacker and are not 
                  restricted to proxies. The proposed mitigation is based on
                  verifying the timeliness of the request, for example, by using 
                  time stamps or with an additional round-trip. These 
                  mitigations can be supported by a new CoAP option containing 
                  time stamp or binding the response in a first round-trip to a
                  request of the second, as specified in 
                  <xref target="I-D.mattsson-core-coap-actuators"/>.
                  By integrity protecting that new CoAP option, the threat can 
                  be mitigated.
                </t>
                
                <t>
                  The proxy reorders the requests
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting a freshness parameter from which the
                  order of requests can be deduced.
                </t>
                
                <t>
                  The proxy reorders the responses
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting information specifying to which request a
                  response belongs.
                </t> 
              </list>
            </t>
          </section>
          
          <section anchor="T4:1" 
                   title="T4:The proxy illegitimately reads part of a message">
            <t>
              <list style="format T4:1.%d">
                <t>
                  The proxy reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the payload.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP options
                  <vspace blankLines="1"/>
                  The proxy only needs to read the Uri-Host/Uri-Port and
                  Proxy-Uri/Proxy-Scheme options of a request.  The information
                  revealed by these parameters is public on network layer.
                  The proxy only needs to read Max-Age of the response, which is
                  set to 0 as indicated in the functional requirements.
                  This threat can be mitigated by encrypting all other options.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP header fields
                  <vspace blankLines="1"/>
                  The header fields needs to be transferred in plain text to 
                  allow normal CoAP operations.  The Code parameter reveals 
                  information about what RESTful action is requested.  This 
                  information leakage is difficult to mitigate.
                </t>
                
                <t>
                  The proxy reads and stores all message exchanges and can
                  deduce information about the entire history of the corresponding
                  interactions
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encrypting as much as possible
                  of the data transferred between client and server.
                  The case of long term key compromise can be mitigated with
                  forward secrecy.
                  
                  
                </t>

              </list>
            </t>
          </section>

        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="Rx" title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for this scenario.  For each requirement and non-requirement the
            associated threats are listed.  The security requirements are:
            <list style="format R1.%d">
              
              <t>
                The server must authenticate a message coming
                from a requesting client (T1:1.1, T1:1.3, T1:1.5, T2:1.1).
              </t>
              
              <t>
                The server must verify that it has not received this request
                previously (T1:1.7, T3:1.3).
              </t>
              
              <t>
                The client must verify that the received response
                originates from the requested server (T1:1.2, T1:1.4, T1:1.6, 
                T2:1.2).
              </t>
              
              <t>
                The client must verify that a response corresponds uniquely to
                a previous request that the client has made (T1:1.8, T3:1.4).
              </t>
              
              <t>
                The payload must be integrity protected and encrypted
                between client and server (T1:1.1-6,T4:1.1, T2:1.3, T4:1.1, 
                <xref target="RFC7258"/>).
              </t>
              
              <t>
                The CoAP options except Uri-* and Proxy-* must be integrity
                protected in the request.  The effective request URI
                must be integrity protected in the request (T1:1.3).
              </t>
              
              <t>
                All CoAP options in the response must be integrity protected.
                Max-Age must be set to 0 (T1:1.4).
              </t>
              
              <t>
                The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the 
                request must not be encrypted.  The Max-Age option of the 
                response must not be encrypted.  All other options must be
                encrypted (T4:1.2).
              </t>
              
              
              <t>
                The CoAP header fields Version and Code must be integrity 
                protected in requests and responses.  All other header fields 
                must not be integrity protected.  The header fields must not be
                encrypted (T1:1.5, T4:1.3).
              </t>
              
              <t>
                The communication protocol must provide forward secrecy (T4:1.4).
              </t>
              
            </list>
            
            The security non-requirements of this scenario are:
            
            <list style="format NR1.%d">
              <t>
                The proxy may drop messages without the endpoint being able to
                infer that the message is lost due to the proxy (T3:1.1).
              </t>
              
              <t>
                The proxy may delay messages without being detected 
                (T3:1.1, T3:1.2).
              </t>
              
              <t>
                The proxy may read the CoAP header including message layer
                parameters and Code, revealing the kind of RESTful action being
                requested and the response code (T4:1.3).
              </t>
            </list>
            
          </t>
        </section>
        
        
      </section>
      
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      <section anchor="onereq-mulres" title="One Request - Multiple Responses">
        
        <t>
          In this scenario we study use cases where it is important that a 
          response is securely linked to a request as in the previous
          scenario, but where there may be multiple responses for each request.
          This functionality protects communication-constrained servers from
          repeated requests from the same client and thus saves system
          resources and bandwidth.  This is useful in security critical
          monitoring scenarios where time synchronization cannot be
          guaranteed.
        </t>
        
        <figure anchor="figure-2" title="Message Flow of a Notification">
          <artwork align="center">
<![CDATA[Client          Proxy          Server
  |               |               |
  |    Request    |    Request    |
  |-------------->|-------------->|--.
  |               |               |  |
  |<--------------|<--------------|<-'
  |  Notification |  Notification |
  |               |               |
  |<--------------|<--------------|
  |  Notification |  Notification |
  |               |               |
  |<--------------|<--------------|
  |  Notification |  Notification |
  |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          
          
          <list style="hanging">
            <t hangText="Example: Secure parameter monitoring">
              <vspace blankLines="1"/>
              <xref target="figure-2"/> can be seen as an illustration of a
              message exchange for a client monitoring an important parameter measured by the
              server, e.g., in a medical or process industry application.
              The client makes a subscription request for a resource
              and the server responds with notifications, thereby providing
              updates to the parameter in regular time intervals.
            </t>
            <t>
              The client wants to ensure that first received notification 
              reflects the current parameter value and that subsequent 
              notifications are timely updates of the initial request.  Since 
              notifications may be lost or reordered, the client needs to be 
              able to verify the order of the messages, as sent by the server.
              By monitoring the received messages and the time they are
              received, the client can detect missing notifications and take
              appropriate action.
            </t>
          </list>
        </t>
        
        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              The same functional requirement apply as in the previous scenario
              (<xref target="onereq-oneres"/>).
            </t>
          </list>
        </t>
        
        
        <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          
          <t>
            The processing rules are identical to PR 1.1 - 1.3 of the previous
            scenario (<xref target="PR1"/>).
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          <t>
            The security
            objectives are similar to the previous scenario.  Each response
            maps to a unique request, but there may be multiple responses to
            one request.  By ordering the responses, each message in this 
            exchange can be made unique.
          </t>
          <t>
            The security objectives of the previous scenario
            (<xref target="SOx"/>) are valid except for SO1.4 which is replaced by
            the following objectives:
            <list style="format SO2.%d">
              <t>
                The client is able to verify that the received response
                originates from the requested server and resource,
                that it has not been altered in transfer, and that it was
                generated as one in a sequence of responses to the request.
              </t>
              <t>
                The client is able to verify the order of the responses and if
                a response is missing.
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            The threat analysis from the previous scenario carries over
            with a few exceptions.
          </t>
          
          <section anchor="T1:2" 
                   title="T1:The proxy illegitimately modifies a message">
            <t>
              Similar conclusions apply as in the previous scenario 
              (<xref target="T1:1"/>).  However, note that in T1:1.8, a proxy 
              may maliciously reorder the responses to the same request without
              being detected.  The mitigation specified in the previous
              scenario (that the client verifies the response is linked to the
              request) is not sufficient since there may be multiple responses.
            </t>
            <t>
              However, analogous to how requests are protected against
              replay/reordering in the previous scenario, by additionally
              integrity protecting a parameter from which the
              order of responses can be deduced, this threat can be mitigated.
            </t>
          </section>
          
          
          <section title="T2:The proxy illegitimately sends a message">
            <t>
              Similar conclusions apply as in the previous scenario 
              (<xref target="T2:1"/>).  T2:1.3 can be mitigated with the
              additional replay/reordering protection of responses as mentioned
              in <xref target="T1:2"/>.
           </t>
          </section>
          
          <section 
              title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              Similar conclusions apply as in the previous scenario 
              (<xref target="T3:1"/>).  T3:1.4 can be mitigated with the
              additional replay/reordering protection of responses as mentioned
              in <xref target="T1:2"/>.
            </t>
          </section>
          
          <section title="T4:The proxy illegitimately reads part of a message">
            <t>
              The same conclusions apply as in the previous scenario 
              (<xref target="T4:1"/>).
            </t>
          </section>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            The security requirements of the previous scenario
            (<xref target="R1"/>) are valid except for R1.4 which is replaced by 
            the following requirements:
          </t>
          
          
          <t>
            <list style="format R2.%d">
              
              <t>
                The client must verify that a response corresponds to a
                previous request that the client has made (T1:1.8, T3:1.4).
              </t>
              
              <t>
                The client must verify that it has not received this response
                previously and whether responses for the same request are received
                in the wrong order (T1:1.8, T3:1.3).
              </t>
              
            </list>
          </t>
          
        </section>
        
      </section>
      
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
    
      <section anchor="mulreq-oneres" title="Multiple Requests - One Response">
        
        <t>
          In this scenario we study caching: how a proxy may serve the same
          cached response to multiple clients requesting the same resource.
        </t>
        <t>
          The caching functionality protects communication-constrained servers
          from repeated requests for the same resources, possibly originating
          from different clients. This saves system resources, bandwidth, and
          round-trip time.
        </t>
        
        <figure anchor="figure-3" title="Message Flow for Cached Responses">
          <artwork align="center">
<![CDATA[
Client A         Proxy           Server
   |               |               |
   |    Request    |    Request    |
   |-------------->|-------------->|--.
   |               |               |  |
   |<--------------|<--------------|<-'
   |    Response   |    Response   |
   |               |               |
                   |               |
Client B           |               |
   |               |               |
   |    Request    |               |
   |-------------->|--.            |
   |               |  | from cache |
   |<--------------|<-'            |
   |    Response   |               |
   |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          In <xref target="figure-3"/>, Client A requests the proxy to make a 
          certain request to the server and to return the server's response.
          The proxy services the request by making a request message to the
          server according to the processing rules.  If the server returns a
          cacheable response, then the proxy stores the response in its cache, 
          performs any necessary translations, and forwards it to the client.
          Later, client B makes an equivalent request to the proxy that the
          proxy services by returning the response from its cache.
        </t>
        <t>
          Cacheable responses are 2.05 (Content) responses and all error
          responses.
        </t>
        <t>
          Functional Requirements:
          <list style="symbols">
            <t>
              The proxy must be able to store cacheable responses in a
              cache.  This requires the proxy to read the CoAP header, options, and
              payload and to compute the cache key for a request.
            </t>
            <t>
              The proxy must be able to return a fresh response from
              its cache without contacting the server.
            </t>
            <t>
              The proxy must be able to perform validation on a request by
              a client and a request validation to the server (see Section 5.6.2 of
              <xref target="RFC7252"/>).
            </t>
          </list>
        </t>
        
        <!-- *************************************************************** -->
        
        <section anchor="PR3" title="Processing Rules">
          
          <t>
            The proxy complies with the forwarding rules PR1.1 - 1.3 
            (<xref target="PR1"/>) and the rules below.  The rules below have 
            priority.
            <list style="format PR3.%d">
              <t>
                If the proxy receives a request where the cache key matches 
                that of a cached fresh response, then the proxy discards the 
                request and replies with that response, else it makes a 
                translated request.
              </t>
              
              <t>
                The proxy caches and forwards cacheable responses.  If there is
                already a response in the cache with the cache key of the 
                corresponding request, then the old response in the cache is
                marked as stale.
              </t>
              
              <t>
                If the proxy receives a request that contains an ETag option
                and the proxy has a fresh response with the same cache key and
                ETag, then the proxy replies to the request with a 2.03 (Valid)
                response without payload, else it forwards a translated request.
              </t>
              
              <t>
                The proxy updates the Max-Age option according to the
                Max-Age associated with the resource representation it receives,
                decreasing its value to reflect the time spent in the
                cache.
              </t>
              
              <t>
                If the request contains an Accept option and if there is a 
                fresh response that matches the cache key for the corresponding
                request except for the Accept option, and if the Content-Format
                of the response matches that of the Accept option, then the 
                proxy forwards the cached response to the requesting client.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">

          <t>
            A caching proxy has an active role in the resource request/response
            procedure, so it is not surprising that it is necessary to make a
            trade-off between caching functionality and the protection of
            client-server interaction.  Comparing with the scenario in
            <xref target="onereq-oneres"/>, most of the security objectives in
            <xref target="SOx"/> cannot be met:
            <list style="symbols">
              <t>
                The caching functionality decouples responses from requests.
                This implies that a client is not able to verify that a received
                response is generated by the server in response to a specific
                request.
              </t>
              <t>
                A client may receive a response without the server being aware
                that the client has made a request.  A proxy could proactively
                generate requests or observe resources in order to keep the
                cache up-to-date.  Thus the server cannot in general verify
                that a request originates from a client as a precondition
                to provide a response.
              </t>
            </list>
          </t>
          <t>
            Since a proxy can autonomously make requests for resource
            representations and there is no security association between proxy and
            server, the server cannot verify those requests. If a request needs
            to be verified then the solution to the scenario in <xref
            target="onereq-oneres"/> can be re-used. Therefore we do not
            consider the protection of requests and focus here on enabling the
            caching functionality and providing security to cacheable resource
            representations.
          </t>
          
          <t>
            The security objectives for this scenario are:
            <list style="format SO3.%d">
              <t>
                The client is able to verify that a received response contains a
                resource representation to a requested server and resource, and
                that it has not been altered between server and client.
              </t>
              <t>
                The client is able to verify that a received resource
                representation is fresh.
              </t>
              
              <t>
                The server is able to protect a resource representation such
                that only authorized clients can read the representation.
              </t>
            </list>
          </t>
          
        </section>
    
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now list potential threats and discuss candidate mitigation 
            mechanisms.
          </t>
          
          <section anchor="T1:3" 
                   title="T1:The proxy illegitimately modifies a message">
            <t>
              <list style="format T1:3.%d">
                <t>
                  The proxy forwards a request with modified payload
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy forwards a response with modified payload
                  <vspace blankLines="1"/>
                  This threat that may be mitigated with integrity protection of
                  resource representation.
                </t>
                
                <t>
                  The proxy forwards a request with modified CoAP options
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy forwards a response with modified CoAP options
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  For example, a proxy is
                  entitled to change Max-Age.  However, changing Content-Format
                  may result in an error or the wrong interpretation of a
                  representation.  That kind of threat may be mitigated by
                  securely associating resource information (such as 
                  Content-Format) to the representation in the response.
                </t>
                
                <t>
                  The proxy forwards a request with changed CoAP header fields
                  <vspace blankLines="1"/>
                  As mentioned in <xref target="onereq-oneres"/>, this is not
                  necessarily a threat and it is not in scope of the security
                  objectives to mitigate.
                </t>
                
                <t>
                  The proxy forwards a response with changed CoAP header fields
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since message layer 
                  parameters may be changed by a proxy.  A change of Code in 
                  the response may be misinterpreted. But as long as the
                  responses allow verification of resource information, such a
                  change will be detected. Thus this threat is mainly a
                  denial-of-service.  Threats arising from modification of 
                  Version are difficult to predict.  A future version of CoAP 
                  must consider security implications of a proxy manipulating 
                  the version number.
                </t>
                
                <t>
                  The proxy forwards a request different from the translated 
                  request
                 <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>


                <t>
                  The proxy forwards a response to a non-equivalent request
                  <vspace blankLines="1"/>
                  If the response is from another server, then it can be 
                  mitigated by having different security associations with
                  different servers.  If the response is that of another
                  resource of the same server, it can be mitigated by having
                  different security associations of different resources, or by
                  securely associating a resource identifier to the
                  representation in the response.  If the response is from the 
                  right server and resource, then the modifications of payload, 
                  options and header are considered previously.
                </t>
                
                <t>
                  The proxy forwards an old response to the same resource
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  The proxy is supposed to
                  send a cached response, if fresh.  However, if the proxy
                  serves a stale response and manipulates the Max-Age option,
                  then it may trick the client into believing that this is a
                  fresh response.  Since the proxy is entitled to make such
                  changes, this is not possible to prevent.  The server may
                  however provide other freshness information (timestamp,
                  counter, etc.)  integrity protected together with the
                  resource representation and associated resource information
                  from which the client may infer that Max-Age is not correct.
                  Note that in case time synchronization cannot be assumed
                  the information about age is limited to the order of the
                  responses. 
                </t>
                
                <t>
                  The proxy maliciously serves a 2.03 (Valid) response
                  to a request with an ETag option
                  <vspace blankLines="1"/>
                  This is not possible to prevent, since the proxy is entitled
                  to perform such operation without involving the server.
                  [TODO: Since the response must not include a payload
                  (see Section 5.9.1.3 of RFC 7252), it is not clear how a server could
                  enforce the proxy to include any integrity protected freshness
                  information unless we define new proxy processing rules.]
                </t>
                
                <t>
                  The proxy colludes with a legitimate client having access to
                  the key used to generate and verify Message Authentication
                  Codes (MAC) of responses/resource representations to generate
                  a valid MAC.
                  <vspace blankLines="1"/>
                  This threat applies to responses containing a message
                  authentication code (MAC) for integrity protecting the 
                  resource representation.  The threat may be mitigated by the 
                  server digitally signing the representation with its private
                  key instead of using a MAC.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section anchor="T2:3" 
                   title="T2:The proxy illegitimately sends a message">
            <t>
              <list style="format T2:3.%d">
                
                <t>
                  The proxy sends a request to the server without a previous
                  request from the client
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since the proxy may want to
                  keep the cache updated with fresh representations to allow
                  short round-trip time.  A proxy maliciously making requests
                  for the purpose of gaining information about the resources
                  may to some extent be mitigated by encryption, but
                  encrypting data in the cache key has an impact on how the
                  cache can perform its legitimate operation.  This is out of
                  scope for the security objectives.
                </t>
                
                <t>
                  The proxy sends a response to the client without a previous
                  response from the server
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since the proxy is allowed
                  to respond with a fresh, cached response.  Other cases of
                  responding inappropriately to a client request are covered in
                  the previous section.  The client can detect the case of
                  receiving a response without having sent a request.
                </t>
                
                <t>
                  A proxy sends a number of messages for the purpose of flooding
                  client or server
                  <vspace blankLines="1"/>
                  Considering that a proxy is entitled to make resource
                  requests, it may be difficult to protect the server against
                  this kind of denial-of-service attacks.  As for responses, by
                  verifying the integrity and freshness of requested 
                  information, the client may mitigate certain flooding attacks.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:3" 
            title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:3.%d">
                <t>
                  The proxy does not forward a message
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  According to the
                  processing rule, the proxy must not forward a request if
                  there is a fresh cached response.  If the proxy does not
                  forward a request although there is no valid cache response
                  or if the proxy does not propagate a response,
                  then this is a denial-of-service attack.  While these threats may
                  be difficult to mitigate, missing messages are common in
                  lossy environments so applications should be prepared
                  for this kind of issue.
                </t>
                
                <t>
                  The proxy delays forwarding of a received message
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so it
                  is difficult to detect and mitigate this.
                  Delayed requests and responses can also be used in
                  attacks against actuators as is discussed in
                  <xref target="onereq-oneres"/>,
                  but that is out of scope for this scenario.
                </t>
                
                <t>
                  The proxy reorders the requests
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy reorders the responses
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting a freshness parameter together with the response.
                </t>
                
                
              </list>
            </t>
          </section>
          
          <section anchor="T4:3" 
                   title="T4:The proxy illegitimately reads part of a message">
            <t>
              <list style="format T4:3.%d">
                <t>
                  The proxy reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the
                  representation, and other potential payload data.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP options and header fields.
                  <vspace blankLines="1"/>
                  The proxy needs to read the cache key for performing caching
                  operations.  Information leaking that can be inferred from 
                  such data cannot be prevented.
                </t>
                
                <t>
                  The proxy reads and stores all message exchanges and can
                  deduce information about the entire history of resource
                  access.
                  <vspace blankLines="1"/>
                  Since the cache key and other metadata is not in scope of the
                  security objectives, the mitigation is restricted to encrypting
                  the resource representations.
                  The case of long term key compromise would nevertheless reveal
                  the history of the resource, but this can be mitigated with
                  forward secrecy.
                </t>
                
              </list>
            </t>
          </section>

        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="R3" title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for the caching scenario.  For each requirement and non-requirement
            the associated threats are listed.  The security requirements are:
            
            <list style="format R3.%d">
              <t>
                The client must be able to verify that a received resource
                representation originates from the requested server (T1:3.2, 
                T1:3.8).
              </t>
              
              <t>
                The client must be able to verify that a received representation
                is a representation of the resource requested by the client
                (T1:3.2, T1:3.4, T1:3.8).
              </t>
              
              <t>
                The client must be able to verify the content format of the 
                representation (T1:3.4).
              </t>
              
              <t>
                The client must be able to detect that a received representation
                is fresh (T1:3.9, T3:3.4).
              </t>
              
              <t>
                The representation must be integrity protected and encrypted
                from the server to the client (T1:3.2, T1:3.11, T2:3.3, T4:3.1).
              </t>
              
              <t>
                To protect against the proxy colluding with an authorized 
                client, asymmetric cryptography must be used (T1:3.11).
              </t>
              <t>
                The communication protocol must provide forward secrecy (T4:3.3).
              </t>
            </list>
            The security non-requirements of the caching scenario are:
            
            <list style="format NR3.%d">
              
              <t>
                The request is not protected (see Security Objectives).
              </t>
              
              <t>
                The header and options of the response are not protected
                (see Security Objectives, compare R3.3).
              </t>
              
              <t>
                The proxy may eavesdrop on metadata (including the cache key) or
                may make requests on behalf of alleged clients (T2:3.1, T4:3.2).
              </t>
              
              <t>
                The proxy may drop messages without the endpoint being able to
                infer that the message is lost due to the proxy (T3:3.1).
              </t>
              
              <t>
                The proxy may delay messages without being detected (T3:3.2).
              </t>
              
              <t>
                The client may not be able to verify validity information 
                provided by proxy when using ETag (T1:3.10).
              </t>
            </list>
            
          </t>
        </section>
        
      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->

      
      <section title="Multiple Requests - Multiple Responses: Observe">
        
        <t>
          This scenario is about replicating a resource state from a
          server to a client.  The client observes a
          resource and receives notifications which may be cached.
          The difference compared to the previous scenario
          (<xref target="mulreq-oneres"/>) is the capability
          to send multiple responses in reply to a single request.
          The difference compared to <xref target="onereq-mulres"/>
          is that in this scenario multiple clients may be served
          with the same response.
        </t>
        
        <t>
          This functionality protects communication-constrained servers from
          repeated requests, which may come from different clients, when the
          resource is unchanged. This saves system resources and bandwidth.
        </t>
        
        <t>
          In addition to multiple clients' requests being served by one
          response, each request may result in multiple responses.
        </t>

        
        <figure anchor="figure-observe" title="Message Flow for Observe with Multiple Observers">
          <artwork align="center">
<![CDATA[Client A         Proxy          Server
   |               |               |
   |    Request    |    Request    |
   |-------------->|-------------->|--.
   |               |               |  |
   |<--------------|<--------------|<-'
   |  Notification |  Notification |
   |               |               |
                   |               |
Client B           |               |
   |               |               |
   |    Request    |               |
   |-------------->|--.            |
   |               |  | from cache |
   |<--------------|<-'            |
   |  Notification |               |
   |               |               |
   |<--------------|<--------------|
   |  Notification |  Notification |
   |               |               |
                   |               |
Client A           |               |
   |               |               |
   |<--------------|               |
   |  Notification |               |
   |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          The server exposes an observable resource (e.g., the current
          reading of a temperature sensor).  Multiple clients are
          interested in the current state of the resource and observe
          it using the <xref target="RFC7641">CoAP resource observation
            mechanism</xref>.  The goal is to keep the state observed by
          the clients closely in sync with the actual state of the
          resource at the server.  Another goal is to minimize the
          burden on the server by moving the task to fan out
          notifications to multiple clients from the server to the
          proxy.
        </t>
        
        <t>
          Functional Requirements:
          <vspace blankLines="1"/>
          The functional requirements of the previous scenario
          (<xref target="mulreq-oneres"/>) apply, and additionally:
          <list style="symbols">
            <t>
              The proxy must be able to observe a resource on behalf of
              one or more clients.
            </t>
            <t>
              When a client registers interest in a resource with the
              proxy, the proxy must be able to return a response containing
              the current state of the resource without contacting the
              server.
            </t>
          </list>
        </t>
        
        <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          <t>
            The proxy complies with the processing rules PR3.1 - 3.5
            of the previous scenario (<xref target="PR3"/>).
            
            In addition, the following processing rules apply:
            <list style="format PR4.%d">
              <t>
                If the proxy receives a notification from the server
                that is out of sequence (as indicated by the Observe
                option), then the proxy discards the notification.
                Otherwise, the proxy proceeds to notify the registered
                observers.
              </t>
              <t>
                When notifying an observer, the proxy modifies the
                Observe option to indicate the sequence of
                notifications from the proxy to the observer.
              </t>
              
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Security Objectives">
          <t>
            The security objectives are identical to the previous scenario.
          </t>
        </section>
        
        <!-- *************************************************************** -->

        <section title="Threat Analysis and Mitigation">
          <t>
            The threat analysis from the previous scenario carries over to this
            scenario.
          </t>
          
          <section anchor="T1:4" 
                   title="T1:The proxy illegitimately modifies a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T1:3"/>).  For example in T1:3.4, a proxy may
              maliciously modify the Observe option to indicate a different 
              order of notifications without being detected.  However, the
              mitigation specified in the previous scenario applies: the server
              integrity protects a freshness parameter with the response.
            </t>
          </section>
          
          <section title="T2:The proxy illegitimately sends a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T2:3"/>).
            </t>
          </section>
          
          <section 
              title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T3:3"/>).  The threat in T3:3.4 may be combined 
              with manipulation of the Observe option, but the same mitigation 
              as mentioned in (<xref target="T1:4"/>) applies.
            </t>
          </section>
          
          <section title="T4:The proxy illegitimately reads part of a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T4:3"/>).
            </t>
          </section>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            Since the security objectives and threat mitigations carry over from
            the previous scenario (<xref target="mulreq-oneres"/>), the same
            security requirements are valid (<xref target="R3"/>).
          </t>
          
        </section>

      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->

      
      <section 
          title="Multiple Requests - Multiple Responses: Publish-Subscribe">
        
        <t>
          The intermediary node in the publish-subscribe scenario is a broker 
          for messages from a publisher to subscriber.  A subscriber subscribes
          to a "topic" and receives a publication.  The broker fans out
          subsequent publications on that topic to all subscribers.
        </t>
        
        <t>
          In this scenario a single request may result in multiple responses
          and a single response may reach multiple clients.
        </t>
        
        
        <figure anchor="figure-4" title="Message Flow for Publish-Subscribe">
          <artwork align="center">
<![CDATA[Subscriber       Broker          Publisher
(Client A)      (Server)         (Client)
    |               |               |
    |               |    Publish    |
    |            .--|<--------------|
    |   to store |  |               |
    |            '--|-------------->|
    |               |               |
    |   Subscribe   |               |
    |-------------->|--.            |
    |               |  | from store |
    |<--------------|<-'            |
    |  Notification |               |
                    |               |
(Client B)          |               |
    |               |               |
    |   Subscribe   |               |
    |-------------->|--.            |
    |               |  | from store |
    |<--------------|<-'            |
    |  Notification |               |
    |               |               |
    |               |    Publish    |
    |            .--|<--------------|
    |   to store |  |               |
    |            '--|-------------->|
    |               |               |
    |<--------------|               |
    |  Notification |               |
    |               |               |
                    |               |
(Client A)          |               |
    |               |               |
    |<--------------|               |
    |  Notification |               |
    |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          The broker maintains a number of topics that a publisher can publish
          to and a subscriber subscribe to. Topics are represented as URIs at 
          the broker. <xref target="figure-4"/> illustrates the publication to 
          a topic, implemented as a PUT request of a representation to a
          resource at the broker.</t>

        <t>
          Subscribers can make a GET request with the Observe option to the 
          topic URI at the broker in order to initiate the subscription on the
          topic.  The broker provides a notification in the form of a stored
          representation as response to the request. Further publications of
          representations to this URI are provided as notification responses to
          the subscription request.
        </t>

        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              The publication must be able to be transferred in a PUT request
              from the publisher and in a GET response to the subscriber.
            </t>
          </list>
        </t>
        
       <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          
          <t>
            <list style="format PR5.%d">
              
              <t>
                If the broker receives a subscription request to one of its
                resources, then the broker associates the requesting subscriber
                to the topic and responds with the current representation.
              </t>
              
              <t>
                If the broker receives a publication request to one of its
                resources, then the broker stores the received representation
                on the topic and responds with the representation to the
                associated subscribers of that topic.
              </t>
 
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          
          <t>
            In this scenario, there may be multiple publishers to one topic.
            A security objective of the subscriber is to be able to verify
            that a publication on a certain topic is from a publisher authorized
            to publish on this topic. In general that requires authentication
            of publication. How the subscriber knows which publications are
            authorized is out of scope.
          </t>
          
          <t>
            The security objectives for this scenario are:
            <list style="format SO5.%d">
              <t>
                A subscriber is able to verify that a received response
                contains a resource representation by an authorized publisher,
                and of a requested topic, and
                that it has not been altered between publisher and subscriber.
              </t>
              
              <t>
                A subscriber is able to verify that a received
                resource representation is fresh.
              </t>
              
              <t>
                The publisher is able to protect a resource representation such
                that only authorized subscribers can read the representation.
              </t>
              
            </list>

          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now analyze the potential threats relevant to this scenario.
          </t>
          
          
          <section title="T1:The broker illegitimately modifies a message">
            <t>
              <list style="format T1:5.%d">

                <t>
                  The broker responds to a subscriber request with a 
                  publication containing a modified payload
                  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The broker responds to a subscriber request with a
                  publication containing a modified CoAP option
                  <vspace blankLines="1"/>
                  Since the security objective is to protect the resource
                  representation, only options in the GET response that
                  influence the interpretation of the resource representations
                  have an impact.  A broker is entitled to change Max-Age and
                  may do so maliciously.  The broker is not entitled to change 
                  Content-Format, but may anyway do so maliciously.  To mitigate
                  these, the subscriber needs to be able to verify information
                  about freshness and content format provided by the publisher.
                </t>
                
                
                <t>
                  The broker responds to a subscriber request with modified 
                  CoAP header fields
                  <vspace blankLines="1"/>
                  Since the security objective is to protect the resource
                  representation, only header fields in the GET response that 
                  influence the interpretation of the resource representations
                  have an impact.  Changing of Code such as e.g. 2.05 (Content) 
                  to some error code is a denial-of-service.
                </t>
                
                
                <t>
                  The broker modifies the publication before or during storage
                  <vspace blankLines="1"/>
                  This threat is analogous to the previous threats and is
                  mitigated in the same way.
                </t>
              
                
                <t>
                  The broker responds to a subscriber request with the wrong 
                  message
                  <vspace blankLines="1"/>
                  Modifications of payload, options, and header are considered 
                  previously.  To mitigate wrong a interpretation of a response
                  resulting from a broker sending old messages or reordering 
                  messages from the same publisher to the same subscriber, the
                  message may integrity protect a freshness parameter 
                  (timestamp, counter, etc.) from which the age/order can be 
                  deduced (replay/reordering protection).
                </t>
                
                
                <t>
                  The broker colludes with a legitimate subscriber having 
                  access to the key used to create Message Authentication Codes
                  (MAC) of publications in order to generate a valid MAC of a
                  modified publication
                  <vspace blankLines="1"/>
                  This threat applies to publications containing a message
                  authentication code (MAC) for integrity protecting the 
                  resource representation.  The threat may be mitigated by the 
                  publisher digitally signing the representation with a private
                  key instead of using a MAC.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section title="T2:The broker illegitimately sends a message">
            <t>
              <list style="format T2:5.%d">
                
                <t>
                  The broker sends a response to a subscriber request without a
                  previous publication from the publisher
                  <vspace blankLines="1"/>
                  Most cases of responding inappropriately to a subscriber
                  request are covered in the previous section.  In general,
                  authentication of publisher in combination with
                  replay/reordering protection will mitigate this threat.
                </t>
                
                <t>
                  A broker sends a number of messages for the purpose of 
                  flooding the subscriber
                  <vspace blankLines="1"/>
                  By verifying the integrity and freshness information, the 
                  subscriber may mitigate certain flooding attacks.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:5" 
            title="T3:The broker illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:5.%d">
                <t>
                  The broker does not store or forward a publication
                  <vspace blankLines="1"/>
                  This is a denial-of-service attack.  While these threats may
                  be difficult to mitigate, missing messages are common in
                  lossy environments so applications should have a readiness
                  for this kind of issue.
                </t>
                
                <t>
                  The broker does not respond to a publication request
                  <vspace blankLines="1"/>
                  This may be a denial-of-service attack on
                  the publisher.  While such a threat may be difficult to 
                  mitigate, missing messages are common in lossy environments
                  so applications should have a readiness for this kind of
                  issue.
                </t>
              
                <t>
                  The broker delays forwarding of a received publication
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so it
                  may be difficult to detect and mitigate.
                </t>
                
                <t>
                  The broker reorders the publications
                  <vspace blankLines="1"/>
                  This threat may be mitigated by
                  the publisher integrity protecting the message and including
                  a freshness parameter.
                </t>
        
              </list>
            </t>
          </section>
          
          <section title="T4:The broker illegitimately reads part of a message">
            <t>
              <list style="format T4:5.%d">
                <t>
                  The broker reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the
                  representation and other potential payload data
                </t>
                
                <t>
                  The broker infers information about the nature and state of 
                  the publication from CoAP options and header fields.
                  <vspace blankLines="1"/>
                  This metadata is not in scope of confidentiality.  
                  Information leaking that can be inferred from such data 
                  cannot be prevented.
                </t>
                
                <t>
                  The broker reads and stores all publications and can
                  deduce information about the entire history of the publications
                  and subscriptions
                  <vspace blankLines="1"/>
                  Since the protection of metadata related to subscription and
                  publication is not in scope of the security objectives,
                  the mitigation is restricted to encrypting
                  the resource representations.
                  The case of long term key compromise would nevertheless reveal
                  the history of a publication, but this can be mitigated with
                  forward secrecy.
                </t>
                
              </list>
            </t>
          </section>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for the publish-subscribe scenario.  For each requirement and 
            non-requirement the associated threats are listed.  The security
            requirements are:
            
            <list style="format R5.%d">
              <t>
                The subscriber must be able to verify that a received resource
                representation originates from an authorized publisher (T1:5.1,
                T2:5.1).
              </t>
              
              <t>
                The subscriber must be able to verify that a received 
                representation is a representation of the resource requested by
                the subscriber (T1:5.1, T1:5.4, T1:5.5, T1:5.6).
              </t>
              
              <t>
                The subscriber must be able to verify the content format of the 
                representation (T1:5.2)
              </t>
              
              <t>
                The subscriber must be able to detect that the received resource
                representation is older than a previously received
                representation of this resource (T1:5.5, T2:5.1, T3:5.4).
              </t>
              
              <t>
                The representation must be integrity protected and encrypted
                from publisher to subscriber  (T1:5.1, T1:5.5, T2:5.2, T4:5.1).
              </t>
              
              <t>
                To protect against the proxy colluding with an authorized 
                subscriber, asymmetric cryptography must be used  (T1:5.6).
              </t>
              <t>
                The communication protocol must provide forward secrecy (T4:5.3).
              </t>
            </list>
            The security non-requirements of the pub-sub scenario are:
            
            <list style="format NR5.%d">
              
              <t>
                The subscription request is not protected (see Security 
                Objectives).
              </t>
              
              <t>
                The header and options of the notification response are not 
                protected (see Security Objectives, compare R5.3).
              </t>
              <t>
                The broker may change and eavesdrop on certain metadata without
                being detected (T1:5.2, T1:5.3, T4:5.2).
              </t>
              
              <t>
                The broker may drop messages without being detected (T3:5.1, 
                T3:5.2).
              </t>
              
              <t>
                The broker may delay messages without being detected (T3:5.3).
              </t>
            </list>
            
          </t>
          
        </section>
        
      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
      
    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Acknowledgments" numbered="no">

      <!-- sorted by last name -->
      <t>
        Thanks to
        Ari Keranen,
        John Mattsson,
        Jim Schaad, and
        Ludwig Seitz
        for helpful comments and discussions that have shaped the
        document.
      </t>

    </section>
   
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
