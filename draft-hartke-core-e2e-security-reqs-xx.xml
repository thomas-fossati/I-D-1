<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
  <!ENTITY RFC4949 SYSTEM "reference.RFC.4949.xml">
  <!ENTITY RFC6347 SYSTEM "reference.RFC.6347.xml">
  <!ENTITY RFC7228 SYSTEM "reference.RFC.7228.xml">
  <!ENTITY RFC7252 SYSTEM "reference.RFC.7252.xml">
  <!ENTITY RFC7258 SYSTEM "reference.RFC.7258.xml">
  <!ENTITY RFC7641 SYSTEM "reference.RFC.7641.xml">
  <!ENTITY I-D.ietf-cose-msg SYSTEM "reference.I-D.ietf-cose-msg.xml">
  <!ENTITY I-D.mattsson-core-coap-actuators SYSTEM "reference.I-D.mattsson-core-coap-actuators.xml">
  <!ENTITY I-D.koster-core-coap-pubsub SYSTEM "reference.I-D.koster-core-coap-pubsub.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>

<rfc category="info" docName="draft-hartke-core-e2e-security-reqs-01" ipr="trust200902">
    
    <front>

    <title>Requirements for CoAP End-To-End Security</title>

    <author initials="G." surname="Selander" fullname="Goeran Selander">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>goran.selander@ericsson.com</email>
      </address>
    </author>
    
    <author initials="F." surname="Palombini" fullname="Francesca Palombini">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>francesca.palombini@ericsson.com</email>
      </address>
    </author>
   
    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63905</phone>
        <email>hartke@tzi.org</email>
      </address>
    </author>
    
    <!--
    <author initials="L." surname="Seitz" fullname="Ludwig Seitz">
      <organization>SICS Swedish ICT AB</organization>
      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <city>Lund</city>
          <code>223 70</code>
          <country>Sweden</country>
        </postal>
        <email>ludwig@sics.se</email>
      </address>
    </author>
    -->
    
    <date />


    <area>Applications</area>

    <workgroup>CoRE Working Group</workgroup>

    <abstract>

      <t>
        This document analyses threats to CoAP message 
        exchanges traversing proxies and derives the security requirements
        for mitigating those threats.
      </t>

    </abstract>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction">

      <t>
        The <xref target="RFC7252">Constrained Application Protocol
        (CoAP)</xref> is a Web application protocol designed for
        <xref target="RFC7228">constrained nodes and networks</xref>.
        CoAP uses <xref target="RFC6347">Datagram Transport Layer
        Security (DTLS)</xref> for security.  At the same time, CoAP
        relies on proxies for scalability and
        efficiency:  Proxies can
        reduce response time and network bandwidth use by serving
        responses from a cache or enable clients to make requests that
        they otherwise could not make.
      </t> 
       
      <t>
        CoAP proxies need to perform a
        number of operations on requests and responses, which requires
        DTLS to be terminated at the proxy.  The proxies therefore do
        not only have access to the data required for performing the
        desired proxy functionality, but are also able to eavesdrop on
        or manipulate any part of the CoAP payload and metadata in
        transit between client and server or inject new CoAP messages
        without being protected or
        detected by DTLS.
      </t>

      <figure anchor="fig-hopbyhop" title="Hop-by-Hop Security">
        <artwork align="left">
<![CDATA[     __________       _________       _________       __________
    |          |     |         |     |         |     |          |
    |          |---->|         |---->|         |---->|          |
    |  Client  |     |  Proxy  |     |  Proxy  |     |  Server  |
    |          |<----|         |<----|         |<----|          |
    |__________|     |_________|     |_________|     |__________|
          :             :   :           :   :             :
          '-------------'   '-----------'   '-------------'
             Security         Security         Security
            Association      Association      Association
                 A                B                C]]>
        </artwork>
      </figure>
      
      <t>
        One way to mitigate this threat is to secure CoAP communication
        at the application layer using an object-based security
        mechanism such as <xref target="I-D.ietf-cose-msg">CBOR
        Encoded Message Syntax</xref> instead of or in addition to
        the security mechanisms at the network layer or transport
        layer. Such a mechanism can provide "end-to-end security" at
        the application layer in contrast to the "hop-by-hop security"
        provided by DTLS.
      </t>

      <figure anchor="fig-endtoend" title="End-to-End Security">
        <artwork align="left">
<![CDATA[     __________       _________       _________       __________
    |          |     |         |     |         |     |          |
    |          |---->|         |---->|         |---->|          |
    |  Client  |     |  Proxy  |     |  Proxy  |     |  Server  |
    |          |<----|         |<----|         |<----|          |
    |__________|     |_________|     |_________|     |__________|
          :                                               :
          '-----------------------------------------------'
                        Security Association]]>
        </artwork>
      </figure>

      <t>
        This document analyses security aspects of sensor and actuator
        comunications over CoAP that involve proxies and
        other similar intermediaries.  The analysis is based on identifying
        the assets associated with this communication
        and considering the potential threats posed by
        proxies to these assets.  The threat analysis provides the basis for
        recommending security requirements that an end-to-end security
        mechanism for CoAP needs to meet.
      </t>

      <section title="Scope and Assumptions">

        <t>
          In general, there are the following types of assets that
          need to be protected:
          <list style="format A%d:" counter="my_count">
            <t>
              The devices at the two ends, the data generated and stored in
              these devices, and their (often very
              constrained) system resources such as available memory, storage,
              processing capacity, and energy.
            </t>
            <t>
              The physical environment of the devices fitted with sensors
              and actuators.  Access to the physical environment is
              provided through CoAP resources that allow a remote entity
              to retrieve information about the physical environment
              (such as the current temperature) or to produce an effect
              on the physical environment (such as the activation of a
              heater).
            </t>
            <t>
              The communication infrastructure linking the two devices
              (which often contains some very constrained parts) and the data
              stored in the message processing devices.
            </t>
          </list>
        </t>

        <t>
          The purpose of this document is to analyze threats executed through
          intermediary nodes. An intermediary may directly affect assets of
          type A3, e.g. by dropping messages. An intermediary node may also
          manipulate the messages exchanged between the endpoints and thereby
          have an impact also on the assets A1 and A2, for example: flooding a
          device with messages has impact on its
          system resources, and successful manipulation of an actuator command,
          carried in a message, has an impact on the physical environment.
        </t>

        <t>
          An intermediate node handling unprotected messages may be an attractive
          target for an attack, since such nodes are aggregation points for message flows
          (see <xref target="sec-cons"/>) and, furthermore, may be an easier target from the
          Internet than the sensors/actuators residing behind them.  An intermediary
          may become subject to intrusion or infected by malware and perform
          the attacks of a man-in-the-middle; the attack vectors for
          compromise are out of scope for this document.
        </t>

        <t>
          The scope of the analysis is
          restricted to threats from intermediaries to single client to server
          interactions.  Threats resulting from collusion between multiple
          intermediaries are also out of scope (see <xref target="sec-cons"/>).
        </t>

        <t>
          To assess what impact various threats have to the assets, we need to specify
          and analyse how the intermediary nodes operate.
        </t>

      </section>
    
      <section title="Terminology">

        <!--
        <t>
          This document makes use of the terminology defined in
          <xref target="RFC4949"/>.
        </t>
        -->

        <t>
          Readers are expected to be familiar with the terms and
          concepts described in <xref target="RFC7252"/> and
          <xref target="RFC7641"/>.
        </t>

        <!--
        <t>
          Additionally, the following terms are used in this document:
          <list style="hanging">
            <t hangText="...:">...</t>
          </list>
        </t>
        -->

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to
          be interpreted as described in <xref target="RFC2119"/>.
          The key word "NOT REQUIRED" is interpreted as synonymous with
          the key word "OPTIONAL".
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Proxying" anchor="proxying">
      
      <figure anchor="fig-proxy" title="A Proxy">
        <artwork align="left">
          <![CDATA[
            _ _ __             ___________             __ _ _
                  | Request   |           | Request   |
          Client  |---------->|           |---------->|  Server
            or    |           |   Proxy   |           |    or
          Proxy   |<----------|           |<----------|  Proxy
            _ _ __|  Response |___________|  Response |__ _ _]]>
        </artwork>
      </figure>
      
      
      <figure anchor="fig-server-req" title="alternative figure">
        <artwork align="left">
          <![CDATA[
             ________            _________            ________
            |        | Request  |         | Request  |        |
            |        |--------->|         |--------->|        |
            | Client |          |  Proxy  |          | Server |
            |        |<---------|         |<---------|        |
            |________| Response |_________| Response |________|
          ]]>
        </artwork>
      </figure>
      
      <t>
        The proxy receives a request from the client and sends a
        response back to the client. There are two ways for the
        proxy to do this:
        <list style="symbols">
          <t>
            The proxy constructs and sends a request to the server,
            receives a response from the server and uses the
            received data to construct the response to the client.
          </t>
          <t>
            The proxy uses cached data to construct the response to
            the client.
          </t>
        </list>
        In both cases, the proxy needs to read some parts of the
        request from the client and the response from the server
        to accomplish its task. Also, if the intermediary sends a request
        to the origin server, this request is not necessarily identical to the
        request received from the client, and analogously for the response.
      </t>
      
      <t>
        The proxy may in turn make a request to another proxy.
        In the case of hop-by-hop security (<xref target="fig-hopbyhop"/>) each node
        has a security association with its nearest hop neighbour.
      </t>
      
      <t>
        In the case of end-to-end security (<xref target="fig-endtoend"/>) the
        client has a security association with the origin server
        and the proxies are only trusted with performing its
        intended operations.
      </t>

      <t>
        <vspace blankLines="100"/>
      </t>

      <!-- **************************************************************** -->

      <section title="Threats and Security Requirements">

        <section title="Client" anchor="sec-client">

          <figure anchor="fig-client" title="The Client End">
            <artwork align="left">
<![CDATA[     __________             __ _ _
    |          | Request   |
    |          |---------->|
    |  Client  |           |   Proxy
    |          |<----------|
    |__________|  Response |__ _ _]]>
            </artwork>
          </figure>

          <t>
            The client sends a request and waits for a
            response.
          </t>
          <t>
            From the perspective of the client, there are three possible
            flows:
            <list style="symbols">
              <t>
                The client receives a response.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The request is duly processed and a response is received
                    based on data from the origin
                    server.
                  </t>
                  <t>
                    The response is a proxy
                    error according to specification
                    (e.g., 5.02 Bad Gateway or 5.04 Gateway Timeout).
                  </t>
                  <t>
                    (Threat 1:) The response is spoofed by an intermediary node.
                  </t>
                </list>
              </t>
              <t>
                The client does not receive a response.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The client times out too early.
                  </t>
                  <t>
                    (Threat 2:) A messages is withheld by an intermediate node.
                  </t>
                </list>
              </t>
              <t>
                The client receives too many responses.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    (Threat 3:) The proxy floods the client with
                    responses.
                  </t>
                </list>
              </t>
            </list>
            This is repeated as often as needed when the client
            observes a resource. TODO: Can this be explained in another way?
          </t>
          
          <t>
            An intermediate node may eavesdrop or infer information from messages
            it operates on.  Such information can be used for targeted attacks as
            well as pervasive monitoring. There are the following threats:
            <list style="symbols">
              <t>(Threat 7:) An intermediate node eavesdrops on data in the
                request from the client and in the response from the server.
              </t>
              <t>(Threat 8:) An intermediate node infers information about
                the nature or content of a message by
                measuring size, frequency or distribution of incoming requests
                or outgoing responses.</t>
            </list>
          </t>
          
          <t>
            Note that "cache poisioning" - the case of caching injected
            incorrect responses - is covered from the point of view of
            the client: it may result in the client receiving a spoofed
            message, or being flooded, or affect other nodes such that the
            client times out too early.
          </t>
          
          <t>
            <vspace blankLines="100"/>
          </t>

          <section title="Threat 1: Spoofing" anchor="spoofing-client">
            <t>
              Except as specified below, this threat is REQUIRED
              to be mitigated by the security solution: the client MUST
              verify that the response is an
              <spanx>authentic response</spanx> before processing it.
            </t>
            <t>
              The definition of an "authentic response"
              depends on the proxy case
              (<xref target="proxy-scenarios"/>),
              but usually means that the client can verify
              some or all of the following things:
              <list style="symbols">
                <t>that the requested action was executed by the origin server;</t>
                <t>that the data originates from the origin server and has not been altered on the way;</t>
                <t>that the data matches the specifications of the request (such as the target resource);</t>
                <t>that the data is fresh (when the data is cacheable);</t>
                <t>that the data is in sequence (when observing a resource).</t>
              </list>
              The proof can, for example, involve a message
              authentication code from the origin
              server or an additional
              challenge-response roundtrip.
            </t>
            <t>
              Note that a CoAP proxy is specified to return an error
              response (such as 5.02 Bad Gateway or 5.04 Gateway
              Timeout) when it encounters an error condition. Since the
              condition occurs at the proxy and not at the origin
              server, the response will not be an "authentic response"
              according to the above definition. Thus a client cannot
              tell if the proxy sends the response according to
              specification or if it spoofs the response.
              This threat is NOT REQUIRED to be mitigated by the
              security solution.
            </t>
          </section>

          <section title="Threat 2: Withholding">
            <t>
              This threat is NOT REQUIRED to be mitigated by the
              security solution because a CoAP client or server cannot tell
              if an intermediate node does not send a message because it is
              busy, or if it intentionally drops a message.
            </t>
            <t>
              Applications sensitive to delay of requests, e.g. certain actuator
              applications, must protect against this kind of threats,
              see <xref target="I-D.mattsson-core-coap-actuators"/>.
              That is out of scope for this document.
            </t>
            
          </section>
          
          <section title="Threat 3: Flooding">
            <t>
              A CoAP client is specified to reject any response that
              it does not expect. This can happen before the client
              verifies if the response is authentic.
              Therefore a flood of responses is primarily a threat to
              the system resources of the client, in particular to its
              energy.
              This threat is NOT REQUIRED to be mitigated by the
              security solution in particular, but a client SHOULD
              generally defend against flooding attacks.
            </t>
          </section>
          
          <section title="Threat 7: Eavesdropping" anchor="eavesdrop">
            
            
            <t>
              This threat is REQUIRED to be mitigated by the security
              solution: clients and servers MUST confidentiality protect
              the data in the requests and responses they send.
            </t>
            <t>
              The definition of what needs to be protected depends on the proxy
              case (<xref target="proxy-scenarios"/>), but it is RECOMMENDED
              to encompass all data that is not
              needed to be read by the intermediate node to
              accomplish its task.
            </t>

          </section>
          
          <section title="Threat 8: Traffic Analysis" anchor="traffic-an">
            <t>
              This threat is NOT REQUIRED to be mitigated by the security solution.
            </t>
            <t>
              It is RECOMMENDED that applications analyse the risks associated with
              application information leaking from the messages flow and assess the
              feasibility to protect against various threats, e.g. by obfuscating
              parameters transported in plain text, aligning message flow and
              traffic between the different cases, adding padding so different
              messages become indistinguishable, etc.
            </t>
            
            <t>
              TODO: forward secrecy
              <vspace blankLines="100"/>
            </t>
          </section>

        </section>

        <section title="Server">

          <figure anchor="fig-server" title="The Server End">
            <artwork align="left">
<![CDATA[                                 _ _ __             __________
                                       | Request   |          |
                                       |---------->|          |
                               Proxy   |           |  Server  |
                                       |<----------|          |
                                 _ _ __|  Response |__________|]]>
            </artwork>
          </figure>

          <t>
            A server listens for a request and returns a response.
          </t>
          <t>
            From the perspective of the server, there are three possible
            flows:
            <list style="symbols">
              <t>
                The server receives a request.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The request was sent according to
                    specification.
                  </t>
                  <t>
                    (Threat 4:) An intermediate node spoofs a request.
                  </t>
                </list>
              </t>
              <t>
                The server does not receive a request.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    A request has not been sent.
                  </t>
                  <t>
                    (Threat 5:) An intermediate node withholds a request.
                  </t>
                </list>
              </t>
              <t>
                The server receives too many requests.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    (Threat 6:) An intermediate node floods the server with
                    requests.
                  </t>
                </list>
              </t>
            </list>
          </t>
          
          <t>
            An intermediate node eavesdropping or
            inferring information from messages it operates has an impact
            on a server in the same way as on a client, see
            <xref target="sec-client"/>. Threats 7 and 8 applies also to the
            server.
          </t>

          <t>
            <vspace blankLines="100"/>
          </t>

          <section title="Threat 4: Spoofing" anchor="spoofing-server">
            <t>
              Except as specified below, this threat is REQUIRED to be mitigated
              by the security
              solution: the server MUST verify that the request is an
              <spanx>authentic request</spanx> before processing it.
            </t>
            <t>
              The definition of an "authentic request"
              depends on the scenario
              (<xref target="proxy-scenarios"/>),
              but usually means that the server can verify
              some or all of the following things:
              <list style="symbols">
                <t>that a proxy acts on behalf of a client;</t>
                <t>that the data originates from the client and has not been altered on the way;</t>
                <t>that the request has not been received previously;</t>
                <t>that the data has been generated recently by the client.</t>
              </list>
              The proof can, for example, involve a message
              authentication code that the proxy obtains from the
              client and includes in the request or a
              challenge-response roundtrip.
            </t>
            
            <t>
              Note that a CoAP proxy may be allowed to make a
              validation request to a resource without it being possible to
              prove that it acts on behalf of a client. Since such a
              request does not originate from the client, the server cannot
              tell if the proxy sends the request according to specification
              or if it spoofs the request.  If the proxy processing rules
              (<xref target="proxy-scenarios"/>)
              specify this functionality, then this threat is NOT REQUIRED
              to be mitigated by the security solution.
            </t>
            
            
          </section>
          

          <section title="Threat 5: Withholding">
            <t>
              This threat is NOT REQUIRED to be mitigated by the
              security solution because a CoAP server cannot detect if
              the proxy does not send a request because it has no work
              to do or if it withholds a request.
            </t>
            <t>
              Applications sensitive to delay of requests, e.g. certain actuator
              applications, must protect against this kind of threats,
              see <xref target="I-D.mattsson-core-coap-actuators"/>.
              That is out of scope for this document.
            </t>
          </section>

          <section title="Threat 6: Flooding">
            <t>
              This threat is NOT REQUIRED to be mitigated by the
              security solution in particular, but a server SHOULD
              generally defend against flooding attacks.
            </t>
    
          </section>
          
          <section title="Threat 7: Eavesdropping">
            
            
            <t>
              This threat is REQUIRED to be mitigated by the security
              solution, see (<xref target="eavesdrop"/>).
            </t>
            
          </section>
          
          <section title="Threat 8: Traffic Analysis">
            <t>
              This threat is NOT REQUIRED to be mitigated by the security
              solution, see (<xref target="traffic-an"/>.
            </t>
            <t>
              <vspace blankLines="100"/>
            </t>
  
          </section>
          
        </section>
        
        <section title="Summary">
          
          <t>
            The security solution MUST protect client and server
            against threats to authenticity
            and confidentiality as defined in relation to the legimitate
            proxy operations in the different cases
            (<xref target="proxy-scenarios"/>).
          </t>
          <t>
            Flooding attacks SHOULD be mitigated. Plain text of message data
            SHOULD be restricted to a need-to-know basis for intermediate nodes,
            and traffic analysis SHOULD be mitigated.
          </t>
          <t>
            Mitigation of spoofing of error messages or other legitimate messages
            originating from the intermediate node is not in scope of the security
            solution. Delay attacks are out of scope.
          </t>
        </section>
        
        
        
      </section>

      <!-- **************************************************************** -->

      <section title="Proxy cases" anchor="proxy-scenarios">


<t>
  In this section we study end-to-end security properties across
  different kinds of proxies. For each kind of proxy, we present
  <list style="symbols">
    <t>the functional requirements of the proxy;</t>
    <t>the processing rules of the proxy;</t>
    <t>the required authenticity properties of the messages;</t>
    <t>the required confidentiality properties of the messages; and</t>
    <t>the resulting security requirements for message transfer
      between the endpoints.</t>
  </list>
</t>
<t>
  Multiple intermediary nodes of different kinds may used in one
  deployment. This is FFS.
</t>
<t>
  Note that since CoAP was not designed for end-to-end security;
  solutions complying with these security requirements extend the
  applicability of CoAP beyond its original scope.
</t>

<section title="Forwarding" anchor="onereq-oneres" >
  
  <t>
    In this case we study forwarding functionality of a CoAP
    forward proxy, and assume that caching is disabled.
    This is applicable to many
    security critical use cases where a response needs to be securely
    linked to a unique request from a client and cannot be re-used with
    another request.
  </t>
  <t>
    There may be a unique response for each request
    (see <xref target="figure-1"/>) or multiple responses for each
    request (see <xref target="figure-2"/>).
  </t>
  
  <section title="Examples" >
    <t>
      Examples of the need for unique response for each request include
      alarm status retrieval and actuator command confirmation.
    </t>
    
    <figure anchor="figure-1" title="Message Flow with a Unique Response for Each Request">
      <artwork align="center">
        <![CDATA[
          Client          Proxy          Server
          |               |               |
          |    Request    |    Request    |
          |-------------->|-------------->|--.
          |               |               |  |
          |<--------------|<--------------|<-'
          |    Response   |    Response   |
          |               |               |]]>
      </artwork>
    </figure>
    
    
    <t>
      <list style="hanging">
        <t hangText="Example: Alarm status retrieval">
          <vspace blankLines="1"/>
          <xref target="figure-1"/> can be seen as an illustration of a
          message exchange for a client requesting the alarm status (e.g.,
          GET /alarm_status) from a server.  Since the client wants to ensure
          that the alarm status received is reflecting the current alarm
          status and not a cached or spoofed response to the same
          resource, it must be able to verify that the received response is
          a response to this particular request made by the client.
          Therefore the response must be securely linked to the request.
        </t>
        <t hangText="Example: Actuation confirmation">
          <vspace blankLines="1"/>
          Another example for which <xref target="figure-1"/> serves as
          illustration is the confirmation of an actuator request.  In this
          case a client, say in an industrial control system, requests a
          server that a valve should be turned to a certain level, e.g. PUT
          /valve_42/level with payload "3".  In order for the client to
          correctly evaluate the result of a potential changed valve level,
          it is important that the client gets a confirmation how the
          server responded to the requested change, e.g., whether the request
          was performed or not.  Again, the client wants to ensure that the
          response is reflecting the result of this particular actuation
          request made by the client and not a cached or spoofed response.
          Therefore the response must be securely linked to the request.
        </t>
      </list>
    </t>
    <t>
      An example of the use of multiple responses for each request is
      in security critical monitoring scenarios where time synchronization
      cannot be guaranteed. By avoiding repeated requests from the same
      client to the same resource, constrained node resources and bandwidth
      is saved.
    </t>
    
    
    <figure anchor="figure-2" title="Message Flow of Notifications of
      Linked to a Unique Request">
      <artwork align="center">
        <![CDATA[
          Client          Proxy          Server
          |               |               |
          |    Request    |    Request    |
          |-------------->|-------------->|--.
          |               |               |  |
          |<--------------|<--------------|<-'
          |  Notification |  Notification |
          |               |               |
          |<--------------|<--------------|
          |  Notification |  Notification |
          |               |               |
          |<--------------|<--------------|
          |  Notification |  Notification |
          |               |               |]]>
      </artwork>
    </figure>
    
    <t>
      
      <list style="hanging">
        <t hangText="Example: Secure parameter monitoring">
          <vspace blankLines="1"/>
          <xref target="figure-2"/> can be seen as an illustration of a
          message exchange for a client monitoring an important parameter
          measured by the
          server, e.g., in a medical or process industry application.
          The client makes a subscription request for a resource
          and the server responds with notifications, e.g. providing
          updates to the parameter on regular time intervals.
        </t>
        <t>
          The client wants to ensure that the first received notification
          reflects the current parameter value and that subsequent
          notifications are timely updates of the initial request.  Since
          notifications may be lost or reordered, the client needs to be
          able to verify the order of the messages, as sent by the server.
          By monitoring the received messages and the time they are
          received, the client can detect missing notifications and take
          appropriate action.
        </t>
      </list>
    </t>
    
  </section>
  
  
  <section anchor="FR1" title="Functional Requirement">
    
    <t>
      <list style="format FR1.%d">
        <t>
          The caching functionality MUST be inhibited;
          the CoAP option Max-Age of the responses SHALL be 0
          (see Section 5.7.1 of <xref target="RFC7252"/>).
        </t>
      </list>
    </t>
  </section>
  
  <!-- *************************************************************** -->
  
  <section anchor="PR1" title="Processing Rules">
    <t>
      In this scenario, the desired proxy functionality is
      to forward a translated request to the determined destination.
      There are two modes of operation for requests:
      Either using the Proxy-Uri option (PR1.1) or using the
      Proxy-Scheme option together with the Uri-Host, Uri-Port,
      Uri-Path and Uri-Query options (PR1.2).
      <list style="format PR1.%d">
        <t>
          The Proxy-Uri option contains the request URI
          including request scheme (e.g. "coaps://"); the
          Proxy-Scheme and Uri-* options are not present.
          <vspace blankLines="1"/>
          If the proxy is configured to forward requests to
          another proxy, then it keeps the Proxy-Uri
          option; otherwise, it splits the option into its
          components, adds the corresponding Uri-* options and
          removes the Proxy-Uri option.
          Then it makes the request using the request scheme
          indicated in the Proxy-Uri.
        </t>
        <t>
          The Proxy-Scheme option
          and the Uri-* options together contain the request URI;
          the Proxy-Uri option is not present.
          <vspace blankLines="1"/>
          If the proxy is configured to forward requests to
          another forwarding proxy, then it keeps the
          Proxy-Scheme and Uri-* options; otherwise, it removes
          the Proxy-Scheme option.  Then it makes the request
          using the request scheme indicated in the removed
          Proxy-Scheme option.
        </t>
        <t>
          Responses are forwarded by the proxy, without any modification.
        </t>
      </list>
    </t>
  </section>
  
  
  
  <!-- *************************************************************** -->
  <section anchor="auth-1" title="Authenticity">
    <t>
      This section defines when
      a message is considered authentic (see
      <xref target="spoofing-client"/> and <xref target="spoofing-server"/>).
    </t>
    <t>
      The request is considered authentic by the server if:
      <list style="format A1.%d" counter="A1_count">
        <t>
          The request originates from the client
        </t>
        <t>
          The CoAP payload of the request has not been altered.
        </t>
        <t>
          The CoAP options of the request have not been altered in any
          other way than defined in <xref target="PR1" />.
        </t>
        <t>
          The effective URI of the request is not changed.
        </t>
        <t>
          The CoAP header fields Version and Code of the request have not
          been altered.
        </t>
        <t>
          The request has not been previously received.
        </t>
        <t>
          The request was recently sent by the client.
        </t>
      </list>
    </t>
    <t>
      <vspace blankLines="1"/>
    </t>
    <t>
      The response is considered authentic by the client if:
      <list style="format A1.%d" counter="A1_count">
        <t>
          The response originates from the server.
        </t>
        <t>
          The CoAP payload, options and header fields Version and Code of
          the response have not been altered.
        </t>
        <t>
          The response has not been previously received.
        </t>
        <t>
          The response was recently sent by the server.
        </t>
        <t>
          The response corresponds to a unique request
          sent by the client.
        </t>
        <t>
          If there are multiple responses, the client should
          be able to verify that
          is the case, as well as the order of the responses.
        </t>
        
      </list>
    </t>
    
  </section>
  
  <!-- *************************************************************** -->
  <section anchor="conf-1" title="Confidentiality">
    
    <t>
      This section defines when
      a message is considered confidentiality protected (see
      <xref target="eavesdrop"/>).
    </t>
    
    <t>
      A message is considered confidentiality protected if:
      <list style="format C1.%d">
        <t>
          The CoAP payload (if present) is confidentiality protected
        </t>
        <t>
          All CoAP options of the request and response, except
          Uri-Host/Port and Proxy-Uri/Scheme, are confidentiality
          protected.
        </t>
        <t>
          The keys used for confidentiality protection provides forward
          security.
        </t>
      </list>
    </t>
    
  </section>
  
  <!-- *************************************************************** -->
  
  
  <section anchor="R1" title="Security Requirements">
    <t>
      This section contains the security requirements for this scenario.
      For each requirement the associated functional requirement,
      processing rule, authenticity property, or confidentiality
      property is listed.  The security requirements are:
      <list style="format R1.%d">
        
        <t>
          The server MUST authenticate a message coming
          from a requesting client (A1.1).
        </t>
        
        <t>
          The CoAP payload MUST be integrity protected and encrypted
          between client and server (A1.2, C1.1).
        </t>
        
        <t>
          The CoAP options except Uri-* and Proxy-* MUST be integrity
          protected in the request.  The effective request URI
          MUST be integrity protected in the request (PR1.1, PR1.2, A1.3,
          A1.4).
        </t>
        
        <t>
          The CoAP header fields Version and Code MUST be integrity
          protected in requests and responses.  All other header fields
          must not be integrity protected.  The header fields MUST not be
          encrypted (A1.5).
        </t>
        
        <t>
          The server MUST verify that it has not received this request
          previously (A1.6).
        </t>
        
        <t>
          The client MUST verify that the received response
          originates from the requested server (A1.8).
        </t>
        
        <t>
          The client MUST be able to verify that multiple response to a
          request are allowed as well as the order of the responses. (A.13)
        </t>
        
        <t>
          All CoAP options in the response MUST be integrity protected.
          Max-Age MUST be set to 0 (FR1.1, PR1.3).
        </t>
        
        <t>
          The client MUST verify that a response corresponds to
          a unique previous request that the client has made (A1.12).
        </t>
        
        <t>
          The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the
          request MUST not be encrypted.  The Max-Age option of the
          response MUST not be encrypted.  All other options MUST be
          encrypted (C1.2).
        </t>
        
        
        <t>
          The communication protocol MUST provide forward secrecy (C1.3).
        </t>
        
      </list>
      
    </t>
  </section>
  
</section>


<section title="Caching">
  
  <t>
    In this case we study caching: how a proxy may serve the same
    cached response to multiple clients requesting the same resource.
  </t>
  <t>
    The caching functionality protects communication-constrained servers
    from repeated requests for the same resources, possibly originating
    from different clients. This saves system resources, bandwidth, and
    round-trip time.
  </t>
  
  <t>
    There may be one response for each request
    (see <xref target="figure-3"/>) or multiple responses for each
    request (see <xref target="figure-observe"/>).
  </t>
  
  <section title="Examples" >
    <t>
      The first example is a simple case of caching.
    </t>
    
    <figure anchor="figure-3" title="Message Flow for Cached Responses">
      <artwork align="left">
        <![CDATA[
          Client A         Proxy           Server
          |               |               |
          |    Request    |    Request    |
          |-------------->|-------------->|--.
          |               |               |  |
          |<--------------|<--------------|<-'
          |    Response   |    Response   |
          |               |               |
          |               |
          Client B           |               |
          |               |               |
          |    Request    |               |
          |-------------->|--.            |
          |               |  | from cache |
          |<--------------|<-'            |
          |    Response   |               |
          |               |               |]]>
      </artwork>
    </figure>
    
    <t>
      <list style="hanging">
        <t hangText="Example: Caching">
          <vspace blankLines="1"/>
          In <xref target="figure-3"/>, client A requests the proxy to make a
          certain request to the server and to return the server's response.
          The proxy services the request by making a request message to the
          server according to the processing rules.  If the server returns a
          cacheable response, then the proxy stores the response in its cache,
          performs any necessary translations, and forwards it to the client.
          Later, client B makes an equivalent request to the proxy that the
          proxy services by returning the response from its cache. Both
          client A and B want to verify that the response is valid.
        </t>
      </list>
    </t>
    
    <t>
      In addition to multiple clients' requests being served by one
      response, each request may result in multiple responses.
      The difference compared to <xref target="onereq-oneres"/>
      is that in this example multiple clients may be served
      with the same response, further saving server resources.
    </t>
    
    
    <figure anchor="figure-observe" title="Message Flow for Observe with Multiple Observers">
      <artwork align="left">
        <![CDATA[Client A         Proxy          Server
          |               |               |
          |    Request    |    Request    |
          |-------------->|-------------->|--.
          |               |               |  |
          |<--------------|<--------------|<-'
          |  Notification |  Notification |
          |               |               |
          |               |
          Client B           |               |
          |               |               |
          |    Request    |               |
          |-------------->|--.            |
          |               |  | from cache |
          |<--------------|<-'            |
          |  Notification |               |
          |               |               |
          |<--------------|<--------------|
          |  Notification |  Notification |
          |               |               |
          |               |
          Client A           |               |
          |               |               |
          |<--------------|               |
          |  Notification |               |
          |               |               |]]>
      </artwork>
    </figure>
    <t>
      <list style="hanging">
        <t hangText="Example: Observe with caching">
          <vspace blankLines="1"/>
          In <xref target="figure-observe"/>, the server exposes an
          observable resource (e.g., the current
          reading of a temperature sensor).  Multiple clients are
          interested in the current state of the resource and observe
          it using the <xref target="RFC7641">CoAP resource observation
            mechanism</xref>.  The goal is to keep the state observed by
          the clients closely in sync with the actual state of the
          resource at the server.  Another goal is to minimize the
          burden on the server by moving the task to fan out
          notifications to multiple clients from the server to the
          proxy.
        </t>
      </list>
    </t>
    
    
  </section>
  
  
  <!-- *************************************************************** -->
  
  <section anchor="FR2" title="Functional Requirements">
    <t>
      TODO: Complete the functional requirements
    </t>
    
    <t>
      <list style="format FR2.%d">
        <t>
          The proxy MUST be able to store cacheable responses in a
          cache.  Cacheable responses are 2.05 (Content) responses and
          all error responses.
        </t>
        <t>
          This proxy MUST be able to read the CoAP header, options, and
          payload and to compute the cache key for a request.
        </t>
        <t>
          The proxy MUST be able to return a fresh response from
          its cache without contacting the server.
        </t>
        <t>
          The proxy MUST be able to perform validation on a request by
          a client and a request validation to the server (see Section
          5.6.2 of <xref target="RFC7252"/>).
        </t>
        <t>
          The proxy MUST be able to observe a resource on behalf of
          one or more clients.
        </t>
      </list>
    </t>
  </section>
  
  <!-- *************************************************************** -->
  
  <section anchor="PR2" title="Processing Rules">
    <t>
      TODO: Complete the processing rules
    </t>
    
    <t>
      The proxy complies with the forwarding rules PR1.1 - 1.3
      (<xref target="PR1"/>) and the rules below.  The rules below have
      priority.
      <list style="format PR2.%d">
        <t>
          If the proxy receives a request where the cache key matches
          that of a cached fresh response, then the proxy discards the
          request and replies with that response, else it makes a
          translated request.
        </t>
        
        <t>
          The proxy caches and forwards cacheable responses.  If there is
          already a response in the cache with the cache key of the
          corresponding request, then the old response in the cache is
          marked as stale.
        </t>
        
        <t>
          If the proxy receives a request that contains an ETag option
          and the proxy has a fresh response with the same cache key and
          ETag, then the proxy replies to the request with a 2.03 (Valid)
          response without payload, else it forwards a translated request.
        </t>
        
        <t>
          The proxy updates the Max-Age option according to the
          Max-Age associated with the resource representation it receives,
          decreasing its value to reflect the time spent in the
          cache.
        </t>
        
        <t>
          If the request contains an Accept option and if there is a
          fresh response that matches the cache key for the corresponding
          request except for the Accept option, and if the Content-Format
          of the response matches that of the Accept option, then the
          proxy forwards the cached response to the requesting client.
        </t>
      </list>
    </t>
    
  </section>
  
  <!-- *************************************************************** -->
  
  <section anchor="auth-2" title="Authenticity">
    
    <t>
      TODO: Make the analysis and write this section
    </t>
    
    <t>
      This section consider the forwarding only proxy case and defines when
      a message is considered authentic (see
      <xref target="spoofing-client"/> and <xref target="spoofing-server"/>).
    </t>
    <t>
      The request is considered authentic by the server if:
      <list style="format A2.%d" counter="A2_count">
        <t>
          The request originates from the client
        </t>
        <t>
          The CoAP payload of the request has not been altered.
        </t>
        <t>
          The CoAP options of the request have not been altered in any
          other way than defined in <xref target="PR2" />.
        </t>
        <t>
          The effective URI of the request is not changed.
        </t>
        <t>
          The CoAP header fields Version and Code of the request have not
          been altered.
        </t>
        <t>
          The request has not been previously received.
        </t>
        <t>
          The request was recently sent by the client.
        </t>
      </list>
    </t>
    <t>
      <vspace blankLines="1"/>
    </t>
    <t>
      The response is considered authentic by the client if:
      <list style="format A2.%d" counter="A2_count">
        <t>
          The response originates from the server.
        </t>
        <t>
          The CoAP payload, options and header fields Version and Code of
          the response have not been altered.
        </t>
        <t>
          The response has not been previously received.
        </t>
        <t>
          The response was recently sent by the server.
        </t>
        <t>
          The response corresponds to a unique request
          sent by the client.
        </t>
        <t>
          If there are multiple responses, the client should
          be able to verify that
          is the case, as well as the order of the responses.
        </t>
        
      </list>
    </t>
    
  </section>
  
  <!-- *************************************************************** -->
  
  <section anchor="conf-2" title="Confidentiality">
    
    <t>
      TODO: Make the analysis and write this section
    </t>
    
    <t>
      This section defines when a message is considered confidentiality
      protected (see <xref target="eavesdrop"/>).
    </t>
    <t>
      A messages is considered confidentiality protected if:
      <list style="format C2.%d">
        <t>
          The CoAP payload (if present) is confidentiality protected
        </t>
        <t>
          All CoAP options of the request and response, except
          Uri-Host/Port and Proxy-Uri/Scheme, are confidentiality
          protected.
        </t>
        <t>
          The keys used for confidentiality protection provides forward
          security.
        </t>
      </list>
    </t>
    
  </section>
  
  <!-- *************************************************************** -->
  
  
  <section anchor="R2" title="Security Requirements">
    
    <t>
      TODO: Make the analysis and write this section
    </t>
    
    <t>
      This section contains the security requirements for this scenario.
      For each requirement the associated functional requirement,
      processing rule, authenticity property, or confidentiality
      property is listed.  The security requirements are:
      <list style="format R2.%d">
        
        <t>
          The server MUST authenticate a message coming
          from a requesting client (A1.1).
        </t>
        
        <t>
          The CoAP payload MUST be integrity protected and encrypted
          between client and server (A1.2, C1.1).
        </t>
        
        <t>
          The CoAP options except Uri-* and Proxy-* MUST be integrity
          protected in the request.  The effective request URI
          MUST be integrity protected in the request (PR1.1, PR1.2, A1.3,
          A1.4).
        </t>
        
        <t>
          The CoAP header fields Version and Code MUST be integrity
          protected in requests and responses.  All other header fields
          must not be integrity protected.  The header fields MUST not be
          encrypted (A1.5).
        </t>
        
        <t>
          The server MUST verify that it has not received this request
          previously (A1.6).
        </t>
        
        <t>
          The client MUST verify that the received response
          originates from the requested server (A1.8).
        </t>
        
        <t>
          The client MUST be able to verify that multiple response to a
          request are allowed as well as the order of the responses. (A.13)
        </t>
        
        <t>
          All CoAP options in the response MUST be integrity protected.
          Max-Age must be set to 0 (FR1.2, PR1.3).
        </t>
        
        <t>
          The client MUST verify that a response corresponds to
          a unique previous request that the client has made (FR1.1, A1.12).
        </t>
        
        <t>
          The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the
          request MUST not be encrypted.  The Max-Age option of the
          response MUST not be encrypted.  All other options MUST be
          encrypted (C1.2).
        </t>
        
        <t>
          The communication protocol MUST provide forward secrecy (C1.3).
        </t>
        
      </list>
      
    </t>
  </section>
</section>

<section title="Reverse proxy">
  
  <section title="Examples">
    <t>
      TODO
    </t>
  </section>
  
  <section anchor="FR3" title="Functional Requirements">
    <t>
      TODO
    </t>
  </section>
  
  
  <section anchor="PR3" title="Processing Rules">
    <t>
      TODO
    </t>
  </section>
  
  
  <section anchor="auth-3" title="Authenticity">
    <t>
      TODO
    </t>
  </section>
  
  <section anchor="conf-3" title="Confidentiality">
    <t>
      TODO
    </t>
  </section>
  
  <section anchor="R-3" title="Security Requirements">
    <t>
      TODO
    </t>
  </section>
</section>



        <section title="Summary">

<t>
  TODO
</t>
          <figure>
            <artwork>
<![CDATA[ +-------------- One Request - One Response
 |   +---------- One Request - Multiple Responses
 |   |   +------ Multiple Requests - One Response
 |   |   |   +-- Multiple Requests - Multiple Responses
 |   |   |   |
 V   V   V   V]]>
            </artwork>
          </figure>
          <t>
            <list style="hanging" hangIndent="17">
              <t>--- Server ---</t>
              <t hangText="(x) (x) ( ) ( )">The server must authenticate a message coming from a requesting client. (R1.1)</t>
              <t hangText="(x) (x) ( ) ( )">The server must verify that it has not received this request previously. (R1.2)</t>
              <t>--- Client ---</t>
              <t hangText="(x) (x) (x) (x)">The client must verify that the received response originates from the requested server. (R1.3) The client must be able to verify that a received resource representation originates from the requested server. (R3.1)</t>
              <t hangText="(x) ( ) ( ) ( )">The client must verify that a response corresponds uniquely to a previous request that the client has made. (R1.4)</t>
              <t hangText="( ) (x) ( ) ( )">The client must verify that a response corresponds to a previous request that the client has made. (R2.1)</t>
              <t hangText="( ) (x) ( ) ( )">The client must verify that it has not received this response previously and whether responses for the same request are received in the wrong order. (R2.2)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to verify that a received representation is a representation of the resource requested by the client. (R3.2)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to verify the content format of the representation. (R3.3)</t>
              <t hangText="( ) ( ) (x) (x)">The client must be able to detect that a received representation is fresh. (R3.4)</t>
              <t>--- Encrypted and Integrity Protected Parts ---</t>
              <t hangText="(x) (x) (x) (x)">The payload must be integrity protected and encrypted between client and server. (R1.5) The representation must be integrity protected and encrypted from the server to the client. (R3.5)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP options except Uri-* and Proxy-* must be integrity protected in the request.  The effective request URI must be integrity protected in the request. (R1.6)</t>
              <t hangText="(x) (x) ( ) ( )">All CoAP options in the response must be integrity protected. Max-Age must be set to 0. (R1.7)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the request must not be encrypted.  The Max-Age option of the response must not be encrypted.  All other options must be encrypted. (R1.8)</t>
              <t hangText="(x) (x) ( ) ( )">The CoAP header fields Version and Code must be integrity protected in requests and responses.  All other header fields must not be integrity protected. The header fields must not be encrypted. (R1.9)</t>
              <t>--- Miscellaneous ---</t>
              <t hangText="(x) (x) (x) (x)">The communication protocol must provide forward secrecy. (R1.10) (R3.7)</t>
              <t hangText="( ) ( ) (x) (x)">To protect against the proxy colluding with an authorized client, asymmetric cryptography must be used. (R3.6)</t>
            </list>
          </t>
          <t>
            <vspace blankLines="100"/>
          </t>
          
        </section>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Publish-Subscribe">

      <t>
        Applying <xref target="proxying"/> to Publish-Subscribe results
        in <xref target="fig-pubsub-endtoend"/>.
      </t>

      <figure anchor="fig-pubsub-endtoend" title="End-to-End Security">
        <artwork align="left">
<![CDATA[     ___________      _      __________      _      ____________
    |           |    | |    |          |    | |    |            |
    |           |--->| |--->|          |<---| |<---|            |
    | Publisher |    | |    |  Broker  |    | |    | Subscriber |
    |           |<---| |<---|          |--->| |--->|            |
    |___________|    |_|    |__________|    |_|    |____________|
          :         Proxy       :  :       Proxy         :
          :                     :  :                     :
          '---------------------'  '---------------------'
                  Security               Security
                 Association            Association
                      A                      B]]>
        </artwork>
      </figure>

      <t>
        This section is about <xref target="fig-pubsub-ptos"/>.
      </t>

      <figure anchor="fig-pubsub-ptos" title="Publisher-to-Subscriber Security">
        <artwork align="left">
<![CDATA[     ___________      _      __________      _      ____________
    |           |    | |    |          |    | |    |            |
    |           |--->| |--->|          |<---| |<---|            |
    | Publisher |    | |    |  Broker  |    | |    | Subscriber |
    |           |<---| |<---|          |--->| |--->|            |
    |___________|    |_|    |__________|    |_|    |____________|
          :         Proxy                  Proxy         :
          :                                              :
          '----------------------------------------------'
                        Security Association]]>
        </artwork>
      </figure>

      <t>
        (But note that a key aspect of pub-sub is that the subscribers
        do not know the publishers and the publishers do not know the
        subscribers. They only have to know the broker. In
        <xref target="fig-pubsub-ptos"/> all subscribers have to know
        all publishers. That doesn't scale.)
      </t>

      <t>
        <vspace blankLines="100"/>
      </t>

      <!-- **************************************************************** -->

      <section title="Threats and Security Requirements">

        <section title="Publisher">

          <figure anchor="fig-publisher" title="The Publisher End">
            <artwork align="left">
<![CDATA[     ___________             __ _ _
    |           | Request   |
    |           |---------->|
    | Publisher |           |  Broker
    |           |<----------|
    |___________|  Response |__ _ _]]>
            </artwork>
          </figure>

          <t>
            The publisher sends a request to the broker (possibly
            via one or more proxies) and receives a response.
          </t>
          <t>
            From the perspective of the publisher, are there any
            requirements on the response?
          </t>
          <t>
            <vspace blankLines="100"/>
          </t>

        </section>

        <section title="Subscriber">

          <figure anchor="fig-subscriber" title="The Subscriber End">
            <artwork align="left">
<![CDATA[                                 _ _ __             ____________
                                       |   Request |            |
                                       |<----------|            |
                               Broker  |           | Subscriber |
                                       |---------->|            |
                                 _ _ __| Response  |____________|]]>
            </artwork>
          </figure>

          <t>
            The subscriber sends a request to the broker (possibly
            via one or more proxies) and waits for a response.
          </t>
          <t>
            From the perspective of the subscriber, there are three
            possible flows:
            <list style="symbols">
              <t>
                The subscriber receives a response.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The broker duly processed the request and returns
                    a response based on data it obtained from a
                    publisher.
                  </t>
                  <t>
                    The subscriber made a bad request and the broker
                    returns an error response accordingly (e.g., 4.04
                    Not Found).
                  </t>
                  <t>
                    The broker encountered an unexpected condition and
                    returns an error response accordingly (e.g., 5.03
                    Service Unavailable).
                  </t>
                  <t>
                    (Threat 1:) The broker spoofs a response.
                  </t>
                </list>
              </t>
              <t>
                The subscriber does not receive a response.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    The subscriber times out too early.
                  </t>
                  <t>
                    (Threat 2:) The broker withholds the response.
                  </t>
                </list>
              </t>
              <t>
                The subscriber receives too many responses.
                <vspace/>Reasons include:
                <list style="symbols">
                  <t>
                    (Threat 3:) The proxy floods the subscriber with
                    responses.
                  </t>
                </list>
              </t>
            </list>
            This is repeated as often as needed when the subscriber
            observes a topic.
          </t>

          <!--<t>
            <vspace blankLines="100"/>
          </t>-->

          <section title="Threat 1: Spoofing">
            <t>
              With one exception (see below), this threat is REQUIRED
              to be mitigated by the security solution: the subscriber
              MUST verify that the response is an
              <spanx>authentic response</spanx> before processing it.
            </t>
            <t>
              The definition of an "authentic response"
              depends on the scenario
              (<xref target="pubsub-scenarios"/>),
              but usually means that the subscriber can obtain proof
              for some or all of the following things:
              <list style="symbols">
                <t>that the data matches the specifications of the request (such as the topic);</t>
                <t>that the data originates from a publisher that is authorized to publish to the topic;</t>
                <t>that the data has not been altered on the way between publisher and subscriber;</t>
                <t>that the data is fresh (when the data is cacheable);</t>
                <t>that the data is in sequence (when observing a topic).</t>
              </list>
              The proof can, for example, involve a message
              authentication code that the proxy obtains from the origin
              server and includes in the response or an additional
              challenge-response roundtrip.
            </t>
            <t>
              Note that a CoAP server like the broker is specified to
              return an error response (such as 4.04 Not Found or 5.03
              Service Unavailable) when it encounters an error
              condition. Since the condition occurs at the broker and
              not at the publisher, the response will not be an
              "authentic response" according to the above definition.
              Thus a subscriber cannot tell if the broker sends the
              error response according to specification or if it spoofs
              the response. This threat is NOT REQUIRED to be mitigated
              by the security solution.
            </t>
          </section>

          <section title="Threat 2: Withholding">
            <t>
              This threat is NOT REQUIRED to be mitigated by the
              security solution.
            </t>
          </section>

          <section title="Threat 3: Flooding">
            <t>
              A CoAP client like the subscriber is specified to reject
              any response that it does not expect. This can happen
              before the client verifies if the response is authentic.
              Therefore a flood of responses is primarily a threat to
              the system resources of the client, in particular to its
              energy.
              This threat is NOT REQUIRED to be mitigated by the
              security solution in particular, but a subscriber SHOULD
              generally defend against flooding attacks.
            </t>
            <t>
              <vspace blankLines="100"/>
            </t>
          </section>

        </section>

        <section title="Broker">

          <figure anchor="fig-brokerend" title="A Broker">
            <artwork align="left">
<![CDATA[          _ _ __             __________             __ _ _
                | Request   |          |   Request |
                |---------->|          |<----------|
      Publisher |           |  Broker  |           | Subscriber
                |<----------|          |---------->|
          _ _ __|  Response |__________| Response  |__ _ _]]>
            </artwork>
          </figure>

          <t>
            The broker receives a request from a publisher or a
            subscriber (possibly via one or more proxies).
            <list style="symbols">
              <t>
                If the request comes from a publisher, the broker
                stores the data, notifies any subscribers and returns
                a response to the publisher.
              </t>
              <t>
                If the request comes from a subscriber, the broker
                uses the previously stored data to construct a
                response and returns the response to the client.
              </t>
            </list>
            In both cases, the broker needs to read some parts of the
            requests to accomplish its task.
          </t>
          <t>
            There are the following threats:
            <list style="symbols">
              <t>(Threat 4:) The broker reads the data in the request from the publisher or the subscriber.</t>
              <t>(Threat 5:) The broker measures the frequency and distribution of incoming requests.</t>
              <t>(Threat 6:) The broker stores and notifies subscribers of data from an unauthorized publisher.</t>
            </list>
          </t>

          <t>
            <vspace blankLines="100"/>
          </t>

          <section title="Threat 4: Reading">
            <t>
              This threat is REQUIRED to be mitigated by the security
              solution: publishers MUST protect the data in the requests
              they're sending with Authenticated Encryption.
            </t>
            <t>
              Note that this requirement is in conflict with the
              requirement that the broker needs to be able to read some
              parts of the requests in order to accomplish its task.
              Which parts can be encrypted and/or
              integrity-protected depends on the scenario
              (<xref target="pubsub-scenarios"/>).
            </t>
          </section>

          <section title="Threat 5: Measuring">
            <t>
              This threat is NOT REQUIRED to be mitigated by the
              security solution.
            </t>
          </section>

          <section title="Threat 6: Poisoning">
            <t>
              TODO.
            </t>
            <t>
              <vspace blankLines="100"/>
            </t>
          </section>

        </section>

      </section>

      <!-- **************************************************************** -->

      <section title="Scenarios" anchor="pubsub-scenarios">

        <section title="Multiple Requests - Multiple Responses"><t><vspace blankLines="100"/></t></section>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section anchor="sec-cons" title="Security Considerations">

      <t>
        A proxy or intermediary may be an aggregation point for message flows.
        Therefore it is an attractive target, both from a security and privacy
        point of view.
      </t>
      
      <t>
        Unless the security mechanisms provide forward secrecy, a
        compromise of long term keying material means that an attacker can 
        decrypt all previously sent information and can be directly used for
        any kind of manipulation of the cyber-physical system.
      </t>
      
      <t>
        Therefore the key exchange mechanism used for establish keys to use with
        application layer security must provide forward secrecy.
      </t>
      
      <t>
        Intermediary nodes are aggregation points also for metadata and
        therefore valuable targets for signal intelligence agencies.
        Pervasive monitoring is an attack <xref target="RFC7258"/> and the 
        effect of collecting and correlating information from multitude of 
        proxies must be mitigated.
      </t>
      
      <t>
        Related to this, it is needed to delete all historical information
        from all nodes handling the plaintext data and metadata, in order
        to avoid information leakage.  The impact of this on the intermediary
        nodes can be limited by confidentiality protecting as much as
        possible between the endpoints.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    

    <section title="IANA Considerations">

      <t>
        This document includes no request to IANA.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC2119;

      &RFC7252;
      
      &RFC7258;
      
      &RFC7641;

    </references>

    <references title="Informative References">

      &RFC6347;

      &RFC7228;
      
      &I-D.ietf-cose-msg;
      
      &I-D.mattsson-core-coap-actuators;
      
      &I-D.koster-core-coap-pubsub;

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Acknowledgments" numbered="no">

      <!-- sorted by last name -->
      <t>
        Thanks to
        Ari Keranen,
        John Mattsson,
        Jim Schaad, and
        Ludwig Seitz
        for helpful comments and discussions that have shaped the
        document.
      </t>

    </section>
   
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
