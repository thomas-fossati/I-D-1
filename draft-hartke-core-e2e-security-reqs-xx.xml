<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
  <!ENTITY RFC4949 SYSTEM "reference.RFC.4949.xml">
  <!ENTITY RFC6347 SYSTEM "reference.RFC.6347.xml">
  <!ENTITY RFC7228 SYSTEM "reference.RFC.7228.xml">
  <!ENTITY RFC7252 SYSTEM "reference.RFC.7252.xml">
  <!ENTITY RFC7258 SYSTEM "reference.RFC.7258.xml">
  <!ENTITY RFC7641 SYSTEM "reference.RFC.7641.xml">
  <!ENTITY I-D.ietf-cose-msg SYSTEM "reference.I-D.ietf-cose-msg.xml">
  <!ENTITY I-D.mattsson-core-coap-actuators SYSTEM "reference.I-D.mattsson-core-coap-actuators.xml">
  <!ENTITY I-D.koster-core-coapmq SYSTEM "reference.I-D.koster-core-coapmq.xml">
  <!ENTITY I-D.tcs-coap-no-response-option SYSTEM "reference.I-D.tcs-coap-no-response-option.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>

<rfc category="info" docName="draft-hartke-core-e2e-security-reqs-00" ipr="trust200902">
    
    <front>

    <title>Requirements for CoAP End-To-End Security</title>
   
    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63905</phone>
        <email>hartke@tzi.org</email>
      </address>
    </author>

    <author initials="G." surname="Selander" fullname="Goeran Selander">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>goran.selander@ericsson.com</email>
      </address>
    </author>
    
    <author initials="F." surname="Palombini" fullname="Francesca Palombini">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>francesca.palombini@ericsson.com</email>
      </address>
    </author>
    
    <author initials="L." surname="Seitz" fullname="Ludwig Seitz">
      <organization>SICS Swedish ICT AB</organization>
      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <city>Lund</city>
          <code>223 70</code>
          <country>Sweden</country>
        </postal>
        <email>ludwig@sics.se</email>
      </address>
    </author>
    
    <date />


    <area>Applications</area>

    <workgroup>CoRE Working Group</workgroup>

    <abstract>

      <t>
        This document analyses threats to CoAP message 
        exchanges traversing proxies and derives the security requirements
	mitigating those threats.
      </t>

    </abstract>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction">

      <t>
        The <xref target="RFC7252">Constrained Application Protocol
        (CoAP)</xref> is a Web application protocol designed for
        <xref target="RFC7228">constrained nodes and networks</xref>.
        CoAP uses <xref target="RFC6347">Datagram Transport Layer
        Security (DTLS)</xref> for security.  At the same time, CoAP
        relies on proxies, to improve scalability and
        efficiency.  These proxies are specified to perform a
        number of operations on CoAP messages, which requires
        DTLS to be terminated at the proxy.  The proxy therefore
        not only has access to the data required for performing the
        intended proxy functionality, but is also able to eavesdrop on,
        or manipulate any part of the CoAP payload and metadata, in
        transit between client and server, or inject new CoAP messages,
        without being protected or
        detected by DTLS.
      </t>

      <t>
        One way to mitigate this threat is to secure CoAP communication
        at the application layer, using an object-based security
        mechanism (such as <xref target="I-D.ietf-cose-msg">CBOR
        Encoded Message Syntax</xref>) instead of, or in addition to,
        the security mechanisms at the network layer or transport
        layer.
      </t>

      <t>
        This document analyses security requirements for CoAP requests and
        responses of sensor and actuator deployments, involving proxies and
	other similar intermediaries.  The analysis is based on identifying
	the assets associated to sensor- and actuator-based communication
	patterns, and considering the potential threats executed through
	proxies to these assets.  The threat analysis provides the basis for
	defining the security requirements, that an application layer security
	mechanism for CoAP needs to meet.
      </t>

      <section title="Terminology">

        <!--
        <t>
          This document makes use of the terminology defined in
          <xref target="RFC4949"/>.
        </t>
        -->

        <t>
          Readers are expected to be familiar with the terms and
          concepts described in <xref target="RFC7252"/>.
        </t>

        <!--
        <t>
          Additionally, the following terms are used in this document:
          <list style="hanging">
            <t hangText="...:">...</t>
          </list>
        </t>
        -->

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119"/>.
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Scope and Assumptions">

      <t>
        This document presents a number of scenarios involving sensor
        and actuator communications over CoAP.  Common to all scenarios is the
        presence of at least one intermediary device, typically between
        a client requesting a resource and a server hosting a resource
        (<xref target="figure-0"/>).
      </t>

      <t>Note: We mainly consider proxies and therefore use the term "proxy" and
      its communication setup as a generic model.</t>

      <t>The proxy is responsible, for example, for reducing response time and
      network bandwidth use by serving responses from a cache or for enabling 
      the client to make requests that it otherwise could not make, for example
      because of lack of privileges or reachability.
      </t>

      <figure anchor="figure-0" title="CoAP Exchanges Through A Proxy">
        <artwork align="center">
<![CDATA[ 
 __________   Request    _________              __________
|          | ---------> |         |  Request   |          |
|          |            |         | ---------> |          |
|  Client  |            |  Proxy  |            |  Server  |
|          |            |         | <--------- |          |
|__________| <--------- |_________|  Response  |__________|
               Response]]>
        </artwork>
      </figure>
      
      <t>
        A proxy may perform different functions, but the basic function
        is to forward translated messages, according to certain processing rules.
	For example:
        
        <list style="format Rule %d:">
          <t>
            Forward a message to the next proxy when the link is up
          </t>
          <t>
            Only forward a request if there is no fresh cached response
          </t>
          <t>
            Forward a new publication to all subscribing clients
          </t>
        </list>
      </t>
 
      <t>
        In order to perform its function, a proxy may be required to read or
        change certain parts of a CoAP message, as defined by the processing 
	rules.  For example, a forward proxy is defined to transform
        the Proxy-Uri option to Uri-Host, Uri-Port, Uri-Path and Uri-Query
        options.  A proxy, caching responses, needs to read the Cache Key, and may
	change the Max-Age option in the responses.
      </t>
      
      <t>
        Since a proxy might not be fully trusted, a security solution is needed
        that protects the client, the server, and the message exchanges against
        certain threats, while still allowing the proxy to assume its normal
        functionality. The client and server are assumed to have a security
        association, but the proxy is neither assumed to have a security 
	association with the client, nor with the server.  
	<xref target="fig:fwProxy"/> and
	<xref target="fig:brokerProxy"/> illustrate this assumption.
      </t>
      
      <t>
        The following types of intermediary nodes
        are considered: Forward proxy (see <xref target="RFC7252"/>)
        and publish-subscribe broker (see
        <xref target="I-D.koster-core-coapmq"/>).  The precise functionality 
	assumed by the intermediary nodes is defined by processing rules in the 
	respective scenario analyzed in this document (<xref
	target="analysis"/>).
      </t>
      
      <t>
        
      <figure anchor="fig:fwProxy" 
	      title="Security association between client and server">
        <artwork align="center">
<![CDATA[ 
    +----------+   +-----------+                  +----------+
    |          |   |           |                  |          |
    |  Client  |___|  Forward  |__________________|  Origin  |
    |          |   |   Proxy   |                  |  Server  |
    |          |   |           |                  |          |
    +----------+   +-----------+                  +----------+
         |                                              |
         |______________________________________________|
                     Security Association]]>
        </artwork>
      </figure>
    
      <figure anchor="fig:brokerProxy" 
	      title="Security association between publisher and subscriber">
        <artwork align="center">
<![CDATA[ 
    +-----------+          +----------+           +-----------+
    |           |          |          |           |           |
    | Subscriber|__________|  Broker  |___________| Publisher |
    |           |          |          |           |           |
    |           |          |          |           |           |
    +-----------+          +----------+           +-----------+
          |                                             |
          |_____________________________________________|
                      Security Association]]>
        </artwork>
      </figure>
   
        TODO: Reverse proxy and translational proxy is planned to be added in a
        future version of this draft.
      </t>
      
      <t>
        To identify the threats in scope, we first consider what assets need to
        be protected.  In general, there are the following types of assets to
        protect:
        <list style="format A%d:" counter="my_count">
          <t>
            The devices at the two ends, the data generated and stored in
            these devices, and their (often very
            constrained) system resources such as available memory, storage,
            processing capacity, and energy.
          </t>
          <t>
            The physical environment of the devices fitted with sensors
            and actuators.  Access to the physical environment is
            provided through CoAP resources that allow a remote entity
            to retrieve information about the physical environment
            (such as the current temperature) or to produce an effect
            on the physical environment (such as the activation of a
            heater).
          </t>
          <t>
            The communication infrastructure linking the two devices
            (which often contains some very constrained parts), and the data
	    stored in the message processing devices.
          </t>
        </list>
      </t>
      
      <t>
        The scope of this document is to analyze threats executed through
        intermediary nodes, and this is only directly affecting the assets of
	type A3, e.g. if a proxy is dropping all messages.
      </t>
      
      <t>
        However, the intermediary node may manipulate the messages exchanged
        between the endpoints and thereby have an impact also on the assets A1 
	and A2, for example: flooding a device with messages has impact on its 
	system resources, and successful manipulation of an actuator command, 
	carried in a message, has an impact on the physical environment.  We 
	therefore add a fourth asset, which is the main target being evaluated
	in this document:
      </t>
      
      <t>
        <list style="format A%d:" counter="my_count">
          <t>
            The messages exchanged between a client and a server, through the
            proxy.  This includes the CoAP header and options in
            request and response messages (such as the requested method
            or the target URI) and the CoAP resource representations,
            encapsulated in the message payload.
          </t>
        </list>
      </t>
      
      <t>
        A fully trusted proxy, handling unprotected messages, is an attractive 
	target, since proxies are aggregation points for message flows (see 
	<xref target="sec-cons"/>) and they may be an easier target from the 
	Internet than the sensors/actuators residing behind them.  A proxy may 
	become subject to intrusion, or become infected by malware, and perform 
	the attacks of a man-in-the-middle.  The attack vectors for 
	compromising a proxy, and the associated risks, are out of scope for this
	document.
      </t>
      
      <t>
        The scope of the threat analysis is
        restricted to threats from proxies to single client to server
	interactions.  Threats resulting from collusion between multiple
	proxies are also out of scope (see <xref target="sec-cons"/>).
      </t>
      
      <t>
        On a high level, there are the following threats from proxies
        to consider:
        <list style="format T%d:">
          <t>
            The proxy illegitimately modifies a message.
          </t>
          <t>
            The proxy illegitimately sends a message,
            including replay, flooding, etc.
          </t>
          <t>
            The proxy illegitimately inhibits sending of a message,
            including delay, reordering, etc.
          </t>
          <t>
            The proxy illegitimately reads part of a message.
          </t>
        </list>
      </t>
      
      <t>
        To assess how such threats impact the assets, we need to specify
        the processing rules of the intermediary nodes in different scenarios
        and define the associated security objectives.
      </t>
      
      
     
    </section>
    
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    
    <section anchor="analysis" 
	     title="Scenarios, Threats and Security Requirements">
      
      <t>
        In this section we consider a set of scenarios involving proxies and 
	brokers, with different processing rules and security objectives.  We 
	study the associated threats, and derive the security requirements for 
	message transfer between client and server, in the different scenarios.
        Note that, since CoAP was not designed for end-to-end security,
        solutions complying with these security requirements extend the 
	applicability of CoAP beyond its original scope.
      </t>
      
      <t>
        To simplify the analysis, the scenarios are structured according to how
        requests and responses are related to each other:
        <list style="hanging">
          <t hangText="One Request - One Response">
            <vspace />
            There is a one-to-one relation between request and response.
          </t>
          <t hangText="One Request - Multiple Responses">
            <vspace />
            A request may have multiple responses, but each response is securely
            linked to a unique request.
          </t>
          <t hangText="Multiple Requests - One Response">
            <vspace />
            One response may serve multiple requests, but each request has a 
	    single response.
          </t>
          <t hangText="Multiple Requests - Multiple Responses">
            <vspace />
            One response may serve multiple requests, and each request may have
            multiple responses.
          </t>
        </list>
      
      </t>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
      
      <section anchor="onereq-oneres" title="One Request - One Response">
        
        <t>
          In this scenario we study use cases, where it is important that a 
	  response sent from one endpoint is the response to a particular
	  request to that endpoint.  Many security critical use cases require
          that responses are in this way "securely linked" to requests, such as
	  alarm status retrieval and actuator command confirmation.
        </t>
        <t>
          In this scenario there must be a unique response for each request.
        </t>
        
        
        <figure anchor="figure-1" title="Message flow with unique responses
					 for each request.">
          <artwork align="center">
<![CDATA[Client          Proxy          Server
  |               |               |
  |    Request    |    Request    |
  |-------------->|-------------->|--.
  |               |               |  |
  |<--------------|<--------------|<-'
  |    Response   |    Response   |
  |               |               |]]>
          </artwork>
        </figure>
        
        
        <t>
          <list style="hanging">
            <t hangText="Example: Alarm status retrieval">
            <vspace blankLines="1"/>
              <xref target="figure-1"/> can be seen as an illustration of a 
	      message exchange for a client, requesting the alarm status, e.g.
	      GET /alarm_status, at a server.  Since the client wants to ensure
	      that the alarm status received is reflecting the current alarm
	      status, and not a cached or spoofed response to the same
	      resource, it must be able to verify that the received response is
	      a response to this particular request made by the client.
	      Therefore the response must be securely linked to the request.
            </t>
            <t hangText="Example: Actuation confirmation">
            <vspace blankLines="1"/>
              Another example, for which <xref target="figure-1"/> serves as
	      illustration, is the confirmation of an actuator request.  In this 
	      case a client, say in an industrial control system, requests a 
	      server that a valve should be turned to a certain level, e.g. PUT
	      /valve_42/level with payload "3".  In order for the client to 
	      correctly evaluate the result of a potential changed valve level,
              it is important that the client gets a confirmation how the 
	      server responded to the requested change, e.g. whether the request
              was performed or not.  Again, the client wants to ensure that the 
	      response is reflecting the result of this particular actuation 
	      request made by the client, and not a cached or spoofed response.
	      Therefore the response must be securely linked to the request.
            </t>
          </list>
        </t>
        
        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              Since each response is intended to be securely linked to a 
	      particular request, the response should not be used with any 
	      other request.  Hence, as much as possible of the caching 
	      functionality must be inhibited.  Therefore the CoAP option 
	      Max-Age of the responses is set to 0 (see Section 5.7.1 of 
	      <xref target="RFC7252"/>).
            </t>
          </list>
        </t>
        

        <!-- *************************************************************** -->
        
        <section anchor="PR1" title="Processing Rules">
          <t>
            In this scenario, the assumed proxy functionality is essentially
            to forward a translated request to the determined destination.
            There are two modes of operation for requests:
            Either (PR1.1) using the Proxy-Uri option, or (PR1.2) using the
            Proxy-Scheme option together with the Uri-Host, Uri-Port,
            Uri-Path and Uri-Query options.
            <list style="format PR1.%d">
              <t>
                The Proxy-Uri option contains the request URI
                including request scheme (e.g. "coaps://"); the
                Proxy-Scheme and Uri-* options are not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another proxy, then it keeps the Proxy-Uri
                option; otherwise it splits the option into its
                components, adds the corresponding Uri-* options and
                does not include a Proxy-Uri option.
                Then it makes the request, using the request scheme
                indicated in the Proxy-Uri.
              </t>
              <t>
                The Proxy-Scheme option
                and the Uri-* options together contain the request URI;
                the Proxy-Uri option is not present.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests to
                another forwarding proxy, then it keeps the
                Proxy-Scheme and Uri-* options; otherwise it removes
                the Proxy-Scheme option.  Then it makes the request,
                using the request scheme indicated in the removed
                Proxy-Scheme option.
              </t>
              <t>
               Responses are forwarded by the proxy, without any modification.
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="SO1" title="Security Objectives">
          <t>
            In this scenario there is a unique response for each request, so the
            client should be able to verify that a certain response is made in
            response to a specific request sent by the client.
          </t>
          <t>
            The server should be able to verify that the proxy only has
            performed the message modifications intended
            by the client, according to the processing rules.
          </t>
          <t>
            The proxy should be prevented from reading, or making modifications
            to messages, apart from what is necessary to perform the processing 
	    rules (cf. <xref target="RFC7258"/>).
          </t>
          <t>
            The security objectives are:
            <list style="format SO1.%d">
              <t>
                The server is able to verify that a received request originates
                from a client with which it has a security association, and that
                the request has not been received before.
              </t>
              <t>
                The server is able to verify, that the received request either
                has not been altered in transfer, or that the request is 
		modified according to the processing rule PR1.1 or PR1.2 (
		<xref target="PR1"/>).
              </t>
              <t>
                The server is able to protect the response, such that only
                authorized clients can read the response.
              </t>
              <t>
                The client is able to verify that the received response
                originates from the requested server and resource,
                that it has not been altered in transfer, and that it was
                generated as the unique response to the request.
              </t>
              <t>
                The proxy is only able to read data needed to perform
                the processing rules.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now list potential threats, and discuss candidate mitigation 
	    mechanisms.
          </t>
          
          <section anchor="T1:1" 
		   title="T1:The proxy illegitimately modifies a message">
            <t>
              <list style="format T1:1.%d">
                <t>
                  The proxy forwards a request with modified payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The proxy forwards a response with modified payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The proxy forwards a request with modified CoAP option
                  <vspace blankLines="1"/>
                  Note that the proxy is entitled to change certain options by
		  processing rules PR1.1 and PR1.2.  Since the change is
		  predictable, the request URI and Proxy-Scheme can be
		  integrity protected by the client, and verified by the server.
                  The other CoAP options in the request can be integrity
		  protected.
                </t>

                <t>
                  The proxy forwards a response with modified CoAP option
                  <vspace blankLines="1"/>
                  This threat can be mitigated with integrity protection of
                  CoAP options. Since Max-Age is set to 0 the proxy is not 
		  entitled to change any options in the response, so they can 
		  all be integrity protected.
                </t>
                
                <t>
                  The proxy forwards a request with changed CoAP header fields
                  <vspace blankLines="1"/>
                  The proxy is entitled to change certain header fields, e.g. 
		  Token, as part of its normal operations.  Malicious changes to
		  message layer parameters may cause denial-of-service,
		  equivalent of dropping a message, or sending spoofed messages.
		  This is difficult to mitigate.  However, changing the CoAP
		  header Code, e.g. from GET to DELETE may result in an error,
		  or wrong interpretation of the request, which can have other
		  security implications.  A change to the header field Version
		  may result in security errors in the interaction between
		  different versions of CoAP.  These threats can be mitigated
		  by integrity protecting the Code and Version header fields.
                </t>
                
                <t>
                  The proxy forwards a response with changed CoAP header fields
                  <vspace blankLines="1"/>
                  Similar to previous threat. Some aspects of this threat can 
		  be mitigated by integrity protecting the Code and Version 
		  header fields.
                </t>
                
                <t>
                  The proxy forwards a different request
                  <vspace blankLines="1"/>
                  If the forwarded request is from another client, it can be 
		  mitigated by having different security associations with 
		  different clients.  If the forwarded request is from the same
		  client, but with differences in payload, options, or header, 
		  then this coincides with previously listed threats.  A proxy 
		  sending old requests, or reordering requests, from the same 
		  client, to the same server resource can be mitigated by
		  integrity protecting a freshness parameter (timestamp, 
		  counter, etc.) from which the order of requests can be 
		  deduced (replay/reordering protection).
                </t>
                
                <t>
                  The proxy forwards a different response 
                  <vspace blankLines="1"/>
                  By integrity protecting uniquely identifying information of 
		  the request in the response, the client can verify if the
		  response was generated to answer a particular request.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section anchor="T2:1" 
		   title="T2:The proxy illegitimately sends a message">
            <t>
              <list style="format T2:1.%d">
                
                <t>
                  The proxy sends a request to the server, without a previous
                  request from the client
                  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity- and replay
                  protection.
                </t>
                
                <t>
                  The proxy sends a response to the client, without a previous
                  response from the server
                  <vspace blankLines="1"/>
                  Error messages from the proxy, such as 5.02 (Bad Gateway),
		  originate from the proxy.  A proxy maliciously sending error
		  messages is a denial-of-service attack, similar to not
		  forwarding a message (T3:1.1), and is difficult to mitigate.
		  However, responses claiming to be from the server may be
		  mitigated with integrity protection, uniquely identifying
		  information of the request.
                </t>
                
                <t>
                  A proxy sends a number of messages for the purpose of flooding
                  client or server
                  <vspace blankLines="1"/>
                  By verifying the integrity, the client and server may
                  mitigate certain flooding attacks.  The server can use the 
		  replay/reordering protection to verify which messages are 
		  legitimate, and the client can verify if a message is a 
		  response to a previously sent request.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:1" 
            title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:1.%d">
                <t>
                  The proxy does not forward a message
                  <vspace blankLines="1"/>
                  This is a denial-of-service attack. While these kind of 
		  threats may be difficult to mitigate, applications should 
		  have a readiness for this kind of issues, and a client
                  is able to detect a missing response.
                </t>
                
                <t>
                  The proxy delays forwarding of a received message
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so they
                  may be difficult to detect and mitigate.
                  However, delayed requests, and responses can also be used in
                  attacks against actuators, see 
		  <xref target="I-D.mattsson-core-coap-actuators"/>.  These 
		  attacks can be performed by an on-path attacker, and are not 
		  restricted to proxies. The proposed mitigation is based on
		  verifying the timeliness of the request, for example by using 
		  time stamps, or with an additional round-trip. These 
		  mitigations can be supported by a new CoAP option, containing 
		  time stamp or binding the response in a first round-trip to a
		  request of the second, as specified in 
		  <xref target="I-D.mattsson-core-coap-actuators"/>.
                  By integrity protecting that new CoAP option, the threat can 
		  be mitigated.
                </t>
                
                <t>
                  The proxy reorders the requests
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting a freshness parameter, from which the
                  order of requests can be deduced.
                </t>
                
                <t>
                  The proxy reorders the responses
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting information, specifying to which request a
		  response belongs.
                </t> 
              </list>
            </t>
          </section>
          
          <section anchor="T4:1" 
		   title="T4:The proxy illegitimately reads part of a message">
            <t>
              <list style="format T4:1.%d">
                <t>
                  The proxy reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the payload.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP options.
                  <vspace blankLines="1"/>
                  The proxy only needs to read the Uri-Host/Uri-Port and
                  Proxy-Uri/Proxy-Scheme options of a request.  The information
		  revealed by these parameters is public on network layer.
                  The proxy only needs to read Max-Age of the response, which is
                  set to 0 as indicated in the functional requirements.
                  This threat can be mitigated by encrypting all other options.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP header fields.
                  <vspace blankLines="1"/>
                  The header fields needs to be transferred in plain text, to 
		  allow normal CoAP operations.  The Code parameter reveals 
		  information about what RESTful action is requested.  This 
		  information leakage is difficult to mitigate.
                </t>
                
                <t>
                  The proxy stores all message exchanges and can, if long
                  term keying material is compromised, read the whole history
                  of the corresponding interactions.
                  <vspace blankLines="1"/>
                  To mitigate this requires a key exchange mechanism, providing
		  forward secrecy (PFS), for establishing the keys to use with
		  application layer security.
                </t>

              </list>
            </t>
          </section>

        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="R1" title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for this scenario.  For each requirement and non-requirement, the
            associated threats are listed.  The security requirements are:
            <list style="format R1.%d">
              
              <t>
                The server must authenticate a message coming
                from a requesting client (T1:1.1, T1:1.3, T1:1.5, T2:1.1)
              </t>
              
              <t>
                The server must verify that it has not received this request
                previously (T1:1.7, T3:1.3)
              </t>
              
              <t>
                The client must verify that the received response
                originates from the requested server (T1:1.2, T1:1.4, T1:1.6, 
		T2:1.2)
              </t>
              
              <t>
                The client must verify that a response corresponds uniquely to
                a previous request, that the client has made (T1:1.8, T3:1.4)
              </t>
              
              <t>
                The payload must be integrity protected and encrypted,
                between client and server (T1:1.1-6,T4:1.1, T2:1.3, T4:1.1, 
		<xref target="RFC7258"/>)
              </t>
              
              <t>
                The CoAP options except Uri-* and Proxy-* must be integrity
                protected in the request.  The request URI and proxy scheme 
		must be integrity protected in the request. (T1:1.3)
              </t>
              
              <t>
                All CoAP options in the response must be integrity protected.
                Max-Age must be set to 0 (T1:1.4)
              </t>
              
              <t>
                The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the 
		request must not be encrypted.  The Max-Age option of the 
		response must not be encrypted.  All other options must be
		encrypted. (T4:1.2)
              </t>
              
              
              <t>
                The CoAP header fields Version and Code must be integrity 
		protected in requests and responses.  All other header fields 
		must not be integrity protected.  The header fields must not be
		encrypted. (T1:1.5, T4:1.3)
              </t>
              
              
            </list>
            
            The security non-requirements of this scenario are:
            
            <list style="format NR1.%d">
              <t>
                The proxy may drop messages without the endpoint being able to
                infer that the message is lost due to the proxy. (T3:1.1)
              </t>
              
              <t>
                The proxy may delay messages without being detected. 
		(T3:1.1, T3:1.2)
              </t>
              
              <t>
                The proxy may read the CoAP header including message layer
                parameters and Code, revealing the kind of RESTful action being
                requested and the response code (T4:1.3)
              </t>
            </list>
            
          </t>
        </section>
        
        
      </section>
      
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      <section anchor="onereq-mulres" title="One Request - Multiple Responses">
        
        <t>
          In this scenario we study use cases, where it is important that a 
	  response is securely linked to a request, like in the previous
	  scenario, but where there may be multiple responses for each request.
	  This functionality protects communication-constrained servers from
	  repeated requests from the same client, and thus saves system
	  resources and bandwidth.  This is useful in security critical
	  monitoring scenarios, where time synchronization cannot be
	  guaranteed.
        </t>
        
        <figure anchor="figure-2" title="Message flow of a notification.">
          <artwork align="center">
<![CDATA[Client          Proxy          Server
  |               |               |
  |    Request    |    Request    |
  |-------------->|-------------->|--.
  |               |               |  |
  |<--------------|<--------------|<-'
  |    Notify     |    Notify     |  |
  |               |               |  |
  |<--------------|<--------------|<-'
  |    Notify     |    Notify     |  |
  |               |               |  |
  |<--------------|<--------------|<-'
  |    Notify     |    Notify     |
  |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          
          
          <list style="hanging">
            <t hangText="Example: Secure parameter monitoring">
              <vspace blankLines="1"/>
              <xref target="figure-2"/> can be seen as an illustration of a
	      message exchange for a client monitoring an important parameter,
	      e.g. in a medical or process industry application, measured by the
	      server.  The client makes a subscription request for a resource, 
	      and the server responds with notifications, thereby providing
	      updates to the parameter, in regular time intervals.
            </t>
            <t>
              The client wants to ensure that first received notification 
	      reflects the current parameter value, and that subsequent 
	      notifications are timely updates of the initial request.  Since 
	      notifications may be lost, or reordered, the client needs to be 
	      able to verify the order of the messages, as sent by the server.
	      By monitoring the received messages and the time they are
	      received, the client can detect missing notifications and take
	      appropriate action.
            </t>
          </list>
        </t>
        
        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              The same functional requirement apply as in the previous scenario
              (<xref target="onereq-oneres"/>).
            </t>
          </list>
        </t>
        
        
        <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          
          <t>
            The processing rules are identical to PR 1.1 - 1.3 of the previous
            scenario (<xref target="PR1"/>).
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          <t>
            The security
            objectives are similar to the previous scenario.  Each response
            maps to a unique request, but there may be multiple responses to
	    one request.  By ordering the responses, each message in this 
	    exchange can be made unique.
          </t>
          <t>
            The security objectives of the previous scenario (
	    <xref target="SO1"/>) are valid, except SO1.4, which is replaced by 
	    the following:
           <list style="format SO2.%d">
              <t>
                The client is able to verify, that the received response
                originates from the requested server and resource,
                that it has not been altered in transfer, and that it was
                generated as one, in a sequence of responses to the request.
              </t>
              <t>
                The client is able to verify the order of the responses, and if
                a response is missing.
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            The threat analysis from the previous scenario carries over,
            with a few exceptions.
          </t>
          
          <section anchor="T1:2" 
		   title="T1:The proxy illegitimately modifies a message">
            <t>
              Similar conclusions apply as in the previous scenario 
	      (<xref target="T1:1"/>).  However, note that in T1:1.8, a proxy 
	      may maliciously reorder the responses to the same request without
	      being detected.  The mitigation specified in the previous
	      scenario, that the client verifies the response is linked to the
	      request, is not sufficient, since there may be multiple responses.
            </t>
            <t>
              However, analogous to how requests are protected against
              replay/reordering in the previous scenario, by additionally
              integrity protecting a parameter, from which the
              order of responses can be deduced, this threat can be mitigated.
            </t>
          </section>
          
          
          <section title="T2:The proxy illegitimately sends a message">
            <t>
              Similar conclusions apply as in the previous scenario 
	      (<xref target="T2:1"/>).  T2:1.3 can be mitigated with the
              additional replay/reordering protection of responses as mentioned
              in <xref target="T1:2"/>.
           </t>
          </section>
          
          <section 
	      title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              Similar conclusions apply as in the previous scenario 
	      (<xref target="T3:1"/>).  T3:1.4 can be mitigated with the
              additional replay/reordering protection of responses as mentioned
              in <xref target="T1:2"/>.
            </t>
          </section>
          
          <section title="T4:The proxy illegitimately reads part of a message">
            <t>
              The same conclusions apply as in the previous scenario 
	      (<xref target="T4:1"/>).
            </t>
          </section>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            The security requirements of the previous scenario
            (<xref target="R1"/>) are valid, except R1.4 which is replaced by 
	    the following:
          </t>
          
          
          <t>
            <list style="format R2.%d">
              
              <t>
                The client must verify that a response corresponds to a
                previous request that the client has made (T1:1.8, T3:1.4)
              </t>
              
              <t>
                The client must verify that it has not received this response
                previously, and whether responses for the same request are received
                in the wrong order (T1:1.8, T3:1.3)
              </t>
              
            </list>
          </t>
          
        </section>
        
      </section>
      
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
    
      <section anchor="mulreq-oneres" title="Multiple Requests - One Response">
        
        <t>
          In this scenario we study caching, how a proxy may serve the same
          cached response to multiple clients, requesting the same resource.
        </t>
        <t>
          The caching functionality protects communication-constrained servers
          from repeated requests for the same resources, possibly originating
	  from different clients. This saves system resources, bandwidth, and
	  round-trip time.
        </t>
        
        <figure anchor="figure-3" title="Message flow for cached responses.">
          <artwork align="center">
<![CDATA[
Client A         Proxy           Server
   |               |               |
   |    Request    |    Request    |
   |-------------->|-------------->|--.
   |               |               |  |
   |<--------------|<--------------|<-'
   |    Response   |    Response   |
   |               |               |
                   |               |
Client B           |               |
   |               |               |
   |    Request    |               |
   |-------------->|--.            |
   |               |  | from cache |
   |<--------------|<-'            |
   |    Response   |               |
   |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          In <xref target="figure-3"/>, Client A requests the proxy to make a 
	  certain request to the server, and to return the server's response.
	  The proxy services the request by making a request message to the
          server, according to the processing rules.  If the server returns a
          cacheable response, then the proxy stores the response in its cache, 
	  performs any necessary translations, and forwards it to the client.
	  Later, client B makes an equivalent request to the proxy, that the
	  proxy services by returning the response from its cache.
        </t>
        <t>
          Cacheable responses are 2.05 (Content) responses, and error
          responses.
        </t>
        <t>
          Functional Requirements:
          <list style="symbols">
            <t>
              The proxy must be able to store cacheable responses in a
              cache.  This requires the proxy to read CoAP header, options, and
	      payload, and to compute the cache key for a request.
            </t>
            <t>
              The proxy must be able to return a fresh response from
              its cache, without contacting the server.
            </t>
            <t>
              The proxy must be able to perform validation on a request by
              a client and a request validation to the server (see 5.6.2. of
              <xref target="RFC7252"/>).
            </t>
          </list>
        </t>
        
        <!-- *************************************************************** -->
        
        <section anchor="PR3" title="Processing Rules">
          
          <t>
            The proxy complies with the forwarding rules PR1.1 - 1.3 
	    (<xref target="PR1"/>), and the rules below.  The rules below have 
	    priority.
            <list style="format PR3.%d">
              <t>
                If the proxy receives a request, where the cache key matches 
		that of a cached fresh response, then the proxy discards the 
		request, and replies with that response, else it makes a 
		translated request.
              </t>
              
              <t>
                The proxy caches and forwards cacheable responses.  If there is
                already a response, cached with the cache key of the 
		corresponding request, then the old response in the cache is
		marked as stale.
              </t>
              
              <t>
                If the proxy receives a request, that contains an ETag option,
                and the proxy has a fresh response with the same cache key and
		ETag, then the proxy replies to the request with a 2.03 (Valid)
		response without payload, else it forwards a translated request.
              </t>
              
              <t>
                The proxy updates the Max-Age option, according to value of
                Max-Age associated to resource representation it receives,
                and decreasing its value, to reflect the time spent in the
		cache.
              </t>
              
              <t>
                If the request contains an Accept option, and if there is a 
		fresh response that matches the cache key for the corresponding
		request except for the Accept option, and if the Content-Format
                of the response matches that of the Accept option, then the 
		proxy forwards the cached response to the requesting client.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">

          <t>
            A caching proxy has an active role in the resource request/response
            procedure, so it is not surprising, that it is necessary to make a
            trade-off between caching functionality, and the protection of
            client-server interaction.  Comparing with the scenario in
            <xref target="onereq-oneres"/>, most of the security objectives in
            <xref target="SO1"/> cannot be met:
            <list style="symbols">
              <t>
                The caching functionality decouples responses from requests.
                This implies, that a client is not able to verify that a received
                response is generated by the server in response to a specific
                request.
              </t>
              <t>
                A client may receive a response, without the server being aware
                that the client has made a request.  A proxy could proactively
		generate requests, or observe resources, in order to keep the
		cache up-to-date.  Thus the server cannot, in general, verify
		that a request originates from a client, as a precondition
		to provide a response.
              </t>
            </list>
          </t>
          <t>
            Since a proxy can autonomously make requests for (validity of) resource
            representations, and there is no security association between proxy and
            server, the server cannot verify those requests. If a request needs
            to be verified then the solution to the scenario in <xref
	    target="onereq-oneres"/> can be re-used. Therefore we do not
	    consider the protection of requests, and focus here on enabling the
	    caching functionality, and providing security to cacheable resource
	    representations.
          </t>
          
          <t>
            The security objectives for this scenario are:
            <list style="format SO3.%d">
              <t>
                The client is able to verify that a received response contains a
                resource representation to a requested server and resource, and
                that it has not been altered between server and client.
              </t>
              <t>
                The client is able to verify that a received resource
                representation is fresh.
              </t>
              
              <t>
                The server is able to protect a resource representation, such
                that only authorized clients can read the representation.
              </t>
            </list>
          </t>
          
        </section>
    
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now list potential threats, and discuss candidate mitigation 
	    mechanisms.
          </t>
          
          <section anchor="T1:3" 
		   title="T1:The proxy illegitimately modifies a message">
            <t>
              <list style="format T1:3.%d">
                <t>
                  The proxy forwards a request with modified payload
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy forwards a response with modified payload
                  <vspace blankLines="1"/>
                  This threat that may be mitigated with integrity protection of
                  resource representation.
                </t>
                
                <t>
                  The proxy forwards a request with modified CoAP options
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy forwards a response with modified CoAP options
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  For example, a proxy is
                  entitled to change Max-Age.  However, changing Content-Format
                  may result in an error, or the wrong interpretation of a
                  representation.  That kind of threat may be mitigated by
                  securely associating resource information, such as 
		  Content-Format, to the representation in the response.
                </t>
                
                <t>
                  The proxy forwards a request with changed CoAP header fields
                  <vspace blankLines="1"/>
                  As mentioned in (<xref target="onereq-oneres"/>), this is not
                  necessarily a threat, and it is not in scope of the security
                  objectives to mitigate.
                </t>
                
                <t>
                  The proxy forwards a response with changed CoAP header fields
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since message layer 
		  parameters may be changed by a proxy.  A change of Code in 
		  the response may be misinterpreted, but as long as the
		  responses allow verification of resource information, such a
		  change will be detected, thus this threat is mainly a
		  denial-of-service.  Threats arising from modification of 
		  Version are difficult to predict.  A future version of CoAP 
		  must consider security implications of a proxy manipulating 
		  the version number.
                </t>
                
                <t>
                  The proxy forwards a request different from the translated 
		  request
                 <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>


                <t>
                  The proxy forwards a response to a non-equivalent request
                  <vspace blankLines="1"/>
                  If the response is from another server, then it can be 
		  mitigated by having different security associations with
		  different servers.  If the response is that of another
		  resource of the same server, it can be mitigated by having
		  different security associations of different resources, or by
		  securely associating a resource identifier to the
		  representation in the response.  If the response is from the 
		  right server and resource, then the modifications of payload, 
		  options and header are considered previously.
                </t>
                
                <t>
                  The proxy forwards an old response to the same resource
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  The proxy is supposed to
                  send a cached response, if fresh.  However, if the proxy
                  serves a stale response and manipulates the Max-Age option,
                  then it may trick the client into believing, that this is a
		  fresh response.  Since the proxy is entitled to make such
		  changes, this is not possible to prevent.  The server may
		  however provide other freshness information (timestamp,
		  counter, etc.)  integrity protected, together with the
                  resource representation, and associated resource information,
                  from which the client may infer that Max-Age is not correct.
                  Note that in case time synchronization cannot be assumed,
		  then information about age is limited to the order of the
		  responses. 
                </t>
                
                <t>
                  The proxy maliciously serves a 2.03 (Valid) response
                  to a request with an ETag option
                  <vspace blankLines="1"/>
                  This is not possible to prevent, since the proxy is entitled
                  to perform such operation, without involving the server.
                  TODO: Since the response must not include a payload
                  (RFC 7252, 5.9.1.3) it is not clear how a server could
                  enforce the proxy to include any integrity protected freshness
                  information unless we define new proxy processing rules.
                </t>
                
                <t>
                  The proxy colludes with a legitimate client, having access to
                  the key used to generate and verify Message Authentication
                  Codes (MAC) of responses/resource representations to generate
		  a valid MAC.
                  <vspace blankLines="1"/>
                  This threat applies to responses containing a message
                  authentication code (MAC) for integrity protecting the 
		  resource representation.  The threat may be mitigated by the 
		  server digitally signing the representation with its private
		  key, instead of using a MAC.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section anchor="T2:3" 
		   title="T2:The proxy illegitimately sends a message">
            <t>
              <list style="format T2:3.%d">
                
                <t>
                  The proxy sends a request to the server, without a previous
                  request from the client
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since the proxy may want to
                  keep the cache updated with fresh representations to allow
                  short round-trip time.  A proxy maliciously making requests,
                  for the purpose of gaining information about the resources,
                  may to some extent be mitigated by encryption, but
                  encrypting data in the cache key has an impact on how the
                  cache can perform its legitimate operation.  This is out of
		  scope for the security objectives.
                </t>
                
                <t>
                  The proxy sends a response to the client, without a previous
                  response from the server
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since the proxy is allowed
                  to respond with a fresh, cached response.  Other cases of
                  responding inappropriately to a client request are covered in
                  the previous section.  The client can detect the case of
                  receiving a response without having sent a request.
                </t>
                
                <t>
                  A proxy sends a number of messages, for the purpose of flooding
                  client or server
                  <vspace blankLines="1"/>
                  Considering that a proxy is entitled to make resource
                  requests, it may be difficult to protect the server against
                  this kind of denial-of-service attacks.  As for responses, by
                  verifying the integrity and freshness of requested 
		  information, the client may mitigate certain flooding attacks.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:3" 
	    title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:3.%d">
                <t>
                  The proxy does not forward a message
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  According to the
                  processing rule, the proxy must not forward a request, if
                  there is a fresh cached response.  If the proxy does not
                  forward a request, although there is no valid cache response,
                  then this is a denial-of-service attack, and likewise if the
                  proxy does not propagate a response.  While these threats may
                  be difficult to mitigate, missing messages are common in
                  lossy environments so applications should have a readiness
                  for this kind of issue.
                </t>
                
                <t>
                  The proxy delays forwarding of a received message
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so it
                  is difficult to detect and mitigate this.
                  Delayed requests and responses can also be used in
                  attacks against actuators as is discussed in
                  <xref target="onereq-oneres"/>,
                  but that is out of scope for this scenario.
                </t>
                
                <t>
                  The proxy reorders the requests
                  <vspace blankLines="1"/>
                  Out of scope of the security objectives.
                </t>
                
                <t>
                  The proxy reorders the responses
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting a freshness parameter together with the response.
                </t>
                
                
              </list>
            </t>
          </section>
          
          <section anchor="T4:3" 
		   title="T4:The proxy illegitimately reads part of a message">
            <t>
              <list style="format T4:3.%d">
                <t>
                  The proxy reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the
                  representation, and other potential payload data.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP options and header fields.
                  <vspace blankLines="1"/>
                  The proxy needs to read the cache key for performing caching
                  operations.  Information leaking that can be inferred from 
		  such data cannot be prevented.
                </t>
              </list>
            </t>
          </section>

        </section>
        
        <!-- *************************************************************** -->
        
        <section anchor="R3" title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for the caching scenario.  For each requirement and non-requirement
	    the associated threats are listed.  The security requirements are:
            
            <list style="format R3.%d">
              <t>
                The client must be able to verify that a received resource
                representation originates from the requested server (T1:3.2, 
		T1:3.8)
              </t>
              
              <t>
                The client must be able to verify that a received representation
                is a representation of the resource requested by the client
                (T1:3.2, T1:3.4, T1:3.8)
              </t>
              
              <t>
                The client must be able to verify the content format of the 
		representation (T1:3.4)
              </t>
              
              <t>
                The client must be able to detect that a received representation
                is fresh (T1:3.9, T3:3.4)
              </t>
              
              <t>
                The representation must be integrity protected and encrypted
                from the server to the client (T1:3.2, T1:3.11, T2:3.3, T4:3.1)
              </t>
              
              <t>
                To protect against the proxy colluding with an authorized 
		client, asymmetric cryptography must be used (T1:3.11)
              </t>
            </list>
            The security non-requirements of the caching scenario are:
            
            <list style="format NR3.%d">
              
              <t>
                The request is not protected (See Security Objectives)
              </t>
              
              <t>
                The header and options of the response are not protected
                (See Security Objectives, compare R3.3)
              </t>
              
              <t>
                The proxy may eavesdrop on metadata, including the cache key, or
                by making requests on behalf of alleged clients (T2:3.1, T4:3.2)
              </t>
              
              <t>
                The proxy may drop messages, without the endpoint being able to
                infer that the message is lost due to the proxy (T3:3.1)
              </t>
              
              <t>
                The proxy may delay messages without being detected (T3:3.2)
              </t>
              
              <t>
                The client may not be able to verify validity information 
		provided by proxy when using ETag (T1:3.10)
              </t>
            </list>
            
          </t>
        </section>
        
      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->

      
      <section title="Multiple Requests - Multiple Responses: Observe">
        
        <t>
          This scenario is about replicating a resource state from a
          server to a client.  The client observes a
          resource, and receives notifications which may be cached.
          The difference, compared to the previous scenario
          (<xref target="mulreq-oneres"/>), is the capability
          to send multiple responses, in reply to a single request.
          The difference, compared to <xref target="onereq-mulres"/>,
          is that in this scenario multiple clients may be served
          with the same response.
        </t>
        
        <t>
          This functionality protects communication-constrained servers from
          repeated requests, which may come from different clients, when the
	  resource is unchanged. This saves system resources and bandwidth.
        </t>
        
        <t>
          In addition to multiple clients' requests being served by one
          response, each request may result in multiple responses.
        </t>

        
        <figure anchor="figure-observe" title="Message flow for observe 
					       with multiple observers.">
          <artwork align="center">
            <![CDATA[
Client A         Proxy          Server
   |               |               |
   |    Request    |    Request    |
   |-------------->|-------------->|--.
   |               |               |  |
   |<--------------|<--------------|<-'
   |    Notify     |    Notify     |  |
   |               |               |  |
                   |               |  |
Client B           |               |  |
   |               |               |  |
   |    Request    |               |  |
   |-------------->|--.            |  |
   |               |  | from cache |  |
   |<--------------|<-'            |  |
   |    Notify     |               |  |
   |               |               |  |
   |<--------------|<-+------------|<-'
   |    Notify     |  |  Notify    |
   |               |  |            |
                   |  |            |
Client A           |  |            |
   |               |  |            |
   |<--------------|<-'            |
   |    Notify     |               |
   |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          The server exposes an observable resource (e.g., the current
          reading of a temperature sensor).  Multiple clients are
          interested in the current state of the resource, and observe
          it, using the <xref target="RFC7641">CoAP resource observation
            mechanism</xref>.  The goal is to keep the state observed by
          the clients closely in sync with the actual state of the
          resource at the server.  Another goal is to minimize the
          burden on the server, by moving the task to fan out
          notifications to multiple clients from the server to the
          proxy.
        </t>
        
        <t>
          Functional Requirements:
          <vspace blankLines="1"/>
          The functional requirements of the previous scenario
          (<xref target="mulreq-oneres"/>) apply, and additionally:
          <list style="symbols">
            <t>
              The proxy must be able to observe a resource, on behalf of
              one or more clients.
            </t>
            <t>
              When a client registers interest in a resource with the
              proxy, the proxy must be able to return a response, containing
              the current state of the resource, without contacting the
              server.
            </t>
          </list>
        </t>
        
        <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          <t>
            The proxy complies with the processing rules PR3.1 - 3.5
            of the previous scenario (<xref target="PR3"/>).
            
            In addition, the following processing rules apply:
            <list style="format PR4.%d">
              <t>
                If the proxy receives a notification from the server,
                that is out of sequence (as indicated by the Observe
                option), then the proxy discards the notification.
                Otherwise, the proxy proceeds to notify the registered
                observers.
              </t>
              <t>
                When notifying an observer, the proxy modifies the
                Observe option, to indicate the sequence of
                notifications from the proxy to the observer.
              </t>
              
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Security Objectives">
          <t>
            The security objectives are identical to the previous scenario.
          </t>
        </section>
        
        <!-- *************************************************************** -->

        <section title="Threat Analysis and Mitigation">
          <t>
            The threat analysis from the previous scenario carries over to this
            scenario.
          </t>
          
          <section anchor="T1:4" 
		   title="T1:The proxy illegitimately modifies a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T1:3"/>).  For example in T1:3.4, a proxy may
              maliciously modify the Observe option to indicate a different 
	      order of notifications, without being detected.  However, the
	      mitigation specified in the previous scenario applies: the server
	      integrity protects a freshness parameter with the response.
            </t>
          </section>
          
          <section title="T2:The proxy illegitimately sends a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T2:3"/>).
            </t>
          </section>
          
          <section 
	      title="T3:The proxy illegitimately inhibits sending of a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T3:3"/>).  The threat in T3:3.4 may be combined 
	      with manipulation of the Observe option, but the same mitigation 
	      as mentioned in (<xref target="T1:4"/>) applies.
            </t>
          </section>
          
          <section title="T4:The proxy illegitimately reads part of a message">
            <t>
              The same conclusions apply as in the previous scenario
              (<xref target="T4:3"/>).
            </t>
          </section>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            Since the security objectives, and threat mitigations carry over from
            the previous scenario (<xref target="mulreq-oneres"/>), the same
            security requirements are valid (<xref target="R3"/>).
          </t>
          
        </section>

      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->

      
      <section 
	  title="Multiple Requests - Multiple Responses: Publish-Subscribe">
        
        <t>
          The intermediary node in the publish-subscribe scenario is a broker 
	  for messages from a publisher to subscriber.  A subscriber subscribes
	  to a "topic", and receives a publication.  The broker fans out
	  subsequent publications on that topic to all subscribers.
        </t>
        
        <t>
          In this scenario a single request may result in multiple responses,
          and a single response may reach multiple clients.
        </t>
        
        
        <figure anchor="figure-4" title="Message flow for publish-subscribe">
          <artwork align="center">
<![CDATA[Subscribers      Broker         Publisher
(Client A)      (Server)        (Client)
    |               |               |
    |               |    Publish    |
    |      to store |<--------------|
    |               |               |
    |   Subscribe   |               |
    |-------------->|--.            |
    |               |  | from store |
    |<--------------|<-'            |
    |    Notify     |               |
    |               |               |
                    |               |
(Client B)          |               |
    |               |               |
    |   Subscribe   |               |
    |-------------->|--.            |
    |               |  | from store |
    |<--------------|<-'            |
    |    Notify     |               |
    |               |               |
    |               |               |
    |<--------------|<-+------------|
    |    Notify     |  |  Publish   |
    |               |  |            |
    |               |  |            |
(Client A)          |  |            |
    |               |  |            |
    |<--------------|<-'            |
    |    Notify     |               |
    |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          The broker maintains a number of topics, which a publisher can publish
	  to, and a subscriber subscribe to. Topics are represented as URIs at 
	  the broker. <xref target="figure-4"/> illustrates the publication to 
	  a topic, implemented as a PUT request of a representation to a
	  resource at the broker.</t>

	<t>
	  Note that the PUT response may be inhibited using the
          No-Response option <xref target="I-D.tcs-coap-no-response-option"/> 
	  and is omitted from the figure.
        </t>
        
        <t>
          Subscribers can make a GET request with the Observe option to the 
	  topic URI at the broker, in order to initiate the subscription on the
	  topic.  The broker provides a notification, in the form the stored
	  representation, as response to the request. Further publications of
	  representations to this URI are provided as notification responses to
	  the subscription request.
        </t>

        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              The publication must be able to be transferred in a PUT request
              from the publisher, and in a GET response to the subscriber.
            </t>
          </list>
        </t>
        
       <!-- *************************************************************** -->
        
        <section title="Processing Rules">
          
          <t>
            <list style="format PR5.%d">
              
              <t>
                If the broker receives a subscription request to one of its
		resources, then the broker associates the requesting subscriber
		to the topic, and responds with the current representation.
              </t>
              
              <t>
                If the broker receives a publication request to one of its
		resources, then the broker stores the received representation
		on the topic, and responds with the representation to the
		associated subscribers of that topic.
              </t>
 
            </list>
          </t>
          
          <t>
            Since we are focusing on end-to-end security between publisher and
            subscriber, the creation and deletion of topics and other
	    endpoint-to-broker operations are out of scope.
          </t>
          
          
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          <t>
            The security objectives for this scenario are:
            <list style="format SO5.%d">
              <t>
                A subscriber is able to verify that a received response
		contains a resource representation of a requested topic, that 
		the publisher is authorized to publish to that topic, and
                that it has not been altered between publisher and subscriber.
              </t>
              
              <t>
                A subscriber is able to verify that a received
                resource representation is fresh
              </t>
              
              <t>
                The publisher is able to protect a resource representation, such
                that only authorized subscribers can read the representation.
              </t>

            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now analyze the potential threats relevant to this scenario.
          </t>
          
          
          <section title="T1:The broker illegitimately modifies a message">
            <t>
              <list style="format T1:5.%d">

                <t>
                  The broker responds to a subscriber request with a 
		  publication containing modified payload
		  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity protection of
                  payload.
                </t>
                
                <t>
                  The broker responds to a subscriber request with a 
		  publication with a modified CoAP option
                  <vspace blankLines="1"/>
                  Since the security objective is to protect the resource
		  representation, only options in the GET response, that
		  influence the interpretation of the resource representations,
		  have an impact.  A broker is entitled to change Max-Age, and
		  may do so maliciously.  The broker is not entitled to change 
		  Content-Format, but may anyway do so maliciously.  To mitigate
		  these, the subscriber needs to be able to verify information
		  about freshness and content format provided by the publisher.
                </t>
                
                
                <t>
                  The broker responds to a subscriber request with modified 
		  CoAP header fields
                  <vspace blankLines="1"/>
                  Since the security objective is to protect the resource
		  representation, only header fields in the GET response, that 
		  influence the interpretation of the resource representations, 
		  have an impact.  Changing of Code such as e.g. 2.05 (Content) 
		  to some error code is a denial-of-service.
                </t>
                
                
                <t>
                  The broker modifies the publication before or during storage
                  <vspace blankLines="1"/>
                  This threat is analogous to the previous threats, and is
		  mitigated in the same way.
                </t>
              
                
                <t>
                  The broker responds to a subscriber request with the wrong 
		  message
                  <vspace blankLines="1"/>
                  Modifications of payload, options, and header are considered 
		  previously.  To mitigate wrong interpretation of a response, 
		  resulting from a broker sending old messages, or reordering 
		  messages, from the same publisher to the same subscriber, the
		  message may integrity protect a freshness parameter 
		  (timestamp, counter, etc.), from which the age/order can be 
		  deduced (replay/reordering protection).
                </t>
                
                
                <t>
                  The broker colludes with a legitimate subscriber having 
		  access to the key used to create Message Authentication Codes
		  (MAC) of publications, in order to generate a valid MAC of a
		  modified publication.
                  <vspace blankLines="1"/>
                  This threat applies to publications containing a message
                  authentication code (MAC) for integrity protecting the 
		  resource representation.  The threat may be mitigated by the 
		  publisher digitally signing the representation with a private
		  key instead of using a MAC.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section title="T2:The broker illegitimately sends a message">
            <t>
              <list style="format T2:5.%d">
                
                <t>
                  The broker sends a response to a subscriber request, without a
		  previous publication from the publisher
                  <vspace blankLines="1"/>
                  Most cases of responding inappropriately to a subscriber
		  request are covered in the previous section.  In general,
		  authentication of publisher, in combination with
		  replay/reordering protection will mitigate this threat.
                </t>
                
                <t>
                  A broker sends a number of messages, for the purpose of 
		  flooding the subscriber
                  <vspace blankLines="1"/>
                  By verifying the integrity and freshness information, the 
		  subscriber may mitigate certain flooding attacks.
                </t>
              </list>
            </t>
          </section>
          
          <section anchor="T3:5" 
            title="T3:The broker illegitimately inhibits sending of a message">
            <t>
              <list style="format T3:5.%d">
                <t>
                  The broker does not store or forward a publication
                  <vspace blankLines="1"/>
                  This is a denial-of-service attack.  While these threats may
                  be difficult to mitigate, missing messages are common in
                  lossy environments so applications should have a readiness
                  for this kind of issue.
                </t>
                
                <t>
                  The broker does not respond to a publication request
                  <vspace blankLines="1"/>
                  If there is a response (it may be omitted using the 
		  No-Response option) this may be a denial-of-service attack on
		  the publisher.  While such a threat may be difficult to 
		  mitigate, missing messages are common in lossy environments
		  so applications should have a readiness for this kind of
		  issue.
                </t>
              
                <t>
                  The broker delays forwarding of a received publication
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial-of-service attack, similar
                  to not forwarding.  Certain delays may be legitimate, so it
                  may be difficult to detect and mitigate.
                </t>
                
                <t>
                  The broker reorders the publications
                  <vspace blankLines="1"/>
                  This threat may be mitigated by
                  the publisher integrity protecting the message, and including
                  a freshness parameter.
                </t>
        
              </list>
            </t>
          </section>
          
          <section title="T4:The broker illegitimately reads part of a message">
            <t>
              <list style="format T4:5.%d">
                <t>
                  The broker reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the
                  representation, and other potential payload data
                </t>
                
                <t>
                  The broker infers information about the nature and state of 
		  the publication from CoAP options and header fields.
                  <vspace blankLines="1"/>
                  This meta-data is not in scope of confidentiality.  
		  Information leaking that can be inferred from such data 
		  cannot be prevented.
                </t>
              </list>
            </t>
          </section>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for the publish-subscribe scenario.  For each requirement and 
	    non-requirement the associated threats are listed.  The security
	    requirements are:
            
            <list style="format R5.%d">
              <t>
                The subscriber must be able to verify that a received resource
                representation originates from an authorized publisher (T1:5.1,
		T2:5.1)
              </t>
              
              <t>
                The subscriber must be able to verify that a received 
		representation is a representation of the resource requested by
		the subscriber (T1:5.1, T1:5.4, T1:5.5, T1:5.6)
              </t>
              
              <t>
                The subscriber must be able to verify the content format of the 
		representation (T1:5.2)
              </t>
              
              <t>
                The subscriber must be able to detect that the received resource
                representation is older than a previously received
                representation of this resource (T1:5.5, T2:5.1, T3:5.4)
              </t>
              
              <t>
                The representation must be integrity protected and encrypted
                from publisher to subscriber.  (T1:5.1, T1:5.5, T2:5.2, T4:5.1)
              </t>
              
              <t>
                To protect against the proxy colluding with an authorized 
		subscriber, asymmetric cryptography must be used.  (T1:5.6)
              </t>
            </list>
            The security non-requirements of the pub-sub scenario are:
            
            <list style="format NR5.%d">
              
              <t>
                The subscription request is not protected (See Security 
		Objectives)
              </t>
              
              <t>
                The header and options of the notification response are not 
		protected (See Security Objectives, compare R5.3)
              </t>
              <t>
                The broker may change and eavesdrop on certain metadata without
		being detected (T1:5.2, T1:5.3, T4:5.2)
              </t>
              
              <t>
                The broker may drop messages without being detected (T3:5.1, 
		T3:5.2)
              </t>
              
              <t>
                The broker may delay messages without being detected (T3:5.3)
              </t>
            </list>
            
          </t>
          
        </section>
        
      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
      
    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section anchor="sec-cons" title="Security Considerations">

      <t>
        A proxy or intermediary may be an aggregation point for message flows,
        and therefore it is an attractive target, both from a security and privacy
        point of view.
      </t>
      
      <t>
        Unless the security mechanisms provide forward secrecy, a
        compromise of long term keying material means that an attacker can 
	decrypt all previously sent information, and can be directly used for
	any kind of manipulation of the cyber-physical system.
      </t>
      
      <t>
        Therefore the key exchange mechanism used for establish keys to use with
        application layer security must provide forward secrecy.
      </t>
      
      <t>
        Intermediary nodes are aggregation points, also for meta data, and
        therefore valuable targets for signal intelligence agencies.
        Pervasive monitoring is an attack <xref target="RFC7258"/>, and the 
	effect of collecting and correlating information from multitude of 
	proxies must to be mitigated.
      </t>
      
      <t>
        Related to this, it is needed to delete all historical information
        from all nodes handling the plaintext data and meta-data, in order
	to avoid information leakage.  The impact of this on the intermediary
	nodes can be limited, by confidentiality protecting as much as
	possible between the endpoints.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    

    <section title="IANA Considerations">

      <t>
        This document includes no request to IANA.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC2119;

      &RFC7252;
      
      &RFC7258;
      
      &RFC7641;

    </references>

    <references title="Informative References">

      &RFC6347;

      &RFC7228;
      
      &I-D.ietf-cose-msg;
      
      &I-D.tcs-coap-no-response-option;

      &I-D.mattsson-core-coap-actuators;
      
      &I-D.koster-core-coapmq;

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->


    <section title="Acknowledgments" anchor="acknowledgments" numbered="no">
      <t>
     The authors wish to thank John Mattsson and Ari Keranen for reviewing
     early versions of the draft.
     </t>
    </section>
   
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
