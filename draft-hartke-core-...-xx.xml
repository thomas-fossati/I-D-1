<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
  <!ENTITY RFC4949 SYSTEM "reference.RFC.4949.xml">
  <!ENTITY RFC6347 SYSTEM "reference.RFC.6347.xml">
  <!ENTITY RFC7228 SYSTEM "reference.RFC.7228.xml">
  <!ENTITY RFC7252 SYSTEM "reference.RFC.7252.xml">
  <!ENTITY RFC7641 SYSTEM "reference.RFC.7641.xml">
  <!ENTITY I-D.ietf-cose-msg SYSTEM "reference.I-D.ietf-cose-msg.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>

<rfc category="info" docName="draft-hartke-core-e2e-security-00" ipr="trust200902">
    
    <front>

    <title>Requirements for CoAP End-To-End Security</title>

    <author initials="G." surname="Selander" fullname="Goeran Selander">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>goran.selander@ericsson.com</email>
      </address>
    </author>
    
    <author initials="F." surname="Palombini" fullname="Francesca Palombini">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code>SE-164 80 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>francesca.palombini@ericsson.com</email>
      </address>
    </author>
    
    <author initials="L." surname="Seitz" fullname="Ludwig Seitz">
      <organization>SICS Swedish ICT AB</organization>
      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <city>Lund</city>
          <code>223 70</code>
          <country>Sweden</country>
        </postal>
        <email>ludwig@sics.se</email>
      </address>
    </author>

    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63905</phone>
        <email>hartke@tzi.org</email>
      </address>
    </author>
    
    <date />


    <area>Applications</area>

    <workgroup>CoRE Working Group</workgroup>

    <abstract>

      <t>
        This document analyses threats to CoAP message 
        exchanges traversing proxies and derives the security requirements
        mitigating the threats.
      </t>

    </abstract>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction">

      <t>
        The <xref target="RFC7252">Constrained Application Protocol
        (CoAP)</xref> is a Web application protocol designed for
        <xref target="RFC7228">constrained nodes and networks</xref>.
        CoAP relies on <xref target="RFC6347">Datagram Transport Layer
        Security (DTLS)</xref> for security. At the same time, CoAP
        relies on proxies to improve scalability and
        efficiency. These proxies are specified to perform a
        number of operations on CoAP messages which requires
        DTLS to be terminated at the proxy. The proxy therefore
        not only has access to the data required for performing the
        intended proxy functionality but also is able to eavesdrop on
        or manipulate any part of the CoAP payload and metadata in
        transit between client and server without being protected or
        detected by DTLS.
      </t>

      <t>
        One way to mitigate this threat is to secure CoAP communication
        at the application layer using an object-based security
        mechanism (such as <xref target="I-D.ietf-cose-msg">CBOR
        Encoded Message Syntax</xref>) instead of or in addition to
        the security mechanisms at the network layer or transport
        layer.
      </t>

      <t>
        This document analyses the threats to CoAP requests and
        responses of sensor and actuator deployments involving proxies.
        The analysis is based on identifying the assets associated to sensor-
        and actuator-based communication patterns, and considering
        the potential threats executed through proxies to these assets.
        The threat analysis provides the basis for defining the security
        requirements that an application layer security mechanism for CoAP
        needs to meet.
      </t>

      <section title="Terminology">

        <!--
        <t>
          This document makes use of the terminology defined in
          <xref target="RFC4949"/>.
        </t>
        -->

        <t>
          Readers are expected to be familiar with CoAP
          <xref target="RFC7252"/> and the terms defined there.
        </t>

        <!--
        <t>
          Additionally, the following terms are used in this document:
          <list style="hanging">
            <t hangText="...:">...</t>
          </list>
        </t>
        -->

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119"/>.
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Scope and assumptions">

      <t>
        This document presents a number of scenarios involving sensor
        and actuator communications over CoAP. Common to all scenarios is the
        presence of at least one proxy between
        the client requesting a resource and the server hosting a resource.
      </t>
      
      <t>
        The proxy is intentionally placed between the
        two endpoints and is responsible, for example, for reducing
        response time and network bandwidth use by serving responses from
        a cache or for enabling the client to make requests that it
        otherwise could not make.
      </t>
      
      <t>
        A proxy may perform different functions, but the basic function
        is to forward messages according to certain rules.  For example:
        
        <list style="format Rule %d:">
          <t>
            Forward a message to the next proxy when the link is up
          </t>
          <t>
            Only forward a request if there is no fresh cached response
          </t>
          <t>
            Forward a new publication to all subscribing clients
          </t>
        </list>
      </t>
 
      <t>
        In order to perform its function, a proxy may be required to read or
        change certain parts of a CoAP message, as discussed below. On the 
	other hand, there are parts of a CoAP message that a proxy in general 
	should not be able to read and change, such as the CoAP payload.
      </t>
      
      <t>
        Since a proxy might not be fully trusted, a security solution is needed
        that protects the client, the server and the message exchanges against
        certain threats, while still allowing the proxy to assume its normal
        functionality. The client and server are assumed to have a security
        association, but the proxy is neither assumed to have a security association
        with the client, nor with the server.</t>
      
      <t>
        To identify the threats in scope, we first consider what assets need to
        be protected. In general, there are the following types of assets to
        protect:
        <list style="format A%d:">
          <t>
            The devices at the two ends and their (often very
            constrained) system resources such as available memory,
            processing capacity, and energy.
          </t>
          <t>
            The physical environment of the devices fitted with sensor
            and actuators. Access to the physical environment is
            provided through CoAP resources that allow a remote entity
            to retrieve information about the physical environment
            (such as the current temperature) or to produce an effect
            on the physical environment (such as the activation of a
            heater).
          </t>
          <t>
	    The communication infrastructure linking the two devices
	    (which often contains some very constrained parts).
	  </t>
          <t>
            The messages exchanged between a client and a server, through the
            proxy. This includes the CoAP header and options in
            request and response messages (such as the requested method
            or the target URI) and the CoAP resource representations,
            encapsulated in the message payload.
          </t>
        </list>
      </t>
      
      <t>
        The scope of this document is to analyze threats executed through
        proxies, and this is only directly affecting the assets of type A3 and
        A4 listed above: Clearly A4 is affected by the proxies, and since the
        proxies are part of the communication infrastructure (A3) an attack
        executed through a proxy such as inhibiting forwarding has an impact
        on it.
      </t>
      
      <t>
        Note also that the assets of type A4, the messages, have an impact also
        on the two other types of assets. For example: flooding a device with
        messages has impact on its system resources; and successful manipulation
        of an actuator command carried in a message has an
        impact on the physical environment.
      </t>
      
      <t>
        There may be several reasons why a proxy could end up performing
        malicious operations, for example it may have become subject
        to intrusion, or infected by malware. A fully trusted proxy, handling
        unprotected messages, is an attractive target, since proxies commonly
        act as a concentrators for many message flows and since a proxy may
        be easier to attack from the Internet than attacking the sensor/actuator
        residing behind the proxy. The attack vectors for compromising a proxy
        and the associated risks are out of scope for this document.
      </t>
      
      <t>
        On a high level, there are the following potential threats from proxies
        to consider:
        <list style="format T%d:">
          <t>
            The proxy forwards a message other than received
          </t>
          <t>
            The proxy sends a message on its own initiative, including replay,
            flooding, etc.
          </t>
          <t>
            The proxy does not forward a message, including delay, reordering, 
	    etc.
          </t>
          <t>
            The proxy reads a message
          </t>
        </list>
      </t>
      
      <t>
        Not all of these potential threats are actual threats, in all proxy
        settings. For example, a forwarding proxy may change the
        contents of CoAP options Uri-Host, Uri-Port to that of the the next hop.
        A proxy caching reponses needs to read the cache key and may change the
        CoAP option Max-Age in the responses.
      </t>
      
      <t>
        To assess which of these potential threats are actual threats, we
        need to define what are the legitimate proxy operations in different scenarions
        and what are the security objectives in these scenarios.
      </t>
      
      
     
    </section>
    
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    
    <section title="Scenarios, threats and security requirements">
      
      <t>
        In this section we consider a set of scenarios involving proxies, with
        different forwarding rules and security objectives. We study the
        associated threats and derive the security requirements for message
        transfer between client and server in the different scenarios.
      </t>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
      
      <section title="One request - one response">
        
        <t>
          In this scenario we study use cases where it is important that a response
          sent from one endpoint is the response to a particular request
          to that endpoint. In other words, the proxy cannot cache or broker
          responses but is restricted to forwarding only. Use cases include
          challenge-response protocols such as alarm status request-response
          and actuator command confirmation.
        </t>
        <t>
          In this scenario there must be a unique response for each request.
        </t>
        
        
        <figure>
          <artwork align="center">
            <![CDATA[
  Client          Proxy          Server
    |               |               |
    |    Request    |    Request    |
    |-------------->|-------------->|--.
    |               |               |  |
    |<--------------|<--------------|<-'
    |    Response   |    Response   |
    |               |               |
    
  Figure XX: FIXME Captions, on all figures
            ]]>
          </artwork>
        </figure>
        
        
        <t>
          <list style="hanging">
            <t hangText="Example: Alarm status">
            <vspace blankLines="1"/>
              Figure XX can be seen as an illustration of a message exchange for a client
              requesting the alarm status, GET /alarm_status, at a server. Since the client
              wants to ensure that the alarm status received is reflecting the current alarm
              status, and not a cached or spoofed response to the same resource, it
              must be able to verify that the received response is a response to this
              particular request made by the client. Therefore the response must be
              securely bound to the request.
            </t>
            <t hangText="Example: Actuation confirmation">
            <vspace blankLines="1"/>
              Another example for which Figure XX serves as illustration is the
              confirmation of an actuator request. In this case a client, say in
              an industrial control system, requests a server that a valve should be
              turned to a certain level, e.g. PUT /valve_42/level with payload "3".
              In order for the client to correctly
              evaluate the result of a potential changed valve level,
              it is important that the client gets a confirmation
              how the server responded to the requested change, e.g. whether the request
              was performed or not. Again, the client wants to ensure that the response
              is reflecting the result of this particular actuation request made by the client,
              and not a cached or spoofed response. Therefore the response must be securely
              bound to the request.
            </t>
          </list>
        </t>
        
        <t>
          Functional Requirement:
          <list style="symbols">
            <t>
              The client and server must be able to exchange messages with as
              little as possible impact from intermediate nodes.
            </t>
            <t>
              All caching functionality should be disabled, since these messages
              only have a meaning to these endpoints during this interaction.
            </t>
          </list>
        </t>
        

        <!-- *************************************************************** -->
        
        <section title="Proxy Rules">
          <t>
            In this scenario, the proxy functionality is limited to forwarding.
            There are two ways for a forward proxy to forward requests:
            Either (R1.1) using the Proxy-Uri option, or (R1.2) using different
            information in Uri-Host/Uri-Port and destination IP address/port.
            <list style="format PR1.%d">
              <t>
                The Proxy-Uri option contains the request URI (potentially
                including request scheme e.g. "coaps://") and the Uri-* options
                contains the URI of the proxy.
                <vspace blankLines="1"/>
                If the proxy is configured to forward requests for this request
                URI to another proxy, then it replaces the Uri-* options
                with those of the other proxy, else it splits the Proxy-Uri option 
                into its components and replaces the corresponding Uri-* options. 
                Then it forwards the request using the request scheme indicated in 
                the Proxy-Uri.
              </t>
              <t>
                The Proxy-Uri option is not present, the Proxy-Scheme option may
                be present and the Uri-* options contains the request URI.
                <vspace blankLines="1"/>
                In the last hop, when the proxy forwards the request to the request
                URI, the request uses the request scheme indicated in the Proxy-Scheme.
                The Proxy-Scheme option is omitted in the last hop, but the proxy
                does not change the Uri-* options.
              </t>
              <t>
               Responses are forwarded by the proxy without any modification.
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          <t>
            In this scenario there is a unique response for each request, so the
            client should be able to verify that a certain response is made in
            response to a specific request sent by the client.
          </t>
          <t>
            As the proxy functionality is restricted to forwarding only, as much
            as possible of the original messages should be protected
            between client and server, to prevent unauthorized access and manipulations
            by a proxy. FIXME Reference IAB statement of Internet Confidentiality
          </t>
          <t>
            The server should be able to verify that the proxy has
            performed the allowed message modifications according to the
            proxy rules, according to the intended
            operations requested by the client.
          </t>
          
          <t>
            The security objectives are:
            <list style="format SO1.%d">
              <t>
                The server is able to verify that a received request originates
                from a client with which it has a security association, and that
                the request has not been received before.
              </t>
              <t>
                The server is able to verify that the received request either
                has not been altered in transfer, or that the request is modified
                according to the proxy rules PR1.1 and PR1.2 (Section 3.1.1).
              </t>
              <t>
                The server is able to protect the response such that only
                authorized clients can read the response.
              </t>
              <t>
                The client is able to verify that the received response
                originates from the requested server and resource,
                that it has not been altered in transfer, and that it was
                generated in response to the request.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now list potential threats and discuss their implications
          </t>
          
          <section title="T1:The proxy forwards a messages other than received">
            <t>
              <list style="format T1:1.%d">
                <t>
                  The proxy forwards a request with modified payload
                  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity protection of
                  payload
                </t>
                
                <t>
                  The proxy forwards a response with modified payload
                  <vspace blankLines="1"/>
                  This threat that may be mitigated with integrity protection of
                  payload
                </t>
                
                <t>
                  The proxy forwards a request with modified CoAP option
                  <vspace blankLines="1"/>
                  This threat may be mitigated by integrity protecting the values
                  of selected CoAP options. Note that the proxy is entitled to
                  change certain options by proxy rules PR1.1 and PR1.2. However,
                  since the change is predictable, the request URI and
                  Proxy-Scheme can be integrity protected by the client and verified
                  by the server.
                </t>

                <t>
                  The proxy forwards a response with modified CoAP option
                  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity protection of
                  CoAP options. Since the response is not intended to be cached,
                  Max-Age is set to 0 (FIXME: add reference to CoAP section 5.7.1) and since the proxy is not entitled to change
                  any other options they can all be integrity protected
                </t>
                
                <t>
                  The proxy forwards a request with changed CoAP header fields
                  <vspace blankLines="1"/>
                  This is not necessarily a threat. For example, a proxy is
                  entitled to change Token as part of its normal operations.
                  Malicious changes to message layer parameters may cause denial-
                  of-service, equivalent of dropping a message or sending
                  spoofed messages. This is difficult to mitigate.
                  However, changing the CoAP header Code, e.g. from GET to DELETE
                  may result in an error or wrong interpretation of the request
                  which can have other security implications.
                  A change to the header field
                  Version may result in security errors in interaction between
                  different versions of CoAP.
                  These threats may be
                  mitigated by integrity protecting the Code and
                  Version header fields.
                </t>
                
                <t>
                  The proxy forwards a response with changed CoAP header fields
                  <vspace blankLines="1"/>
                  Similar to previous threat. Some aspects may be
                  mitigated by integrity protecting the Code and
                  Version header fields.
                </t>
                
                <t>
                  The proxy forwards a different request
                  <vspace blankLines="1"/>
                  If the forwarded request is from another client it can be mitigated by
                  having different security associations with different clients.
                  If the forwarded request is from the same client, but with
                  differences in payload, options or header then this coincides with
                  previous threats.
                  A proxy sending old requests, or reordering requests, from the
                  same client to the same server resource can be
                  mitigated by integrity protecting a freshness parameter
                  (timestamp, counter, etc.) from which the
                  order of requests can be deduced (replay/reordering protection).
                </t>
                
                <t>
                  The proxy forwards a different response 
                  <vspace blankLines="1"/>
                  By integrity protecting uniquely identifying information of the
                  request in the response, the client can verify if the response
                  was generated in response to a particular request.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section title="T2:The proxy sends a message on its own initiative">
            <t>
              <list style="format T2:1.%d">
                
                <t>
                  The proxy sends a request to the server without a previous
                  request from the client
                  <vspace blankLines="1"/>
                  This threat may be mitigated with integrity- and replay
                  protection
                </t>
                
                <t>
                  The proxy sends a response to the client without a previous
                  response from the server
                  <vspace blankLines="1"/>
                  This is not necessarily a threat. Error messages from the
                  proxy such as 5.02 (Bad Gateway) originates from the proxy.
                  A proxy maliciously sending error messages is a denial-of-service
                  attack similar to not forwarding a message (T3:1.1) and is
                  difficult to mitigate.
                  However, responses claiming to be from the server may be
                  mitigated with integrity protection uniquely
                  identifying information of the request
                </t>
                
                <t>
                  A proxy sends a number of messages for the purpose of flooding
                  client or server
                  <vspace blankLines="1"/>
                  By verifying the integrity, the client and server may
                  mitigate certain flooding attacks. The server can use the replay/reordering
                  protection to verify which messages are legitimate and the client
                  can verify if a message is a response to a previously sent request.
                </t>
              </list>
            </t>
          </section>
          
          <section title="T3:The proxy does not forward a message">
            <t>
              <list style="format T3:1.%d">
                <t>
                  The proxy does not forward a message
                  <vspace blankLines="1"/>
                  This is a denial-of-service attack. While these threats may be
                  difficult to mitigate, applications
                  should have a readiness for this kind of issues, and a client
                  is able to detect a missing response.
                </t>
                
                <t>
                  The proxy delays forwarding of a received message
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial of service attack, similar
                  to not forwarding.  Certain delays may be legitimate so it
                  may be difficult to detect and mitigate.
                  However, delayed requests and responses can also be used in
                  attacks against actuator, see draft-mattsson FIXME. These attacks can be
                  performed by an on-path attacker and are not restricted to
                  proxies. The proposed mitigation is based on verifying the
                  timeliness of the request for example by using time stamps or
                  with an additional round-trip. These mitigations can be
                  supported by a new CoAP option containing time stamp or
                  binding the response in a first round-trip to a request of
                  the second. By integrity protecting that new CoAP option,
                  the threat can be mitigated.
                </t>
                
                <t>
                  The proxy reorders the requests
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting a freshness parameter from which the
                  order of requests can be deduced
                </t>
                
                <t>
                  The proxy reorders the responses
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting to which request a response belongs
                </t>
                
                
              </list>
            </t>
          </section>
          
          <section title="T4:The proxy reads a message">
            <t>
              <list style="format T4:1.%d">
                <t>
                  The proxy reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the payload.
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP options.
                  <vspace blankLines="1"/>
                  The proxy only needs to read the Uri-Host/Uri-Port and
                  Proxy-Uri/Proxy-Scheme options of a request and Max-Age of the
                  response (which is set to 0 as indicated in T.1.4 FIXME: is this ok?). The information revealed by
                  these parameters is anyway public on network layer. The other
                  options may be encrypted.
                  FIXME: may be encrypted or can or should?
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP header fields.
                  <vspace blankLines="1"/>
                  The header fields needs to be transferred in plain text to allow
                  normal CoAP operations. The Code parameter reveals information
                  about what RESTful action is requested. This information leakage is
                  difficult to mitigate without violating the REST paradigm.
                </t>

              </list>
            </t>
          </section>

        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for the this scenario.  For each requirement and non-requirement the
            associated threats are listed. The security requirements are:
            <list style="format R1.%d">
              
              <t>
                The server SHALL authenticate a message coming
                from a requesting client (T1:1.1, T1:1.3, T1:1.5, T2:1.1)
              </t>
              
              <t>
                The server SHALL verify if it has received this message
                previously or if the messages are received in the wrong order,
                i.e. replay and re-ordering protection (T1:1.7, T3:1.3)
              </t>
              
              <t>
                The client SHALL verify that the received response
                originates from the requested server (T1:1.2, T1:1.4, T1:1.6, T2:1.2)
              </t>
              
              <t>
                The client SHALL verify that a response is the
                response to a particular request that the client has made (T1:1.8, T3:1.4)
              </t>
              
              <t>
                The payload SHALL be integrity protected and SHOULD be encrypted
                between client and server (T1:1.1-6,T4:1.1, T2:1.3, T4:1.1)
              </t>
              
              <t>
                The CoAP options except Uri-* and Proxy-* SHALL be integrity
                protected in the request. The request URI and proxy scheme SHALL be
                integrity protected in the request. (T1:1.3)
              </t>
              
              <t>
                All CoAP options in the response SHALL be integrity protected.
                Max-Age SHALL be set to 0 (T1:1.4)
              </t>
              
              <t>
                The CoAP options Uri-Host/Port and Proxy-Uri/Scheme of the request
                SHALL NOT be encrypted.  The Max-Age option of the response SHALL
                NOT be encrypted. All other options SHALL be encrypted. (T4:1.2)
              </t>
              
              
              <t>
                The CoAP header fields Version and Code SHALL be integrity protected
                in requests and responses. All other header fields SHALL not be
                integrity protected. The header fields SHALL NOT be encrypted.
                (T1:1.5, T4:1.3)
              </t>
              
              
            </list>
            
            The security non-requirements of the this scenario are:
            
            <list style="format NR1.%d">
              <t>
                The proxy may drop messages without being detected (T3:1.1)
              </t>
              
              <t>
                The proxy may delay messages without being detected (T3:1.1, T3:1.2)
              </t>
            </list>
            
          </t>
        </section>
        
        
      </section>
      
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      <section title="One request - multiple responses">
        
        
        <t>
          This scenario is about notifying a client when a resource changes.
          The client observes a resource, and receives notifications.
        </t>
        
        <t>
          This functionality protects communication-constrained servers from
          repeated requests when the resource is unchanged thus saving system
          resources and bandwidth.
        </t>
        
        <t>
          In this scenario there are typically multiple responses for one request.
        </t>
        
        
        <figure>
          <artwork align="center">
            <![CDATA[
    Client          Proxy          Server
      |               |               |
      |    Request    |    Request    |
      |-------------->|-------------->|--.
      |               |               |  |
      |<--------------|<--------------|<-'
      |  Notification |  Notification |  |
      |               |               |  |
      |<--------------|<--------------|<-'
      |  Notification |  Notification |  |
      |               |               |  |
      |<--------------|<--------------|<-'
      |  Notification |  Notification |
      |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          The server exposes an observable resource (e.g., the current
          reading of a temperature sensor). A client is
          interested in the current state of the resource and observes
          it using the <xref target="RFC7641">CoAP resource observation
            mechanism</xref>. The goal is to keep the state observed by
          the client closely in sync with the actual state of the
          resource at the server.
          FIXME Describe the Observe option.
        </t>
        
        <!-- *************************************************************** -->
        
        <section title="Proxy Rules">
          
          <t>
            The proxy complies with the fowarding rules PR 1.1 - 1.2 see
            section 3.1.1. In addition the following proxy rules apply:
            <list style="format PR2.%d">
              <t>
                The proxy may modify the Observe option . . .
              </t>
              
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          <t>
            With observe there may be a sequence of responses to one request,
            but each response
            maps to a unique request. By ordering the responses each message in
            this exchange can be made unique.
          </t>
          <t>
            Since the proxy functionality is identical to the previous scenario the security
            objectives are similar to the previous scenario. SO1.1, SO1.2, SO1.3 are valid
            also in this case, but the final objective SO1.4 is replaced by SO2.1
            <list style="format SO2.%d">
              <t>
                The client is able to verify that the received response
                originates from the requested server and resource,
                that it has not been altered in transfer, and that it was
                generated as one in a sequence of responses to the request.
              </t>
            </list>
          </t>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            The threat analysis carries over from the previous scenario,
            with a few exceptions.
          </t>
          
          <section title="T1:The proxy forwards a messages other than received">
            <t>
              The same conclusions apply as in the previous scenario except that:
            </t>
            
            <t>
              If the Observe option is not encrypted, it may be legitimately modified by the
              proxy and cannot be integrity protected. However, if the Observe
              option is encrypted, then it is not visible to the proxy
              and may be integrity protected.
            </t>
            
            <t>
              If Observe is not encrypted and thereby cannot be integrity protected,
              then the proxy may reorder responses from the
              same server to the same client. In this case it is not enough with
              protecting uniquely identifying information of the request in the
              response, since there may be multiple responses
              to one request.
              However, analogous to how requests are protected against
              replay/reordering in the previous scenario, by introducing and
              integrity protecting a similar freshness parameter from which the
              order of responses can be deduced this threat can be mitigated.
            </t>
            
            <t>
              If Observe is encrypted and integrity protected,
              then reordered responses will be detected by the client.
            </t>
          </section>
          
          
          <section title="T2:The proxy sends a message on its own initiative">
            <t>
              The same conclusions apply as in the previous scenario with the
              additional replay/reordering protection of responses.
           </t>
          </section>
          
          <section title="T3:The proxy does not forward a message">
            <t>
              This threat is identical to the previous scenario.
            </t>
          </section>
          
          <section title="T4:The proxy reads a message">
            <t>
              The same conclusions apply as in the previous scenario
              with the addition that if the Observe option is in plain text
              then it reveals information about
              the relation between different responses. The frequency of
              the observations may also reveal that the resource
              is changing. This can be mitigated by encrypting the observe option.
            </t>
          </section>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            Since caching is not beneficial in this scenario, there is no
            reason to expose the Observe option to the proxy.
          </t>
          
          <t>
            <list style="format R2.%d">
              
              <t>
                The CoAP option Observe SHALL be encrypted and integrity protected
                (T1)
              </t>
              
              <t>
                The response SHALL include a freshness parameter such that the
                client is able to verify if it has
                received a response previously or if the messages are received in
                the wrong order, i.e. replay and re-ordering protection (T1,T2)
              </t>
              
            </list>
          </t>
          
        </section>
        
      </section>
      
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->
      
      
    
      <section title="Multiple requests - one response">
        
        <t>
          In this scenario we study caching, how a proxy may serve the same
          cached response to multiple clients requesting the same
          resource.
        </t>
        
        <t>
          The caching functionality protects communication-constrained servers
          from repeated requests for the same resources, thus saving system
          resources, bandwidth, and round-trip time.
        </t>
        
        <figure>
          <artwork align="center">
            <![CDATA[
    Client A         Proxy          Server
      |               |               |
      |    Request    |    Request    |
      |-------------->|-------------->|--.
      |               |               |  |
      |<--------------|<--------------|<-'
      |    Response   |    Response   |
      |               |               |
                      |
    Client B          |               |
      |               |               |
      |    Request    |               |
      |-------------->|--.            |
      |               |  | from cache |
      |<--------------|<-'            |
      |    Response   |               |
      |               |               |]]>
          </artwork>
        </figure>
        
        <t>
          In Figure XX, Client A requests the proxy to make a certain request to
          the server and to return the server's response. The proxy
          services the request by forwarding the request message to the
          server according to the rules for forwarding. The server returns a
          cacheable response. The proxy
          stores the response in its cache, performs any necessary
          translations, and forwards it to the client. Later, client B
          makes an equivalent request to the proxy that the proxy
          services by returning the response from its cache.
        </t>
        <t>
          Cacheable responses are responses to GET requests and error
          responses of PUT/POST requests.
        </t>
        <t>
          Functional Requirements:
          <list style="symbols">
            <t>
              The proxy must be able to store cacheable responses in a
              cache. This requires the proxy to read CoAP header and options,
              and compute the cache key for a request.
            </t>
            <t>
              The proxy must be able to return a fresh response from
              its cache without contacting the server.
            </t>
          </list>
        </t>
        
        <!-- *************************************************************** -->
        
        <section title="Proxy Rules">
          
          <t>
            The proxy complies with the fowarding rules R1.1 and R1.2, see section 3.1.1.
            <list style="format PR3.%d">
              <t>
                If the proxy receives a request where the cache key matches that of a
                cached fresh response, then the proxy discards the request and replies
                with that response, else it forwards the request.
              </t>
              
              <t>
                The proxy caches and forwards cacheable responses. If there is
                already a response cached with the cache key of the corresponding
                request, then the old
                response in the cache is replaced with the new response.
              </t>
              
              <t>
                If the request contains an ETag option and the proxy has a valid
                response with that ETag, then the proxy replies to the request
                with a response with Code 2.03 (Valid).
              </t>
              
              <t>
                The proxy may adjust the Max-Age option in a response, decreasing
                its value to reflect the time spent in the cache.
              </t>
            
              
              <t>
                If the request contains an Accept option, and if there is a fresh
                response that matches the cache key for the corresponding request
                except for the Accept option, and if the Content-Format
                of the response matches that of the Accept option,
                then the proxy forwards
                the cached response to the requesting client.
              </t>
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          
          
          <t>
            In this section we analyze security for caching in more detail.
            At the end we present the security objectives.
          </t>
          
          <t>
            A caching proxy has an active role in the resource request/response
            procedure, so it is not surprising that it is necessary to make
            trade-offs between caching functionality and the protection of
            client-server interaction. Considering these trade-offs between
            caching and security there are different candidate ambition levels
            in terms of security objectives in this scenario.
          </t>
          
          <t>
            We envision three types of ambition levels:
            <list style="format %d.">
              <t>
                The most ambitious security objective would be to inhibit caching
                entirely, as discussed in Section 3.1. This is out of scope for
                the current scenario.
              </t>
              
              <t>
                At the other end, an alternative security objective is to target
                the protection of cached resource representations, i.e. GET 
                responses' payload, which is central functionality of a caching proxy.
              </t>
              
              <t>
                Somewhere in between 1. and 2. there is a setting which allow
                caching to some extent, but protects more general message exchanges
                and/or more meta-data than compared to alternative 2.
                Most of the rest of this
                section is about this alternative.
              </t>
            </list>
          </t>
          
          <t>
            The caching functionality decouples responses from requests. This
            implies that a client is not able to verify that a received
            response is generated by the server in response to a specific
            request.
          </t>
          
          
          <t>
            A client may receive a response without the server being aware
            of that the client has made a request.
            Moreover, in order to keep the cache up-to-date and thereby enable short
            round-trip times, a proxy could proactively generate requests, or observe
            resources.
            Thus the server cannot in general verify that a request originates
            from a client as a precondition to provide a response.
          </t>
          
          <t>
           Since the server is not able to verify a request, it must
            <list style="format %c.">
              <t>
                restrict what requests are allowed (otherwise it would perform any requested actions), and
              </t>
              
              <t>
                perform a default action, irrespective of authorized client, for
                protecting the response of these generally allowed requests (otherwise
                not all authorized clients would be able to read and verify the response).
              </t>
            </list>
          </t>
          
          
          <t>
            Example:
            <vspace blankLines="1"/>
            For GET requests (Alternative 2) this could be quite straightforward:
            <list style="format %c.">
              <t>
                The server restricts allowed plaintext requests to GET and
                certain resources.
              </t>
              
              <t>
                The server encrypts and integrity protects the resource representation
                with key specific for the resource and signs with its private key.
              </t>
            </list>
          </t>
          
          
          <t>
            In order for the client to process a received response correctly,
            it needs to determine for what request the response was made. For this
            purpose, information relating the request must be verifiable
            by the client receiving the response.
          </t>
          
          <t>
            In the Example above, the information relating to the request is
            pre-defined in the sense that resource representations are
            integrity protected with a certain key and signed with a certain key
            relating to a certain resource and server, respectively.
          </t>
          
          <t>
            Alternatively, it could be implicit in the sense that
            information about the request is built into the response, e.g.
            integrity protecting request information in the response (cf.
            External_AAD in COSE FIXME).
          </t>
          
          <t>
            In the following we argue that the latter would become quite complex
            in the general case and neither provides desirable properties in terms of
            security nor in terms of caching.
          </t>
 
          
          <t>
            Since there is no binding between the request and the response, 
            information about the resource and the request needs to be protected within the response. FIXME: is this sentence ok?
            In the general case, where we are not restricting to particular methods
            and resources like in the Example, this implies the need to specify selected
            parts of CoAP header, options and payload of the request
            that the client would need to cache and use to verify that a response
            is a response to a particular request.
          </t>
          
          <t>
            To complicate matters further,sSince different requests could result
            in the same response
            from the proxy cache, the request information must be canonicalized such
            that equivalent requests have identical request information, and the
            canonicalized request information must be possible to verify
            by the client receving the response.
            Additionally meta-data that is allowed to be changed by a proxy must
            be excluded from the canonicalized request information.
          </t>
          
          <t>
            If such a canonicalization would be defined, this would include
            protection of meta-data in the request and response protected in the response,
            such as for example CoAP header Code and CoAP option Uri-Path.
            However, requiring meta data to be protected conflicts with
            certain proxy rules in this scenario. PR1.3 entitles the proxy to
            provide the authoritative response Code 2.03 (Valid) to a request
            with ETag. If we require Code to be verifiable this response will be discarded,
            since a response originating from a proxy cannot be verified by the client.
            To avoid this issue requires either ETag or caching functionality to
            be reduced.
          </t>
          
          <t>
            Furthermore, a solution targeting this security objective would still not be able
            to confirm that a response was made in response to a particular request.
            Moreover, providing good privacy/confidentiality properties requires part
            of the cache key to be encrypted, reducing the efficiency
            of the caching function.
          </t>
          
          <t>
            Summarizing this discussion, we think that alternative 3. above does
            neither provide the desired caching functionality nor the security required.
            Acknowledging that the scenario in section 3.1
            targets a more ambitious security objective which can be used
            in use cases where required, we focus here on enabling the caching
            functionality and providing security to cacheable resource representations.
          </t>
          
          <t>
            The security objectives for this scenario are:
            <list style="format SO3.%d">
              <t>
                A client is able to verify that a received response contains a
                resource representation to a requested server and resource, and
                that it has not been altered in transfer.
              </t>
              
              <t>
                The server is able to protect a resource representation such
                that only authorized clients can read the representation
                and that a modification of the representation can be detected by a
                client.
              </t>
            </list>
          </t>
          
        </section>
    
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now analyze the potential threats relevant to this scenario.
          </t>
          
          
          <section title="T1:The proxy forwards a messages other than received">
            <t>
              <list style="format T1:3.%d">
                <t>
                  The proxy forwards a request with modified payload
                  <vspace blankLines="1"/>
                  GET requests does not have payload.
                </t>
                
                <t>
                  The proxy forwards a response with modified payload
                  <vspace blankLines="1"/>
                  This threat that may be mitigated with integrity protection of
                  response payload
                </t>
                
                <t>
                  The proxy forwards a request with modified CoAP option
                  <vspace blankLines="1"/>
                  Since the request is not required to be verified, we only consider
                  the impact on responses. This threat may be mitigated by
                  securely associating resource information to the representation
                  in the response.
                </t>
                
                <t>
                  The proxy forwards a response with modified CoAP option
                  <vspace blankLines="1"/>
                  This is not necessarily a threat.  For example, a proxy is
                  entitled to change Max-Age. However, changing Content-Format
                  may result in an error or the wrong interpretation of a
                  representation.  This threat may be mitigated by
                  securely associating resource information, such as Content-Format,
                  to the representation in the response
                </t>
                
                <t>
                  The proxy forwards a request with changed CoAP header fields
                  <vspace blankLines="1"/>
                  As mentioned in section 3.1, this is not necessarily a threat.
                  We consider here the impacts on the response. By changing
                  Code the response will not contain the requested resource
                  representation. However, as long as the required responses
                  allow verification of resource information the error
                  will be detected, and this threat is mainly denial-of-service.
                  Threats arising from modification of Version are difficult to
                  predict.
                </t>
                
                <t>
                  The proxy forwards a response with changed CoAP header fields
                  <vspace blankLines="1"/>
                  Similar to previous threat. Changing of Code is a denial-of-service.
                </t>
                
                <t>
                  The proxy forwards a different request
                  <vspace blankLines="1"/>
                  Modifications of payload, options and header are considered previously.
                  To mitigate wrong interpretation of a response resulting from
                  a proxy sending old requests, or reordering requests, from the
                  same client to the same server resource,
                  the response may integrity protect a
                  freshness parameter (timestamp, counter, etc.) in from which the
                  age/order can be deduced (replay/reordering protection).
                </t>


                <t>
                  The proxy forwards a response to a non-equivalent request
                  <vspace blankLines="1"/>
                  If the response is from another server it can be mitigated by
                  having different security associations with different
                  servers.  If the response is that of another resource of the
                  same server, it can be mitigated by having different security
                  associations of different resources, or by securely associating
                  resource information to the representation in the response.
                  If the response is from the right server resource, then the
                  difference is in the options or header which has been covered with
                  previous threats.
                </t>
                
                <t>
                  The proxy forwards an old response to the same resource
                  <vspace blankLines="1"/>
                  This is not necessarily a threat. The proxy is supposed to
                  send a cached response, if fresh. However, if the proxy
                  serves a stale response and manipulates the MaxAge option
                  then it may trick the client into believing it is a fresh
                  response.  Since the proxy is entitled to make such changes,
                  this is not possible to prevent. However, the server can
                  integrity protect a freshness parameter (timestamp, counter, etc.)
                  in the response which mitigates certain threats.  Note that in
                  case time synchronization cannot be assumed, the information
                  about age is limited to the order of the responses.
                </t>
                
                <t>
                  The proxy maliciously serves a response with Code 2.03
                  (Valid) to a request with an ETag option
                  <vspace blankLines="1"/>
                  This threat cannot be mitigated since the proxy is entitled
                  to perform such operation without involving the server.
                </t>
                
                <t>
                  The proxy colludes with a legitimate client having access to
                  the key used to create Message Authentication Codes (MAC) of
                  responses/resource representations to generate a valid MAC.
                  <vspace blankLines="1"/>
                  This threat applies to responses containing a message
                  authentication code (MAC) for integrity protecting the resource
                  representation.  The threat may be mitigated by the server
                  digitally signing the representation with its private key
                  instead of using a MAC.
                </t>
                
              </list>
            </t>
          </section>
          
          
          <section title="T2:The proxy sends a message on its own initiative">
            <t>
              <list style="format T2:3.%d">
                
                <t>
                  The proxy sends a request to the server without a previous
                  request from the client
                  <vspace blankLines="1"/>
                  This is not necessarily a threat, since the proxy may want to
                  keep the cache updated with fresh representations to allow
                  short round-trip time.  A proxy maliciously making requests
                  for the purpose of gaining information about the resources
                  may to some extent be mitigated by encryption, but the
                  encrypting data in the cache key may have an impact on how the
                  cache can perform its legitimate operation.
                </t>
                
                <t>
                  The proxy sends a response to the client without a previous
                  response from the server
                  <vspace blankLines="1"/>
                  This is not necessarily a threat since the proxy is allowed
                  to respond with a fresh cached response.  Other cases of
                  responding inappropriately to a client request are covered in
                  the previous section.  The client can detect the case of
                  receiving a response without having received a request.
                </t>
                
                <t>
                  A proxy sends a number of messages for the purpose of flooding
                  client or server
                  <vspace blankLines="1"/>
                  Considering that a proxy is entitled to make resource
                  requests, it may be difficult to protect the server against
                  this kind of denial-of-service attacks.  As for responses, by
                  verifying the integrity and freshness information, the client
                  may mitigate certain flooding attacks.
                </t>
              </list>
            </t>
          </section>
          
          <section title="T3:The proxy does not forward a message">
            <t>
              <list style="format T3:3.%d">
                <t>
                  The proxy does not forward a message
                  <vspace blankLines="1"/>
                  This is not necessarily a threat. According to the
                  forwarding rule, the proxy must not forward a request if
                  there is a fresh cached response. If the proxy does not
                  forward a request although there is no valid cache response,
                  then this is a denial-of-service attack, and likewise if the
                  proxy does not propagate a response. While these threats may
                  be difficult to mitigate, missing messages are common in
                  lossy environments so applications should have a readiness
                  for this kind of issue.
                </t>
                
                <t>
                  The proxy delays forwarding of a received message
                  <vspace blankLines="1"/>
                  Delayed forwarding may be a denial of service attack, similar
                  to not forwarding. Certain delays may be legitimate so it
                  may be difficult to detect and mitigate.
                  Delayed requests and responses can also be used in
                  attacks against actuators as is discussed in Section 3.1 but
                  that is out of scope for this scenario.
                </t>
                
                <t>
                  The proxy reorders the requests
                  <vspace blankLines="1"/>
                  Since the request is not required to be verified, we only consider
                  the impact on responses. This threat may be mitigated with
                  the server integrity protecting a freshness parameter in the response
                </t>
                
                <t>
                  The proxy reorders the responses
                  <vspace blankLines="1"/>
                  This threat may be mitigated with the server integrity
                  protecting a freshness parameter in the response
                </t>
                
                
              </list>
            </t>
          </section>
          
          <section title="T4:The proxy reads a message">
            <t>
              <list style="format T4:3.%d">
                <t>
                  The proxy reads a representation/payload
                  <vspace blankLines="1"/>
                  This threat can be mitigated with encryption of the
                  representation and other potential payload data
                </t>
                
                <t>
                  The proxy infers information about the nature and state of the
                  resource request/response from CoAP options and header fields.
                  <vspace blankLines="1"/>
                  The proxy needs to read the cache key for performing caching
                  operations.  Information leaking that can be inferred from such
                  data cannot be prevented.
                </t>
              </list>
            </t>
          </section>

        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            This section contains the security requirements and non-requirements
            for the caching scenario. For each requirement and non-requirement the
            associated threats are listed. The security requirements are:
            
            <list style="format R3.%d">
              <t>
                The client must be able to verify that a received resource
                representation originates from the requested server (T1:3.2, T1:3.8)
              </t>
              
              <t>
                The client must be able to verify that a received representation
                is a representation of the resource requested by the client
                (T1:3.2, T1:3.3, T1:3.7, T1:3.8)
              </t>
              
              <t>
                The client must be able to verify content format of the representation
                (T1:3.3, T1:3.4).
              </t>
              
              <t>
                The client must be able to detect if it has received this
                response previously, i.e. replay protection. (T1:3.7, T3:3.9)
              </t>
              
              <t>
                The client must be able to detect that the received resource
                representation is older than a previously received
                representation of this resource, i.e. protection from
                reordering. (T1:3.7, T1:3.9)
              </t>
              
              <t>
                The representation must be integrity protected and encrypted
                from server to client. (T1:3.2, T1:3.11, T2:3.2, T2:3.3, T4:3.1)
              </t>
              
              <t>
                To protect against the proxy colluding with an authorized client,
                asymmetric crypto is needed. (T1:3.11)
              </t>
            </list>
            The security non-requirements of the caching scenario are:
            
            <list style="format NR3.%d">
              
              <t>
                The request is not protected (See Security Objectives)
              </t>
              
              <t>
                The header and options of the response are not protected (See Security Objectives)
              </t>
              
              <t>
                The proxy may eavesdrop on meta-data including the cache key (T2:3.1, T4:3.2)
              </t>
              
              <t>
                The proxy may drop messages without being detected (T3:3.1)
              </t>
              
              <t>
                The proxy may delay messages without being detected (T3:3.2)
              </t>
            </list>
            
          </t>
        </section>
        
      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->

      
      <section title="Multiple requests - multiple responses: Observe">
        
        <t>
          This scenario adds to the previous the capability to notify a client
          when a resource changes. The client observes a
          resource and receives notifications, which may be cached.
        </t>
        
        <t>
          This functionality protects communication-constrained servers from
          repeated requests when the resource is unchanged thus saving system
          resources and bandwidth.
        </t>
        
        <t>
          In addition to multiple clients' requests being served by one
          response, each request may result in multiple responses.
        </t>

        
        <figure>
          <artwork align="center">
            <![CDATA[
    Client          Proxy          Server
      |               |               |
      |    Request    |    Request    |
      |-------------->|-------------->|--.
      |               |               |  |
      |<--------------|<--------------|<-'
      |  Notification |  Notification |  |
      |               |               |  |
      |<--------------|<--------------|<-'
      |  Notification |  Notification |  |
      |               |               |  |
      |<--------------|<--------------|<-'
      |  Notification |  Notification |
      |               |               |
            
      FIXME: Add caching to the figure
            ]]>
          </artwork>
        </figure>
        
        <t>
          The server exposes an observable resource (e.g., the current
          reading of a temperature sensor). Multiple clients are
          interested in the current state of the resource and observe
          it using the <xref target="RFC7641">CoAP resource observation
            mechanism</xref>. The goal is to keep the state observed by
          the clients closely in sync with the actual state of the
          resource at the server. Another goal is to minimize the
          burden on the server by moving the task to fan out
          notifications to multiple clients from the server to the
          proxy.
        </t>
        
        
        <t>
          Functional Requirements:
          <list style="symbols">
            <t>
              The proxy must be able to observe a resource on behalf of
              one or more clients.
            </t>
            <t>
              When a client registers interest in a resource with the
              proxy, the proxy must be able to return a response with
              the current state of the resource without contacting the
              server.
            </t>
          </list>
        </t>
        
        <!-- *************************************************************** -->
        
        <section title="Proxy Rules">
          <t>
            The proxy complies with the caching rules PR 3.1 - 3.5 see
            section 3.3.1. In addition the following proxy rules apply:
            <list style="format PR4.%d">
              <t>
                The proxy may modify the Observe option . . .
              </t>
              
            </list>
          </t>
          
        </section>
        
        <!-- *************************************************************** -->
        
        
        <section title="Security Objectives">
          <t>
            The security objectives are identical to the previous scenario.
          </t>
        </section>
        
        <!-- *************************************************************** -->

        <section title="Threat Analysis and Mitigation">
          <t>
            We now analyze the potential threats
          </t>
          
          <section title="T1:The proxy forwards a message other than received">
            <t>
              TBD
            </t>
          </section>
          
          <section title="T2:The proxy sends a message on its own initiative">
            <t>
              TBD
            </t>
          </section>
          
          <section title="T3:The proxy does not forward a message">
            <t>
              TBD
            </t>
          </section>
          
          <section title="T4:The proxy reads a message">
            <t>
              TBD
            </t>
          </section>
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Requirements">
          <t>
            TBD
          </t>
        </section>

      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->

      
      <section title="Multiple requests - multiple responses: Publish-Subscribe">
        
        <t>
          This scenario is about the proxy acting as a broker for messages from
          a publisher to a subscriber. The subscriber subscribes to the broker
          and receives a fresh cached response. Subsequent publications are
          fanned out from the publisher to all subscribers by
          the broker/proxy.
        </t>
        
        
        <figure>
          <artwork align="center">
            <![CDATA[
   Subscribers      Proxy          Publisher
   (Client A)      (Server)        (Client)
      |               |               |
      |               |    Publish    |
      |               |<--------------|
      |         Cache |               |
      |               |               |
      |  Subscribe    |               |
      |-------------->|--.            |
      |               |  | from cache |
      |<--------------|<-'            |
      |  Notification |               |
      |               |               |
                      |               |
   (Client B)         |               |
      |               |               |
      |  Subscribe    |               |
      |-------------->|--.            |
      |               |  | from cache |
      |<--------------|<-'            |
      |  Notification |               |
      |               |               |
      |               |    Publish    |
      |               |<--------------|
      |         Cache |               |
      |               |               |
      |<--------------|               |
      |  Notification |               |
                      |               |
   (Client A)         |               |
      |               |               |
      |<--------------|               |
      |  Notification |               |
      |               |               |
      |               |               |]]>
          </artwork>
        </figure>
        
       <!-- *************************************************************** -->
        
        <section title="Proxy Rules">
          
          <t>
            TBD
          </t>
        
        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Security Objectives">
          <t>
            TBD
          </t>

        </section>
        
        <!-- *************************************************************** -->
        
        <section title="Threat Analysis and Mitigation">
          <t>
            We now analyze the potential threats
          </t>
          
          <section title="T1:The proxy forwards a message other than received">
            <t>
              TBD
            </t>
          </section>
        
          <section title="T2:The proxy sends a message on its own initiative">
            <t>
              TBD
            </t>
          </section>
          
          <section title="T3:The proxy does not forward a message">
            <t>
              TBD
            </t>
          </section>
          
          <section title="T4:The proxy reads a message">
            <t>
              TBD
            </t>
          </section>
        </section>
        
        <!-- *************************************************************** -->
        
 
        <section title="Security Requirements">
          <t>
            TBD
          </t>
        </section>
        
      </section>
      
      <!-- **************************************************************** -->
      <!-- **************************************************************** -->


      
    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Security Considerations">

      <t>
        This document is about security; as such, there are no
        additional security considerations.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="IANA Considerations">

      <t>
        This document includes no request to IANA.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC2119;

      &RFC7252;
      &RFC7641;

    </references>

    <references title="Informative References">

      &RFC6347;

      &RFC7228;
      
      &I-D.ietf-cose-msg;

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <!--
    <section title="Acknowledgements" numbered="no">
    </section>
    -->

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
