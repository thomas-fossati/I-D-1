<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC3986 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.3986.xml">
  <!ENTITY RFC5785 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.5785.xml">
  <!ENTITY RFC6415 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.6415.xml">
  <!ENTITY RFC6570 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.6570.xml">
  <!ENTITY RFC6690 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.6690.xml">
  <!ENTITY RFC6838 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.6838.xml">
  <!ENTITY RFC6906 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.6906.xml">
  <!ENTITY RFC7228 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7228.xml">
  <!ENTITY RFC7230 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7230.xml">
  <!ENTITY RFC7231 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7231.xml">
  <!ENTITY RFC7252 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7252.xml">
  <!ENTITY RFC7301 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7301.xml">
  <!ENTITY RFC7320 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7320.xml">
  <!ENTITY RFC7540 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7540.xml">
  <!ENTITY RFC7595 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7595.xml">
  <!ENTITY RFC8288 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.8288.xml">
  <!ENTITY W3C.REC-xml11-20060816 SYSTEM "http://www.rfc-editor.org/refs/bibxml4/reference.W3C.REC-xml11-20060816.xml">
  <!ENTITY W3C.REC-xml-20081126 SYSTEM "http://www.rfc-editor.org/refs/bibxml4/reference.W3C.REC-xml-20081126.xml">
  <!ENTITY W3C.REC-xml-names-20091208 SYSTEM "http://www.rfc-editor.org/refs/bibxml4/reference.W3C.REC-xml-names-20091208.xml">
  <!ENTITY SELF "[RFCXXXX]">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="no"?>
<?rfc subcompact="no"?>
<?rfc symrefs="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>

<rfc category="info" docName="draft-hartke-core-apps-08" ipr="trust200902">

  <front>

    <title>CoRE Application Descriptions</title>

    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Torshamnsgatan 23</street>
          <city>Stockholm</city>
          <code>SE-16483</code>
          <country>Sweden</country>
        </postal>
        <email>klaus.hartke@ericsson.com</email>
      </address>
    </author>

    <date />

    <area>Applications</area>

    <workgroup>Thing-to-Thing Research Group</workgroup>

    <abstract>

      <t>
        The interfaces of RESTful, hypermedia-driven Web applications consist of
        reusable components such as Internet media types and link relation
        types. This document proposes CoRE Application Descriptions, a
        convention for application designers to describe the programmable
        interfaces of their applications in a structured way so that other
        parties can easily develop interoperable clients and servers or reuse
        the components in their own applications.
      </t>

    </abstract>

    <note title="Note to Readers">

      <t>
        This Internet-Draft should be discussed on the Thing-to-Thing Research
        Group (T2TRG) mailing list &lt;t2trg@irtf.org&gt;
        &lt;https://www.irtf.org/mailman/listinfo/t2trg&gt;.
      </t>

    </note>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction">

      <t>
        <xref target="REST">Representational State Transfer (REST)</xref> is an
        architectural style for distributed hypermedia systems. Over the years,
        REST has gained popularity not only as an approach for large-scale
        information dissemination, but also as the basic principle for designing
        and building Internet-based applications in general.
      </t>

      <t>
        In the coming years, the size and scope of the Internet is expected to
        greatly increase as physical-world objects become smart enough to
        communicate over the Internet -- a phenomenon known as the Internet of
        Things (IoT). As things learn to speak the languages of the net, the
        idea of applying REST principles to the design of IoT application
        architectures suggests itself. To this end, the <xref
        target="RFC7252">Constrained Application Protocol (CoAP)</xref> was
        created, an application-layer protocol that enables RESTful applications
        in <xref target="RFC7228">constrained-node networks</xref>, thus giving
        rise to a new setting for Internet-based applications: the Constrained
        RESTful Environment (CoRE).
      </t>

      <t>
        To realize the full benefits and advantages of the REST style, a set of
        constraints needs to be maintained when designing new applications and
        their application programming interfaces (APIs). One of the fundamental
        principles is that <xref target="RESTAPI">"REST APIs must be
        hypertext-driven"</xref>. This principle is often ignored by application
        designers, who instead specify their APIs out-of-band in terms of fixed
        URI patterns, e.g., in the API documentation or in a machine-readable
        format that facilitates code generation. Although this approach may
        appear easy for clients to use, the fixed resource names and data
        formats lead to a tight coupling between client and server
        implementations and make the system less flexible. Violations of REST
        design principles like this result in APIs that may not be as scalable,
        extensible, and interoperable as promised by REST <xref
        target="SDNREST"/>.
      </t>

      <t>
        REST is intended for long-lived network-based applications that span
        multiple organizations <xref target="RESTAPI"/>. Principled REST APIs
        require some design effort, since application designers do not only have
        to take current requirements into consideration, but also have to
        anticipate changes that may be required in the future -- years or even
        decades after the application has been deployed for the first time. The
        reward is long-term stability and evolvability, both of which are very
        desirable features in the Internet of Things.
      </t>

      <t>
        To aid application designers in the design process, this document
        proposes CoRE Application Descriptions, a convention for describing the
        APIs of RESTful, hypermedia-driven Web applications. CoRE Application
        Descriptions help application designers avoid common mistakes by
        focusing almost all of the descriptive effort on defining the Internet
        media type(s) that are used for representing resources and driving
        application state.
      </t>

      <t>
        A template provides a consistent format for the description of APIs so
        that implementers can easily build interoperable clients and servers and
        other application designers can reuse application components in their
        own applications.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Application Descriptions">

      <t>
        A CoRE Application Description is a named set of reusable components. It
        describes a contract between a server hosting an instance of the
        described application and clients that wish to interface with that
        instance.
      </t>

      <t>
        A CoRE Application Description is comprised of:
        <list style="symbols">
          <t>URI schemes that identify communication protocols,</t>
          <t>Internet media types that identify representation formats,</t>
          <t>link relation types that identify link semantics,</t>
          <t>form relation types that identify form semantics,</t>
          <t>variable names that identify the semantics of variables in templated links,</t>
          <t>form field names that identify the semantics of form fields in forms, and</t>
          <t>optionally, well-known locations.</t>
        </list>
        Together, these components provide the specific, in-band instructions
        for interfacing with a given application.
      </t>

      <section title="URI Schemes">

        <t>
          The foundation of a hypermedia-driven REST API are the communication
          protocol(s) spoken between a client and a server. Although <xref
          target="RFC7230">HTTP/1.1</xref> is by far the most common
          communication protocol for REST APIs, a REST API should typically not
          be dependent on any specific communication protocol.
        </t>

        <t>
          The use of a particular protocol by a client is guided by <xref
          target="RFC7595">URI schemes</xref>. URI schemes specify the syntax
          and semantics of <xref target="RFC3986">URI references</xref> that the
          server includes in links (<xref target="links"/>) and forms (<xref
          target="forms"/>).
        </t>

        <t>
          A URI scheme refers to a family of protocols, typically distinguished
          by a version number. For example, the "http" URI scheme refers to the
          two members of the HTTP family of protocols: <xref
          target="RFC7230">HTTP/1.1</xref> and <xref
          target="RFC7540">HTTP/2</xref> (as well as some predecessors). The
          specific HTTP version used is negotiated between a client and a server
          in-band using the version indicator in the HTTP request-line or the
          TLS <xref target="RFC7301">Application-Layer Protocol Negotiation
          (ALPN) extension</xref>.
        </t>

        <t>
          <list>
            <t>
              IANA maintains a list of registered URI schemes at
              &lt;http://www.iana.org/assignments/uri-schemes&gt;.
            </t>
          </list>
        </t>

      </section>

      <section title="Internet Media Types">

        <t>
          One of the most important aspect of hypermedia-driven communications
          is the concept of Internet media types <xref target="RFC6838"/>. Media
          types are used to label representations so that it is known how the
          representation should be interpreted and how it is encoded. The
          centerpiece of a CoRE Application Description should be one or more
          media types.
        </t>

        <t>
          A media type identifies a versioned series of representation formats
          (<xref target="representations"/>): a media type does not
          identify a particular version of a representation format; rather, the
          media type identifies the family, and includes provisions for version
          indicator(s) embedded in the representations themselves to determine
          more precisely the nature of how the data is to be interpreted <xref
          target="MIMEWEB"/>. A new media type is only needed to designate a
          completely incompatible format <xref target="MIMEWEB"/>.
        </t>

        <t>
          <list style="hanging">
            <t hangText="Note:">
              The terms media type and representation format are often used
              interchangeably. In this document, the term "media type" refers
              specifically to a string of characters such as "application/xml"
              that is used to label representations; the term "representation
              format" refers to the definition of the syntax and semantics of
              representations, such as <xref target="W3C.REC-xml-20081126">XML
              1.0</xref> or <xref target="W3C.REC-xml11-20060816">XML
              1.1</xref>.
            </t>
          </list>
        </t>

        <t>
          Media types consist of a top-level type and a subtype, structured into
          trees <xref target="RFC6838"/>. Optionally, media types can have
          parameters. For example, the media type "text/plain; charset=utf-8" is
          a subtype for plain text under the "text" top-level type in the
          standards tree and has a parameter "charset" with the value "utf-8".
        </t>

        <t>
          Media types can be further refined by <list style="symbols"><t>
          structured type name suffixes (e.g., "+xml" appended to the base
          subtype name; see Section 4.2.8 of <xref target="RFC6838">RFC
          6838</xref>),</t><t>a "profile" parameter (see Section 3.1 of <xref
          target="RFC6906">RFC 6906</xref>),</t><t>subtype information embedded
          in the representations themselves (e.g., "xmlns" declarations in XML
          documents <xref target="W3C.REC-xml-names-20091208"/>),</t></list> or
          a similar annotation. An annotation directly in the media type is
          generally preferable, since subtype information embedded in
          representations can typically not be negotiated during content
          negotiation (e.g., using the CoAP Accept option).
        </t>

        <t>
          In CoAP, media types are combined with <xref target="RFC7231">content
          coding information</xref> to indicate the "content format" <xref
          target="RFC7252"/> of a representation. Each content format is
          assigned a numeric identifier that can be used instead of the
          (typically much longer) textual name of the media type in
          representation formats with space constraints. The flat number space
          loses the structural information that the textual names have, however.
        </t>

        <t>
          The media type of a representation must be determined from in-band
          information (e.g., from the CoAP Content-Format option). Clients must
          not assume a structure from the application context or other
          out-of-band information.
        </t>

        <t>
          <list>
            <t>
              IANA maintains a list of registered Internet media types at
              &lt;http://www.iana.org/assignments/media-types&gt;.
            </t>
            <t>
              IANA maintains a list of registered structured suffixes at
              &lt;http://www.iana.org/assignments/media-type-structured-suffix&gt;.
            </t>
            <t>
              IANA maintains a list of registered CoAP content formats at
              &lt;http://www.iana.org/assignments/core-parameters&gt;.
            </t>
          </list>
        </t>

        <section title="Representation Formats" anchor="representations">

          <t>
            In RESTful applications, clients and servers exchange
            representations that capture the current or intended state of a
            resource and that are labeled with a media type. A representation is
            a sequence of bytes whose structure and semantics are specified by a
            representation format: a set of rules for encoding information.
          </t>

          <t>
            Representation formats should generally allow clients with different
            goals, so they can do different things with the same data. The
            specification of a representation format "describes a problem space,
            not a prescribed relationship between client and server. Client and
            server must share an understanding of the representations they're
            passing back and forth, but they don't need to have the same idea of
            what the problem is that needs to be solved."&nbsp;<xref
            target="WEBAPIS"/>
          </t>

          <t>
            Representation formats and their specifications frequently evolve
            over time. It is part of the responsibility of the designer of a new
            version to insure both forward and backward compatibility: new
            representations should work reasonably (with some fallback) with old
            processors and old representations should work reasonably with new
            processors <xref target="MIMEWEB" />.
          </t>

          <t>
            Representation formats enable hypermedia-driven applications when
            they support the expression of hypermedia controls, i.e., links
            (<xref target="links"/>) and forms (<xref target="forms"/>).
          </t>

          <!--
          <t>
            It is beyond the scope of this document to specify how hypermedia
            controls can be expressed. The appropriate syntax, when available,
            is described by the representation format specification associated
            with each media type.
          </t>
          -->

        </section>

        <section title="Links" anchor="links">

          <t>
            As described in <xref target="RFC8288">RFC 8288</xref>, a link is a
            typed connection between two resources. Additionally, a link is the
            primary means for a client to navigate from one resource to another.
          </t>

          <t>
            A link is comprised of:
            <list style="symbols">
              <t>
                a link context (usually the "current" resource),
              </t>
              <t>
                a link relation type that identifies the semantics of the link
                (see <xref target="link-relations"/>),
              </t>
              <t>
                a link target, identified by a URI, and
              </t>
              <t>
                optionally, target attributes that further describe the link or
                the link target.
              </t>
            </list>
          </t>

          <t>
            A link can be viewed as a statement of the form "{link context} has
            a {link relation type} resource at {link target}, which has {target
            attributes}" <xref target="RFC8288"/>. For example, the resource
            &lt;http://example.com/&gt; could have a "terms-of-service" resource
            at &lt;http://example.com/tos&gt;, which has a representation with
            the media type "text/html".
          </t>

          <t>
            There are two special kinds of links:
            <list style="symbols">
              <t>
                An embedding link is a link with an additional hint: when the
                link is processed, it should be substituted with the
                representation of the referenced resource rather than cause the
                client to navigate away from the current resource. Thus,
                traversing an embedding link adds to the current state rather
                than replacing it.
                <vspace blankLines="1"/>
                The most well known example for an embedding link is the HTML
                &lt;img&gt; element. When a Web browser processes this element,
                it automatically dereferences the "src" and renders the
                resulting image in place of the &lt;img&gt; element.
              </t>
              <t>
                A templated link is a link where the client constructs the link
                target URI from provided in-band instructions. The specific
                rules for such instructions are described by the representation
                format. <xref target="RFC6570">URI Templates</xref> provide a
                generic way to construct URIs through variable expansion.
                <vspace blankLines="1"/>
                Templated links allow a client to construct resource URIs
                without being coupled to the resource structure at the server,
                provided that the client learns the template from a
                representation sent by the server and does not have the template
                hard-coded.
              </t>
            </list>
          </t>

        </section>

        <section title="Forms" anchor="forms">

          <t>
            A form is the primary means for a client to submit information to a
            server, typically in order to change resource state.
          </t>

          <t>A form is comprised of:
            <list style="symbols">
              <t>
                a form context (usually the "current" resource),
              </t>
              <t>
                a form relation type that identifies the semantics of the form
                (see <xref target="form-relations"/>),
              </t>
              <t>
                a form target, identified by a URI,
              </t>
              <t>
                a submission method (PUT, POST, PATCH, FETCH, or DELETE),
              </t>
              <t>
                a description of a representation that the server expects as
                part of the form submission, and
              </t>
              <t>
                optionally, target attributes that further describe the form or
                the form target.
              </t>
            </list>
            A form can be viewed as an instruction of the form "To {form
            relation type} the {form context}, make a {method} request to {form
            target}, which has {target attributes}". For example, to "update"
            the resource &lt;http://example.com/config&gt;, a client could be
            required to make a PUT request to &lt;http://example.com/config&gt;.
            (In many cases, the target of a form is the same resource as the
            context, but this is not required.)
          </t>

          <t>
            The description of the expected representation can be a set of form
            fields (see <xref target="form-fields"/>) or simply a list of
            acceptable media types.
          </t>

          <t>
            <list style="hanging">
              <t hangText="Note:">
                A form with a submission method of GET is, strictly speaking, a
                templated link, since it provides a way to construct a URI and
                does not submit a representation to the server.
               </t>
            </list>
          </t>

        </section>

      </section>

      <section title="Link Relation Types" anchor="link-relations">

        <t>
          A link relation type identifies the semantics of a link <xref
          target="RFC8288"/>. For example, a link with the relation type
          "copyright" indicates that the resource identified by the target URI
          is a statement of the copyright terms applying to the link context.
        </t>

        <t>
          Relation types are not to be confused with media types; they do not
          identify the format of the representation that results when the link
          is dereferenced <xref target="RFC8288"/>. Rather, they only describe
          how the link context is related to another resource <xref
          target="RFC8288"/>.
        </t>

        <t>
          <list>
            <t>
              IANA maintains a list of registered link relation types at
              &lt;http://www.iana.org/assignments/link-relations&gt;.
            </t>
          </list>
        </t>

        <t>
          Applications that don't wish to register a link relation type can use
          an extension link relation type <xref target="RFC8288"/>, which is a
          URI that uniquely identifies the link relation type. For example, an
          application can use the string "http://example.com/foo" as link
          relation type without having to register it. Using a URI to identify
          an extension link relation type, rather than a simple string, reduces
          the probability of different link relation types using the same
          identifiers.
        </t>

      <section title="Template Variable Names">

        <t>
          A templated link enables clients to construct the target URI of a
          link, for example, when the link refers to a space of resources rather
          than a single resource. The most prominent mechanisms for this are
          <xref target="RFC6570">URI Templates</xref> and the HTML &lt;form&gt;
          element with a submission method of GET.
        </t>

        <t>
          To enable an automated client to construct an URI reference from a URI
          Template, the name of the variable in the template can be used to
          identify the semantics of the variable. For example, when retrieving
          the representation of a collection of temperature readings, a variable
          named "threshold" could indicate the variable for setting a threshold
          of the readings to retrieve.
        </t>

        <t>
          Template variable names are scoped to link relation types, i.e., two
          variables with the same name can have different semantics if they
          appear in links with different link relation types.
        </t>

      </section>

      </section>

      <section title="Form Relation Types" anchor="form-relations">

        <t>
          A form relation type identifies the semantics of a form. For example,
          a form with the form relation type "create-item" indicates that a new
          item can be created within the form context by making a request to the
          resource identified by the target URI.
        </t>

        <t>
          Similar to extension link relation types, applications can use
          extension form relation types when they don't wish to register a form
          relation type.
        </t>

      <section title="Form Field Names" anchor="form-fields">

        <t>
          Forms can have a detailed description of the representation expected
          by the server as part of form submission. This description typically
          consists of a set of form fields where each form field is comprised of
          a field name, a field type, and optionally a number of attributes such
          as a default value, a validation rule or a human-readable label.
        </t>

        <t>
          To enable an automated client to fill out a form, the field name can
          be used to identify the semantics of the form field. For example, when
          controlling a smart light bulb, the field name "brightness" could
          indicate the field for setting the desired brightness of the light
          bulb.
        </t>

        <t>
          Field names are scoped to form relation types, i.e., two form fields
          with the same name can have different semantics if they appear in
          forms with different form relation types.
        </t>

        <t>
          The type of a form field is a data type such as "an integer between 1
          and 100" or "a RGB color". The type is orthogonal to the field name,
          i.e., the type should not be determined from the field name even
          though the client can identify the semantics of the field from the
          name. This separation makes it easy to change the set of acceptable
          values in the future.
        </t>

      </section>

      </section>

      <section title="Well-Known Locations">

        <t>
          Some applications may require the discovery of information about a
          host, known as "site-wide metadata" in <xref target="RFC5785">RFC
          5785</xref>. For example, <xref target="RFC6415">RFC 6415</xref>
          defines a metadata document format for describing a host; similarly,
          <xref target="RFC6690">RFC 6690</xref> defines a link format for the
          discovery of resources hosted by a server.
        </t>

        <t>
          Applications that need to define a resource for this kind of metadata
          can register new "well-known locations". <xref target="RFC5785">RFC
          5785</xref> defines the path prefix "/.well-known/" in "http" and
          "https" URIs for this purpose. <xref target="RFC7252">RFC 7252</xref>
          extends this convention to "coap" and "coaps" URIs.
        </t>

        <t>
          <list>
            <t>
              IANA maintains a list of registered well-known URIs at
              &lt;http://www.iana.org/assignments/well-known-uris&gt;.
            </t>
          </list>
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Application Description Template">

      <t>
        As applications are implemented and deployed, it becomes important to
        describe them in some structured way. This section provides a simple
        template for CoRE Application Descriptions. A uniform structure allows
        implementers to easily determine the components that make up the
        interface of an application.
      </t>

      <t>
        The template below lists all components of applications that both the
        client and the server implementation of the application need to
        understand in order to interoperate. Crucially, items not listed in the
        template are not part of the contract between clients and servers --
        they are implementation details. This includes in particular the URIs of
        resources (see <xref target="uri-design"/>).
      </t>

      <t>
        CoRE Application Descriptions are intended to be published in
        human-readable format by designers of applications and by operators of
        deployed application instances. Application designers may publish an
        application description as a general specification of all application
        instances, so that implementers can create interoperable clients and
        servers. Operators of application instances may publish an application
        description as part of the API documentation of the service, which
        should also include instructions how the service can be located and
        which communication protocols and security modes are used.
      </t>

      <t>
        The fields of the template are as follows:
        <list style="hanging">
          <t hangText="Application name:">
            <vspace/>Name of the application. The name is not used to negotiate
            capabilities; it is purely informational. A name may include a
            version number or, for example, refer to a living standard that is
            updated continuously.
          </t>
          <t hangText="URI schemes:">
            <vspace/>URI schemes identifying the communication protocols that
            need to be understood by clients and servers. This information is
            mostly relevant for deployed instances of the application rather
            than for the general specification of the application.
          </t>
          <t hangText="Media types:">
            <vspace/>Internet media types that identify the representation
            formats that need to be understood by clients and servers. An
            application description must comprise at least one media type.
            Additional media types may be required or optional.
          </t>
          <t hangText="Link relation types:">
            <vspace/>Link relation types that identify the semantics of links.
            An application description may comprise IANA-registered link
            relation types and extension link relation types. Both may be
            required or optional.
          </t>
          <t hangText="Template variable names:">
            <vspace/>For each link relation type, variable names that identify
            the semantics of variables in templated links with that link
            relation type. Whether a template variable is required or optional
            is indicated in-band inside the templated link.
          </t>
          <t hangText="Form relation types:">
            <vspace/>Form relation types that identify the semantics of forms
            and, for each form relation type, the submission method(s) to be
            used. An application description may comprise IANA-registered form
            relation types and extension form relation types. Both may be
            required or optional.
          </t>
          <t hangText="Form field names:">
            <vspace/>For each form relation type, form field names that identify
            the semantics of form fields in forms with that form relation type.
            Whether a form field is required or optional is indicated in-band
            inside the form.
          </t>
          <t hangText="Well-known locations:">
            <vspace/>Well-known locations in the resource identifier space of
            servers that clients can use to discover information given the DNS
            name or IP address of a server.
          </t>
          <t hangText="Interoperability considerations:">
            <vspace/>Any issues regarding the interoperable use of the
            components of the application should be given here.
          </t>
          <t hangText="Security considerations:">
            <vspace/>Security considerations for the security of the application
            must be specified here.
          </t>
          <t hangText="Contact:">
            <vspace/>Person (including contact information) to contact for
            further information.
          </t>
          <t hangText="Author/Change controller:">
            <vspace/>Person (including contact information) authorized to change
            this application description.
          </t>
        </list>
        Each field should include full citations for all specifications
        necessary to understand the application components.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="URI Design Considerations" anchor="uri-design">

      <t>
        <xref target="RFC3986">URIs</xref> are a cornerstone of RESTful
        applications. They enable uniform identification of resources via <xref
        target="RFC7595">URI schemes</xref> and are used every time a client
        interacts with a particular resource or when a resource representation
        references another resource.
      </t>

      <t>
        URIs often include structured application data in the path and query
        components, such as paths in a filesystem or keys in a database. It is
        common for many RESTful applications to use these structures not only
        as an implementation detail but also make them part of the public REST
        API, prescribing a fixed format for this data.
        However, there are a number of problems with this practice <xref
        target="RFC7320"/>, in particular if the application designer and the
        server owner are not the same entity.
      </t>

      <t>
        In hypermedia-driven applications, URIs are therefore not included in
        the application interface. A CoRE Application Description must not
        mandate any particular form of URI substructure.
      </t>

      <t>
        <xref target="RFC7320">RFC 7320</xref> describes the problematic
        practice of fixed URI structures in detail and provides some acceptable
        alternatives.
      </t>

      <t>
        Nevertheless, the design of the URI structure on a server is an
        essential part of implementing a RESTful application, even though it is
        not part of the application interface. The server implementer is
        responsible for binding the resources identified by the application
        designer to URIs.
      </t>

      <t>
        A good RESTful URI is:
        <list style="symbols">
          <t>
            Short. Short URIs are easier to remember and cause less overhead in
            requests and representations.
          </t>
          <t>
            Meaningful. A URI should describe the resource in a way that is
            meaningful and useful to humans.
          </t>
          <t>
            Consistent. URIs should follow a consistent pattern to make it easy
            to reason about the application.
          </t>
          <t>
            Bookmarkable. Cool URIs don't change <xref target="COOLURI"/>.
            However, in practice, application resource structures do change.
            That should cause URIs to change as well so they better reflect
            reality. Implementations should not depend on unchanging URIs.
          </t>
          <t>
            Shareable. A URI should not be context sensitive, e.g., to the
            currently logged-in user. It should be possible to share a URI with
            third parties so they can access the same resource.
          </t>
          <t>
            Extension-less. Some applications return different data for
            different extensions, e.g., for "contacts.xml" or "contacts.json".
            But different URIs imply different resources. RESTful URIs should
            identify a single resource. Different representations of the
            resource can be negotiated (e.g., using the CoAP Accept option).
          </t>
        </list>
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Security Considerations">

      <t>
        The security considerations of
        <xref target="RFC3986">RFC 3986</xref>,
        <xref target="RFC5785">RFC 5785</xref>,
        <xref target="RFC6570">RFC 6570</xref>,
        <xref target="RFC6838">RFC 6838</xref>,
        <xref target="RFC7320">RFC 7320</xref>,
        <xref target="RFC7595">RFC 7595</xref>, and
        <xref target="RFC8288">RFC 8288</xref>
        are inherited.
      </t>

      <t>
        All components of an application description are expected to contain
        clear security considerations. CoRE Application Descriptions should
        furthermore contain security considerations that need to be taken into
        account for the security of the overall application.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="IANA Considerations">

      <t>
        This document has no IANA actions.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC3986; <!--Berners-Lee-->

      &RFC6838; <!--Freed-->

      &RFC6570; <!--Gregorio-->

      &RFC5785; <!--Nottingham-->

      &RFC7320; <!--Nottingham-->

      &RFC8288; <!--Nottingham-->

      &RFC7595; <!--Thaler-->

    </references>

    <references title="Informative References">

      &RFC7540; <!--Belshe-->

      <reference anchor="COOLURI" target="http://www.w3.org/Provider/Style/URI.html">
        <front>
          <title>Cool URIs don't change</title>
          <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee" />
          <date year="1998" />
        </front>
      </reference>

      &RFC7228; <!--Bormann-->

      &W3C.REC-xml-names-20091208; <!--Bray-->

      &W3C.REC-xml-20081126; <!--Bray-->

      &W3C.REC-xml11-20060816; <!--Bray-->

      &RFC7230; <!--Fielding-->

      &RFC7231; <!--Fielding-->

      <reference anchor="REST" target="http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf">
        <front>
          <title>Architectural Styles and the Design of Network-based Software Architectures</title>
          <author initials="R." surname="Fielding" fullname="Roy Fielding">
            <organization>University of California, Irvine</organization>
          </author>
          <date year="2000" />
        </front>
        <seriesInfo name="Ph.D." value="Dissertation, University of California, Irvine"/>
        <format type="PDF" target="http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf"/>
      </reference>

      <reference anchor="RESTAPI" target="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">
        <front>
          <title>REST APIs must be hypertext-driven</title>
          <author initials="R." surname="Fielding" fullname="Roy Fielding">
            <organization>University of California, Irvine</organization>
          </author>
          <date month="October" day="20" year="2008" />
        </front>
      </reference>

      &RFC7301; <!--Friedl-->

      &RFC6415; <!--Hammer-Lahav-->

      <reference anchor="SDNREST">
        <front>
          <title>Requirements and Design Patterns for REST Northbound API in SDN</title>
          <author initials="L." surname="Li" fullname="Li Li" />
          <author initials="Z." surname="Wei" fullname="Wei Zhou" />
          <author initials="M." surname="Luo" fullname="Min Luo" />
          <author initials="W." surname="Chou" fullname="Wu Chou" />
          <date month="July" day="8" year="2016" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-li-sdnrg-design-restapi-02" />
        <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-li-sdnrg-design-restapi-02.txt" />
      </reference>

      <reference anchor="MIMEWEB">
        <front>
          <title>MIME and the Web</title>
          <author initials="L." surname="Masinter" fullname="Larry Masinter" />
          <date month="January" day="10" year="2011" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-masinter-mime-web-info-02" />
        <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-masinter-mime-web-info-02.txt" />
      </reference>

      <reference anchor="WEBAPIS">
        <front>
          <title>RESTful Web APIs</title>
          <author initials="L." surname="Richardson" fullname="Leonard Richardson"/>
          <author initials="M." surname="Amundsen" fullname="Mike Amundsen"/>
          <date day="10" month="September" year="2013"/>
        </front>
        <seriesInfo name="O'Reilly" value="Media"/>
        <seriesInfo name="ISBN" value="978-1-4493-5806-8"/>
      </reference>

      &RFC6690; <!--Shelby-->

      &RFC7252; <!--Shelby-->

      &RFC6906; <!-- Wilde -->

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Acknowledgements" numbered="no">

      <t>
        Jan Algermissen,
        Mike Amundsen,
        Mike Kelly,
        Julian Reschke,
        and Erik Wilde
        provided valuable input on link and form relation types.
      </t>

      <t>
        Thanks to
        Olaf Bergmann,
        Carsten Bormann,
        Stefanie Gerdes,
        Ari Keranen,
        Michael Koster,
        Matthias Kovatsch,
        Teemu Savolainen,
        and Bilhanan Silverajan
        for helpful comments and discussions that have shaped the
        document.
      </t>

      <t>
        Some of the text in this document has been borrowed from
        <xref target="RFC8288" />, <xref target="RFC7320" />,
        <xref target="RESTAPI" />, <xref target="SDNREST" />,
        and <xref target="MIMEWEB" />. All errors are my own.
      </t>

      <t>
        This work was funded in part by Nokia.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
