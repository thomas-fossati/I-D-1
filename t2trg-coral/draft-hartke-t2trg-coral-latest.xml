<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
  <!ENTITY RFC3629 SYSTEM "reference.RFC.3629.xml">
  <!ENTITY RFC3986 SYSTEM "reference.RFC.3986.xml">
  <!ENTITY RFC3987 SYSTEM "reference.RFC.3987.xml">
  <!ENTITY RFC4648 SYSTEM "reference.RFC.4648.xml">
  <!ENTITY RFC5234 SYSTEM "reference.RFC.5234.xml">
  <!ENTITY RFC5246 SYSTEM "reference.RFC.5246.xml">
  <!ENTITY RFC5789 SYSTEM "reference.RFC.5789.xml">
  <!ENTITY RFC5952 SYSTEM "reference.RFC.5952.xml">
  <!ENTITY RFC6573 SYSTEM "reference.RFC.6573.xml">
  <!ENTITY RFC6657 SYSTEM "reference.RFC.6657.xml">
  <!ENTITY RFC6690 SYSTEM "reference.RFC.6690.xml">
  <!ENTITY RFC6838 SYSTEM "reference.RFC.6838.xml">
  <!ENTITY RFC6903 SYSTEM "reference.RFC.6903.xml">
  <!ENTITY RFC6906 SYSTEM "reference.RFC.6906.xml">
  <!ENTITY RFC6943 SYSTEM "reference.RFC.6943.xml">
  <!ENTITY RFC7049 SYSTEM "reference.RFC.7049.xml">
  <!ENTITY RFC7228 SYSTEM "reference.RFC.7228.xml">
  <!ENTITY RFC7230 SYSTEM "reference.RFC.7230.xml">
  <!ENTITY RFC7231 SYSTEM "reference.RFC.7231.xml">
  <!ENTITY RFC7252 SYSTEM "reference.RFC.7252.xml">
  <!ENTITY RFC7320 SYSTEM "reference.RFC.7320.xml">
  <!ENTITY RFC8132 SYSTEM "reference.RFC.8132.xml">
  <!ENTITY RFC8174 SYSTEM "reference.RFC.8174.xml">
  <!ENTITY I-D.ietf-cbor-cddl SYSTEM "reference.I-D.ietf-cbor-cddl.xml">
  <!ENTITY I-D.ietf-core-links-json SYSTEM "reference.I-D.ietf-core-links-json.xml">
  <!ENTITY I-D.nottingham-rfc5988bis SYSTEM "reference.I-D.nottingham-rfc5988bis.xml">
  <!ENTITY W3C.REC-html51-20161101 SYSTEM "reference.W3C.REC-html51-20161101.xml">
  <!ENTITY W3C.REC-rdf11-concepts-20140225 SYSTEM "reference.W3C.REC-rdf11-concepts-20140225.xml">
  <!ENTITY W3C.REC-turtle-20140225 SYSTEM "reference.W3C.REC-turtle-20140225.xml">
  <!ENTITY W3C.REC-webarch-20041215 SYSTEM "reference.W3C.REC-webarch-20041215.xml">
  <!ENTITY W3C.REC-xml-20081126 SYSTEM "reference.W3C.REC-xml-20081126.xml">
  <!ENTITY W3C.REC-xml-names-20091208 SYSTEM "reference.W3C.REC-xml-names-20091208.xml">
  <!ENTITY SELF "[I-D.hartke-t2trg-coral]">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>

<rfc category="exp" docName="draft-hartke-t2trg-coral-04" ipr="trust200902">

  <front>

    <title abbrev="Constrained RESTful Application Language">
      The Constrained RESTful Application Language (CoRAL)
    </title>

    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63905</phone>
        <email>hartke@tzi.org</email>
      </address>
    </author>

    <date/>

    <workgroup>Thing-to-Thing Research Group</workgroup>

    <abstract>

      <t>
        The Constrained RESTful Application Language (CoRAL) defines a data
        model and interaction model as well as two specialized serialization
        formats for the description of typed connections between resources on
        the Web ("links"), possible operations on such resources ("forms"), and
        simple resource metadata.
      </t>

    </abstract>

    <note title="Discussion Venue">

      <t>
        This Internet-Draft is discussed on the Thing-to-Thing Research Group
        (T2TRG) mailing list
        &lt;https://www.irtf.org/mailman/listinfo/t2trg&gt;.
      </t>

    </note>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction" anchor="introduction">

      <t>
        The Constrained RESTful Application Language (CoRAL) is a language for
        the description of typed connections between resources on the Web
        ("links"), possible operations on such resources ("forms"), as well as
        simple resource metadata.
      </t>

      <t>
        CoRAL is intended for driving automated software agents that navigate a
        Web application based on a standardized vocabulary of link and form
        relation types. CoRAL is designed to be used in conjunction with a Web
        transfer protocol such as the <xref target="RFC7230">Hypertext Transfer
        Protocol (HTTP)</xref> or the <xref target="RFC7252">Constrained
        Application Protocol (CoAP)</xref>.
      </t>

      <t>
        This document defines the CoRAL data and interaction model as well as
        two specialized CoRAL serialization formats.
      </t>

      <t>
        The CoRAL data and interaction model is a superset of the Web linking
        model described in <xref target="I-D.nottingham-rfc5988bis">RFC
        5988</xref>. The data model consists of two elements:
        <spanx>links</spanx>, which describe relationships between pairs of
        resources and the type of those relationships, and <spanx>forms</spanx>,
        which describe possible operations on resources and the type of those
        operations. Additionally, the model can describe simple resource
        metadata in a style similar to the <xref
        target="W3C.REC-rdf11-concepts-20140225">Resource Description Framework
        (RDF)</xref>. In contrast to RDF, the focus of CoRAL however is on the
        interaction with resources, not just on the relationships between them.
        The interaction model derives from <xref
        target="W3C.REC-html51-20161101">HTML 5</xref> and specifies how an
        automated software agent can navigate between resources by following
        links and perform operations on resources by submitting forms.
      </t>

      <t>
        The primary CoRAL serialization format is a compact, binary encoding of
        links and forms in <xref target="RFC7049">Concise Binary Object
        Representation (CBOR)</xref>. It is intended for <xref
        target="RFC7228">environments with constraints on power, memory, and
        processing resources</xref> and shares many similarities with the
        message format of the <xref target="RFC7252">Constrained Application
        Protocol (CoAP)</xref>: It uses numeric identifiers instead of verbose
        strings for link and form relation types and pre-parses URIs into (what
        CoAP considers to be) their components, which simplifies URI processing
        greatly. As a result, link serializations are often much more compact
        than equivalent serializations in <xref target="RFC6690">CoRE Link
        Format</xref>, including <xref target="I-D.ietf-core-links-json">its
        CBOR variant</xref>. Additionally, the format supports the serialization
        of forms, which the CoRE Link Format does not support.
      </t>

      <t>
        The second serialization format is a light, textual encoding of links
        and forms that is intended to be easy to read and write by humans. The
        format is used for giving examples throughout the document and is
        stylistically similar to <xref
        target="W3C.REC-turtle-20140225">Turtle</xref>, although it is not a
        syntax for RDF.
      </t>

      <!--
      <t>
        <xref target="examples"/> presents some examples.
        <xref target="model"/> specifies the CoRAL data and interaction model.
        <xref target="binary"/> specifies the CoRAL binary format based on CBOR.
        <xref target="textual"/> specifies the CoRAL textual format.
      </t>
      -->

      <section title="Requirements Notation">

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
          "OPTIONAL" in this document are to be interpreted as described in
          <xref target="RFC2119">BCP 14</xref> <xref target="RFC8174"/> when,
          and only when, they appear in all capitals, as shown here.
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Examples" anchor="examples">

      <section title="Web Linking">

        <t>
          At its core, CoRAL is just yet another serialization format for Web
          links. For example, if an HTTP client sends the following request:
        </t>

<figure><artwork><![CDATA[
   GET /TheBook/chapter3 HTTP/1.1
   Host: example.com
]]></artwork></figure>

        <t>
          and receives the following response:
        </t>

<figure><artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: text/coral

   #using <http://www.iana.org/assignments/relation/>

   next    <./chapter4>
   icon    </favicon.png>
   license <http://creativecommons.org/licenses/by/4.0/>
]]></artwork></figure>

        <t>
          then the representation contains the following three links:
          <list style="symbols">
            <t>
              one link of type "http://www.iana.org/assignments/relation/next"
              from &lt;http://example.com/TheBook/chapter3&gt; to
              &lt;http://example.com/TheBook/chapter4&gt;,
            </t>
            <t>
              one link of type "http://www.iana.org/assignments/relation/icon"
              from &lt;http://example.com/TheBook/chapter3&gt; to
              &lt;http://example.com/favicon.png&gt;, and
            </t>
            <t>
              one link of type
              "http://www.iana.org/assignments/relation/license" from
              &lt;http://example.com/TheBook/chapter3&gt; to
              &lt;http://creativecommons.org/licenses/by/4.0/&gt;.
            </t>
          </list>
        </t>

        <t>
          This representation is equivalent to the following <xref
          target="I-D.nottingham-rfc5988bis">Link header field</xref>:
        </t>

<figure><artwork><![CDATA[
   Link: <./chapter4>; rel="next",
         </favicon.png>; rel="icon",
         <http://creativecommons.org/licenses/by/4.0/>; rel="license"
]]></artwork></figure>

        <t>
          and the following <xref target="W3C.REC-html51-20161101">HTML 5</xref>
          link elements:
        </t>

<figure><artwork><![CDATA[
   <link rel="next" href="./chapter4">
   <link rel="icon" href="/favicon.png">
   <link rel="license"
         href="http://creativecommons.org/licenses/by/4.0/">
]]></artwork></figure>

      </section>

      <section title="Links, Forms, and Metadata">

        <t>
          In its entirety, CoRAL is an expressive language for describing Web
          links between resources, possible operations on these resources, and
          simple resource metadata. For example, if an HTTP client sends the
          following request:
        </t>

<figure><artwork><![CDATA[
   GET /tasks HTTP/1.1
   Host: example.com
]]></artwork></figure>

        <t>
          and receives the following response:
        </t>

<figure><artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: text/coral

   #using <http://example.org/vocabulary#>
   #using coral = <urn:ietf:rfc:XXXX#>

   task </tasks/1> {
      description "Pick up the kids"
   }

   task </tasks/2> {
      description "Return the books to the library"
      coral:delete -> DELETE </tasks/2>
   }

   coral:create -> POST </tasks> [coral:accept "example/task"]
]]></artwork></figure>

        <t>
          then the representation contains the following six elements:
          <list style="symbols">
            <t>
              one link of type "http://example.org/vocabulary#task" from
              &lt;http://example.com/tasks&gt; to
              &lt;http://example.com/tasks/1&gt;,
            </t>
            <t>
              one link of type "http://example.org/vocabulary#description" from
              &lt;http://example.com/tasks/1&gt; to "Pick up the kids",
            </t>
            <t>
              one link of type "http://example.org/vocabulary#task" from
              &lt;http://example.com/tasks&gt; to
              &lt;http://example.com/tasks/2&gt;,
            </t>
            <t>
              one link of type "http://example.org/vocabulary#description" from
              &lt;http://example.com/tasks/2&gt; to "Return the books to the
              library",
            </t>
            <t>
              one form of type "urn:ietf:rfc:XXXX#delete" that can be used to
              delete &lt;http://example.com/tasks/2&gt; by making a DELETE
              request to &lt;http://example.com/tasks/2&gt;, and
            </t>
            <t>
              one form of type "urn:ietf:rfc:XXXX#create" that can be used to
              create a new item in &lt;http://example.com/tasks&gt; by making a
              POST request to &lt;http://example.com/tasks&gt; with an
              "example/task" payload.
            </t>
          </list>
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Data and Interaction Model" anchor="model">

      <t>
        The Constrained RESTful Application Language (CoRAL) is designed for
        building <xref target="W3C.REC-webarch-20041215">Web-based
        applications</xref> in which automated software agents navigate between
        resources by following links and perform operations on resources by
        submitting forms.
      </t>

      <section title="Browsing Context">

        <t>
          Borrowing from <xref target="W3C.REC-html51-20161101">HTML 5</xref>,
          each such agent maintains a <spanx>browsing context</spanx> in which
          the representations of Web resources are processed. (In HTML 5, the
          browsing context typically corresponds to a tab or window in a Web
          browser.)
        </t>

        <t>
          A browsing context has a <spanx>session history</spanx>, which lists
          the resource representations that the agent has processed, is
          processing, or will process. At any time, one representation in each
          browsing context is designated the <spanx>active</spanx>
          representation.
        </t>

        <t>
          A session history consists of a flat list of session history entries.
          Each <spanx>session history entry</spanx> consists of a resource
          representation and the <xref target="RFC3987">Internationalized
          Resource Identifier (IRI)</xref> that was used to retrieve the
          representation. An entry may additionally have other information
          associated with it. New entries are added to the session history as
          the agent navigates from resource to resource.
        </t>

      </section>

      <section title="Documents">

        <t>
          A resource representation in one of the CoRAL serialization formats is
          called a CoRAL <spanx>document</spanx>. The IRI that was used to
          retrieve a document is called the document's <spanx>retrieval
          context</spanx>.
        </t>

        <t>
          A CoRAL document consists of a list of zero or more links and forms,
          collectively called <spanx>elements</spanx>. CoRAL serialization
          formats may define additional types of elements for efficiency or
          convenience, such as a base IRI for relative IRI references.
        </t>

      </section>

      <section title="Links">

        <t>
          A <spanx>link</spanx> describes a relationship between two resources
          on the Web. It consists of a <spanx>link context</spanx>, a
          <spanx>link relation type</spanx>, and a <spanx>link target</spanx>. A
          link may additionally have a nested list of zero or more elements,
          which take the place of link target attributes in CoRAL.
        </t>

        <t>
          A link can be viewed as a statement of the form "<spanx>link
          context</spanx> has a <spanx>link relation type</spanx> resource at
          <spanx>link target</spanx>", where the link target may be further
          described by nested links and forms.
        </t>

        <t>
          The link relation type identifies the semantics of a link. In HTML 5
          and RFC 5988 Link headers, a link relation type is typically denoted
          by a registered name, such as "stylesheet" or "icon". In CoRAL, a link
          relation type is denoted by an IRI or an unsigned integer. IRIs allow
          the creation of new, unique relation types in a decentralized fashion,
          but impose some overhead on the size of representations. Unsigned
          integers on the other hand minimize the overhead of link relation
          types in constrained environments, but necessitate the assignment of
          values by a registry.
        </t>

        <t>
          The link context and the link target are both resources. Resources in
          CoRAL are denoted either by an IRI reference or a literal, similar to
          RDF. If the scheme of the IRI indicates a Web transfer protocol such
          as HTTP or CoAP, then an agent can dereference the IRI and navigate
          their browsing context to the referenced resource; this is called
          <spanx>following the link</spanx>. A literal directly identifies a
          value. CoRAL supports Boolean values, integers, floating-point values,
          byte strings, and text strings as literals.
        </t>

        <t>
          A link can occur as a top-level element in a document or as a nested
          element within a link. When a link occurs as a top-level element in a
          document, the link context is implicitly the document's retrieval
          context. When a link occurs within a link, the link context of the
          inner link is the link target of the outer link.
        </t>

        <t>
          There are no restrictions on the cardinality of links; there can be
          multiple links to and from a particular target, and multiple links of
          the same or different types between a given link context and target.
          However, the CoRAL data model constrains the description of a web of
          resources to a graph in tree shape: Links between linked resources can
          only be described by further nesting links.
        </t>

      </section>

      <section title="Forms">

        <t>
          A <spanx>form</spanx> provides instructions to an agent for performing
          an operation on a Web resource. It consists of a <spanx>form
          context</spanx>, a <spanx>form relation type</spanx>, a <spanx>request
          method</spanx>, and a <spanx>submission IRI</spanx>. Additionally, a
          form MAY be accompanied by <spanx>form data</spanx>.
        </t>

        <t>
          A form can be viewed as an instruction of the form "To perform a
          <spanx>form relation type</spanx> operation on <spanx>form
          context</spanx>, make a <spanx>request method</spanx> request to
          <spanx>submission IRI</spanx>", where the payload of the request may
          be further described by form data.
        </t>

        <t>
          The form relation type identifies the semantics of the operation. Like
          link relation types, the form relation type can be denoted by an IRI
          or an unsigned integer. Link and form relation types constitute
          different namespaces, though.
        </t>

        <t>
          The form context is the resource on which an operation is ultimately
          performed. To perform the operation, an agent must construct a request
          with the specified request method and submission IRI. The set of
          possible request methods is defined by the protocol identified by the
          scheme of the submission IRI. The submission IRI typically refers to
          the form context, but MAY refer to a different resource. Constructing
          and sending the request is called _submitting the form_.
        </t>

        <t>
          If a form is accompanied by form data (see <xref target="form-data"/>
          below), the agent MUST also construct and include a payload in the
          request that matches the specifications of the form data when
          submitting the form.
        </t>

        <t>
          A form can occur as a top-level element in a document or as a nested
          element within a link. When a form occurs as a top-level element in a
          document, the form context is implicitly the document's retrieval
          context. When a form occurs within a link, the form context is the
          link target of the enclosing link.
        </t>

      </section>

      <section title="Form Data" anchor="form-data">

        <t>
          Form data provides instructions for agents to construct a request
          payload. It consists of a list of zero or more <spanx>form
          fields</spanx>. Each form field consists of a <spanx>form field
          name</spanx> and a <spanx>form field value</spanx>.
        </t>

        <t>
          Form fields can either directly identify data items that need to be
          included in the request payload or reference an external resource
          (such as a schema) that describes the data. Additionally, they can
          provide other information, such as acceptable serialization formats.
        </t>

        <t>
          The form field name identifies the semantics of the form field. Like
          link and form relation types, a form field name is denoted by an IRI
          or an unsigned integer.
        </t>

        <t>
          The form field value can be an IRI, a Boolean value, an integer, a
          floating-point value, a byte string, or a text string.
        </t>

      </section>

      <section title="Navigation">

        <t>
          An agent begins interacting with an application through a GET request
          on an <spanx>entry point IRI</spanx>. The entry point IRI is the only
          IRI an agent is expected to know before interacting with an
          application. From there, the agent is expected to make all requests by
          following links and submitting forms that are provided by the server
          in responses. The entry point IRI can be obtained by manual
          configuration or some discovery process.
        </t>

        <t>
          If dereferencing the entry point IRI yields a CoRAL document or any
          other representation that implements the CoRAL data and interaction
          model, then the agent proceeds as follows:
          <list style="numbers">
            <t>
              The first step for the agent is to decide what to do next, i.e.,
              which type of link to follow or form to submit, based on the link
              relation types and form relation types it understands.
            </t>
            <t>
              The agent finds the link(s) or form(s) with the given relation
              type in the active representation. This may yield one or more
              candidates, from which the agent must select the most appropriate
              one in the next step. The set of candidates MAY be empty, for
              example, if a transition is not supported or allowed.
            </t>
            <t>
              The agent selects one of the candidates based on the metadata
              associated with the link(s) or form(s). Metadata typically
              includes the media type of the target resource representation, the
              IRI scheme, the request method, and other information that
              describe the element.
            </t>
            <t>
              The agent resolves the IRI reference in the link or form to obtain
              the <spanx>request IRI</spanx>. Fragment identifiers are not part
              of the request IRI and MUST be separated from the rest of the IRI
              prior to a dereference. The request IRI may need to be converted
              to a URI (see Section 3.1 of <xref target="RFC3987">RFC
              3987</xref>) for protocols that do not support IRIs.
            </t>
            <t>
              The agent constructs a new request with the request IRI. If the
              agent follows a link, the request method MUST be GET. If the agent
              submits a form, the request method MUST be the one specified in
              the form. The agent SHOULD set HTTP header fields and CoAP request
              options according to provided metadata (e.g., set the HTTP Accept
              header field or the CoAP Accept option when the media type of the
              target resource is provided). In the case of a form with form
              data, the agent MUST include a request payload that matches the
              specifications of the form data.
            </t>
            <t>
              The agent sends the request and retrieves the response.
            </t>
            <t>
              If a fragment identifier was separated from the request IRI, the
              agent dereferences the fragment identifier within the retrieved
              representation.
            </t>
            <t>
              The agent <spanx>updates the session history</spanx>: It removes
              all the entries in the browsing context's session history after
              the current entry. Then it appends a new entry at the end of the
              history representing the new resource.
            </t>
            <t>
              Finally, if response contains a CoRAL document, the agent can
              again decide what to do next.
            </t>
          </list>
        </t>

      </section>

      <section title="History Traversal">

        <t>
          An agent can additionally navigate a browsing context by traversing
          the browsing context's session history. An agent can <spanx>traverse
          the session history</spanx> by updating the active representation to
          the that entry.
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Binary Format" anchor="binary">

      <t>
        This section defines the encoding of documents in the CoRAL binary
        format.
      </t>

      <t>
        A document in the binary format is a data item in <xref
        target="RFC7049">Concise Binary Object Representation (CBOR)</xref>. The
        structure of this data item is presented in the <xref
        target="I-D.ietf-cbor-cddl">Concise Data Definition Language
        (CDDL)</xref>.
      </t>

      <section title="Data Structure">

        <t>
          The data structure of a document in the binary format is made up of
          three kinds of elements: links and forms, as defined by the CoRAL data
          model, and base IRI directives. Base IRI directives provide a way to
          encode IRI references with a common base more efficiently.
        </t>

        <t>
          Elements are processed in the order they appear in the document.
          Document processors need to maintain an <spanx>environment</spanx>
          while iterating an array of elements. The environment consists of
          three variables: a <spanx>current context IRI</spanx>, a
          <spanx>current base IRI</spanx>, and a <spanx>current relation
          type</spanx>. The current context IRI and current base IRI are
          initially both set to the document's retrieval context. The current
          relation type is initially set to the unsigned integer zero.
        </t>

        <section title="Documents">

          <t>
            The body of a document in the binary format is encoded as an array
            of zero or more links, forms, and directives.
            <list>
              <t>body = [*(link / form / directive)]</t>
            </list>
          </t>

        </section>

        <section title="Links" anchor="binary-links">

          <t>
            A link is encoded as an array that consists of the unsigned integer
            2, followed by the link relation type and the link target,
            optionally followed by a link body that contains nested elements.
            <list>
              <t>link = [link: 2, relation, target, ?body]</t>
            </list>
          </t>

          <t>
            The link relation type is encoded either as a text string containing
            an absolute IRI reference or as an (unsigned or negative) integer
            representing the difference to the current relation type. A link is
            processed by updating the current relation type to the result of
            adding the specified integer (or zero in the case of a text string)
            to the current relation type.
            <list>
              <t>relation = text / int</t>
            </list>
          </t>

          <t>
            The link target is denoted by an IRI reference or represented by a
            literal value. The IRI reference may be relative or absolute and is
            resolved against the current base IRI. The encoding of IRI
            references in the binary format is described in <xref
            target="cbor-iri"/>. The link target MAY be null, which indicates
            that the link target is an unidentified resource.
            <list>
              <t>target = iri / literal / null</t>
              <t>literal = bool / int / float / bytes / text</t>
            </list>
          </t>

          <t>
            The array of elements in the link body (if any) MUST be processed in
            a fresh environment. The current context IRI and current base IRI in
            the new environment are initially both set to the link target of the
            enclosing link. The current relation type in the new environment is
            initially set to the current relation type.
          </t>

        </section>

        <section title="Forms">

          <t>
            A form is encoded as an array that consists of the unsigned integer
            3, followed by the form relation type, the submission method, and a
            submission IRI reference, optionally followed by form data.
            <list>
              <t>form = [form: 3, relation, method, iri, ?form-data]</t>
            </list>
          </t>

          <t>
            The form relation type is encoded and processed in the same way as a
            link relation type; see <xref target="binary-links"/>.
          </t>

          <t>
            The method is encoded as a text string or an unsigned integer that
            refers to one of the request methods defined by the protocol that is
            identified by the scheme of the submission IRI. Method identifiers
            in the form of text strings are constrained to US-ASCII letters and
            are case-insensitive.
            <list>
              <t>method = text / uint</t>
            </list>
          </t>

          <t>
            For <xref target="RFC7231">HTTP</xref>, the method MUST be encoded
            as a text string; the set of possible values is maintained in the
            IANA HTTP Method Registry. For <xref target="RFC7252">CoAP</xref>,
            the method MUST be encoded as an unsigned integer (e.g., the
            unsigned integer 2 for the POST method); the set of possible values
            is maintained in the IANA CoAP Method Codes Registry.
          </t>

          <t>
            The submission IRI reference may be relative or absolute and is
            resolved against the current base IRI. The encoding of IRI
            references in the binary format is described in <xref
            target="cbor-iri"/>.
          </t>

          <section title="Form Data">

            <t>
              Form data is encoded as an array of zero or more name-value pairs.
              <list>
                <t>form-data = [*(form-field-name, form-field-value)]</t>
              </list>
              Form data (if any) MUST be processed in a fresh environment. The
              current context IRI and current base IRI in the new environment
              are initially both set to the submission IRI of the enclosing
              form. The current relation type in the new environment is
              initially set to the current relation type.
            </t>

            <t>
              A form field name is encoded and processed in the same way as a
              link relation type; see <xref target="binary-links"/>.
              <list>
                <t>form-field-name = text / uint</t>
              </list>
            </t>

            <t>
              A form field value can be an IRI reference, Boolean value,
              integer, floating-point value, byte string, or text string. An IRI
              reference may be relative or absolute and is resolved against the
              current base IRI. The encoding of IRI references in the binary
              format is described in <xref target="cbor-iri"/>.
              <list>
                <t>form-field-value = iri / bool / int / float / bytes / text</t>
              </list>
            </t>

          </section>

          <section title="Short Forms">

            <t>
              Forms in certain shapes can be encoded in a more efficient manner
              using short forms. The following short forms are available:
              <list>
                <t>form =/ [form.create: 4, ?accept: uint .size 2]</t>
                <t>form =/ [form.update: 5]</t>
                <t>form =/ [form.delete: 6]</t>
              </list>
            </t>

            <t>
              If the scheme of the submission IRI indicates HTTP, the short
              forms expand as follows:
            </t>

            <figure>
              <artwork>
   [4]     -&gt;  [3, "urn:ietf:rfc:XXXX#create", "POST", []]
   [4, x]  -&gt;  [3, "urn:ietf:rfc:XXXX#create", "POST", [],
                  ["urn:ietf:rfc:XXXX#accept", x]]
   [5]     -&gt;  [3, "urn:ietf:rfc:XXXX#update", "PUT", []]
   [6]     -&gt;  [3, "urn:ietf:rfc:XXXX#delete", "DELETE", []]
              </artwork>
            </figure>

            <t>
              If the scheme of the submission IRI indicates CoAP, the short
              forms expand as follows:
            </t>

            <figure>
              <artwork>
   [4]     -&gt;  [3, "urn:ietf:rfc:XXXX#create", 2, []]
   [4, x]  -&gt;  [3, "urn:ietf:rfc:XXXX#create", 2, [],
                  ["urn:ietf:rfc:XXXX#accept", x]]
   [5]     -&gt;  [3, "urn:ietf:rfc:XXXX#update", 3, []]
   [6]     -&gt;  [3, "urn:ietf:rfc:XXXX#delete", 4, []]
              </artwork>
            </figure>

            <t>
              The form relation types and form field names in the above
              expansions are defined in <xref target="core-vocabulary"/>.
            </t>

          </section>

        </section>

        <section title="Directives">

          <t>
            Directives provide the ability to manipulate the environment when
            processing a list of elements. There is one directive available: the
            Base URI directive.
            <list>
              <t>directive = base-directive</t>
            </list>
          </t>

          <section title="Base URI Directives">

            <t>
              A Base IRI directive is encoded as an array that consists of the
              unsigned integer 1, followed by an IRI reference.
              <list>
                <t>base-directive = [base: 1, iri]</t>
              </list>
            </t>

            <t>
              The encoding of IRI references in the binary format is described
              in <xref target="cbor-iri"/>.
            </t>

            <t>
              The directive is processed by resolving the IRI reference against
              the current context IRI and assigning the result to the current
              base IRI.
            </t>

          </section>

        </section>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Textual Format" anchor="textual">

      <t>
        This section defines the syntax of documents in the CoRAL textual format
        using two grammars: The lexical grammar defines how Unicode characters
        are combined to form line terminators, white space, comments, and
        tokens. The syntactic grammar defines how the tokens are combined to
        form documents. Both grammars are presented in <xref
        target="RFC5234">Augmented Backus-Naur Form (ABNF)</xref>.
      </t>

      <t>
        A document in the textual format is a Unicode string in a Unicode
        encoding form <xref target="UNICODE"/>. The media type for such
        documents is "text/coral". The "charset" parameter is not used; charset
        information is transported inside the document in the form of an
        OPTIONAL Byte Order Mark (BOM). The use of the <xref
        target="RFC3629">UTF-8 encoding scheme</xref>, without a BOM, is
        RECOMMENDED.
      </t>

      <section title="Lexical Structure">

        <t>
          The lexical structure of a document in the textual format is made up
          of four basic elements: line terminators, white space, comments, and
          tokens. Of these, only tokens are significant in the syntactic
          grammar. There are four kinds of tokens: identifiers, IRI references,
          literals, and punctuators.
        </t>

        <t>
          When several lexical grammar rules match a sequence of characters in a
          document, the longest match takes priority.
        </t>

        <section title="Line Terminators">

          <t>
            Line terminators divide text into lines. A line terminator is any
            Unicode character with Line_Break class BK, CR, LF, or NL. However,
            any CR character that immediately precedes a LF character is
            ignored. (This affects only the numbering of lines in error
            messages.)
          </t>

        </section>

        <section title="White Space">

          <t>
            White space is a sequence of one or more white space characters. A
            white space character is any Unicode character with the White_Space
            property.
          </t>

        </section>

        <section title="Comments">

          <t>
            Comments are sequences of characters that are ignored when parsing
            text into tokens. Single-line comments begin with the characters
            "//" and extend to the end of the line. Delimited comments begin
            with the characters "/*" and end with the characters "*/". Delimited
            comments can occupy a portion of a line, a single line, or multiple
            lines.
          </t>

          <t>
            Comments do not nest. The character sequences "/*" and "*/" have no
            special meaning within a single-line comment, and the character
            sequences "//" and "/*" have no special meaning within a delimited
            comment.
          </t>

        </section>

        <section title="Identifiers">

          <t>
            Identifier tokens are user-defined symbolic names. The rules for
            identifiers correspond exactly to those recommended by the <xref
            target="UNICODE-UAX31">Unicode Standard Annex #31</xref>: An
            identifier consists of a Unicode character in the ID_Start class
            followed by zero or more Unicode characters in the ID_Continue
            class.
            <list>
              <t>identifier = ID_Start *ID_Continue</t>
              <t>ID_Start = &lt;Any character in the ID_Start class&gt;</t>
              <t>ID_Continue = &lt;Any character in the ID_Continue class&gt;</t>
            </list>
          </t>

          <t>
            All identifiers MUST be converted into Unicode Normalization Form C
            (NFC), as defined by the <xref target="UNICODE-UAX15">Unicode
            Standard Annex #15</xref>. Comparison of identifiers is based on NFC
            and is case-sensitive (unless otherwise noted).
          </t>

        </section>

        <section title="IRI References">

          <t>
            An IRI reference is a Unicode string that conforms to the syntax
            defined in <xref target="RFC3987">RFC 3987</xref>. An IRI reference
            may be absolute or relative and may contain a fragment identifier.
            IRI references are enclosed in angle brackets ("&lt;" and "&gt;").
            <list>
              <t>iri = %x3C IRI-reference %x3E</t>
              <t>IRI-reference = &lt;Defined in RFC 3987&gt;</t>
            </list>
          </t>

        </section>

        <section title="Literals">

          <t>
            A literal is a textual representation of a value. There are six
            types of literals: Boolean, integer, floating-point, byte string,
            text string, and null.
          </t>

          <section title="Boolean Literals">

            <t>
              The case-sensitive literals "true" and "false" denote the Boolean
              values true and false, respectively.
              <list>
                <t>boolean = %x74.72.75.65 / %x66.61.6C.73.65</t>
              </list>
            </t>

          </section>

          <section title="Integer Literals">

            <t>
              Integer literals denote integer values of unspecified precision.
              By default, integer literals are expressed in decimal, but they
              can also be specified in an alternate base using a prefix. Binary
              literals begin with "0b", octal literals begin with "0o", and
              hexadecimal literals begin with "0x".
            </t>

            <t>
              Decimal literals contain the digits "0" through "9". Binary
              literals contain "0" and "1", octal literals contain "0" through
              "7", and hexadecimal literals contain "0" through "9" as well as
              "A" through "F" in upper- or lowercase.
            </t>

            <t>
              Negative integers are expressed by prepending a minus sign ("-").
              <list>
                <t>integer = [%x2D] (decimal / binary / octal / hexadecimal)</t>
                <t>decimal = 1*DIGIT</t>
                <t>binary = %x30 (%x42 / %x62) 1*BINDIG</t>
                <t>octal = %x30 (%x4F / %x6F) 1*OCTDIG</t>
                <t>hexadecimal = %x30 (%x58 / %x78) 1*HEXDIG</t>
                <t>DIGIT = %x30-39</t>
                <t>BINDIG = %x30-31</t>
                <t>OCTDIG = %x30-37</t>
                <t>HEXDIG = %x30-39 / %x41-46 / %x61-66</t>
              </list>
            </t>

          </section>

          <section title="Floating-point Literals">

            <t>
              Floating-point literals denote floating-point values of
              unspecified precision.
            </t>

            <t>
              Floating-point literals consist of a sequence of decimal digits
              followed by either a fraction, an exponent, or both. The fraction
              consists of a decimal point (".") followed by a sequence of
              decimal digits. The exponent consists of the upper- or lowercase
              letter "e" followed by an optional sign and a sequence of decimal
              digits that indicate a power of 10 by which the value preceding
              the "e" is multiplied.
            </t>

            <t>
              Negative floating-point values are expressed by prepending a minus
              sign ("-").
              <list>
                <t>floating-point = [%x2D] 1*DIGIT [fraction] [exponent]</t>
                <t>fraction = %x2E 1*DIGIT</t>
                <t>exponent = (%x45 / %x65) [%x2B / %x2D] 1*DIGIT</t>
              </list>
            </t>

            <t>
              Floating-point literals can additionally denote the special
              "Not-a-Number" (NaN) value, positive infinity, and negative
              infinity. The NaN value is produced by the case-sensitive token
              "NaN". The two infinite values are produced by the case-sensitive
              tokens "+Infinity" (or simply "Infinity") and "-Infinity".
              <list>
                <t>floating-point =/ %x4E.61.4E</t>
                <t>floating-point =/ [%x2B] %x49.6E.66.69.6E.69.74.79</t>
                <t>floating-point =/ %x2D.49.6E.66.69.6E.69.74.79</t>
              </list>
            </t>

          </section>

          <section title="Byte String Literals">

            <t>
              A byte string literal consists of a prefix and zero or more bytes
              encoded in <xref target="RFC4648">Base16, Base32, or Base64</xref>
              and enclosed in single quotes. Byte string literals encoded in
              Base16 begin with "h" or "b16", byte string literals encoded in
              Base32 begin with "b32", and byte string literals encoded in
              Base64 begin with "b64".
              <list>
                <t>bytes = base16 / base32 / base64</t>
                <t>base16 = (%x68 / %x62.31.36) SQUOTE &lt;Base16 encoded data&gt; SQUOTE</t>
                <t>base32 = %x62.33.32 SQUOTE &lt;Base32 encoded data&gt; SQUOTE</t>
                <t>base64 = %x62.36.34 SQUOTE &lt;Base64 encoded data&gt; SQUOTE</t>
                <t>SQUOTE = %x27</t>
              </list>
            </t>

          </section>

          <section title="Text String Literals">

            <t>
              A text string literal consists of zero or more Unicode characters
              enclosed in double quotes. It can include simple escape sequences
              (such as \t for the tab character) as well as hexadecimal and
              Unicode escape sequences.
              <list>
                <t>text = DQUOTE *(char / %x5C escape) DQUOTE</t>
                <t>char = &lt;Any character except %x22, %x5C, and line terminators&gt;</t>
                <t>escape = simple-escape / hexadecimal-escape / unicode-escape</t>
                <t>simple-escape = %x30 / %x62 / %x74 / %x6E / %x76</t>
                <t>simple-escape =/ %x66 / %x72 / %x22 / %x27 / %x5C</t>
                <t>hexadecimal-escape = (%x78 / %x58) 2HEXDIG</t>
                <t>unicode-escape = %x75 4HEXDIG / %x55 8HEXDIG</t>
                <t>DQUOTE = %x22</t>
              </list>
            </t>

            <t>
              An escape sequence denotes a single Unicode code point. For
              hexadecimal and Unicode escape sequences, the code point is
              expressed by the hexadecimal number following the "\x", "\X",
              "\u", or "\U" prefix. Simple escape sequences indicate the code
              points listed in <xref target="escape"/>.
            </t>

            <texttable title="Simple Escape Sequences" anchor="escape">
              <ttcol align="center">Escape Sequence</ttcol>
              <ttcol align="left">Character Name</ttcol>
              <ttcol align="left">Code Point</ttcol>

              <c>\0</c>
              <c>Null</c>
              <c>U+0000</c>
              <c>\b</c>
              <c>Backspace</c>
              <c>U+0008</c>
              <c>\t</c>
              <c>Character Tabulation</c>
              <c>U+0009</c>
              <c>\n</c>
              <c>Line Feed</c>
              <c>U+000A</c>
              <c>\v</c>
              <c>Line Tabulation</c>
              <c>U+000B</c>
              <c>\f</c>
              <c>Form Feed</c>
              <c>U+000C</c>
              <c>\r</c>
              <c>Carriage Return</c>
              <c>U+000D</c>
              <c>\"</c>
              <c>Quotation Mark</c>
              <c>U+0022</c>
              <c>\'</c>
              <c>Apostrophe</c>
              <c>U+0027</c>
              <c>\\</c>
              <c>Reverse Solidus</c>
              <c>U+005C</c>
            </texttable>

          </section>

          <section title="Null Literal">

            <t>
              The literals "null" and "?" denote the intentional absence of any
              value.
              <list>
                <t>null = %x6E.75.6C.6C / %x3F</t>
              </list>
            </t>

          </section>

        </section>

        <section title="Punctuators">

          <t>
            Punctuator tokens are used for grouping and separating.
            <list>
              <t>punctuator = "#" | ":" | "[" | "]" | "{" | "}" | "=" | "->"</t>
            </list>
          </t>

        </section>

      </section>

      <section title="Syntactic Structure">

        <t>
          The syntactic structure of a document in the textual format is made up
          of three kinds of elements: links and forms, as defined by the CoRAL
          data model, and directives. Directives provide a way to make documents
          easier to read and write by defining a base IRI for relative IRI
          references and introducing shorthands for link and form relation
          types.
        </t>

        <t>
          Elements are processed in the order they appear in the document.
          Document processors need to maintain an <spanx>environment</spanx>
          while iterating a list of elements. The environment consists of three
          variables: a <spanx>current context IRI</spanx>, a <spanx>current base
          IRI</spanx>, and a mapping from identifiers to IRIs. The current
          context IRI and current base IRI are initially both set to the
          document's retrieval context. The mapping from identifiers to IRIs is
          initially empty.
        </t>

        <section title="Documents">

          <t>
            The body of a document in the textual format consists of zero or
            more links, forms, and directives.
            <list>
              <t>body = *(link / form / directive)</t>
            </list>
          </t>

        </section>

        <section title="Links" anchor="textual-links">

          <t>
            A link consists of the link relation type, followed by the link
            target, optionally followed by a link body enclosed in curly
            brackets ("{" and "}").
            <list>
              <t>link = relation target ["{" body "}"]</t>
            </list>
          </t>

          <t>
            The link relation type is denoted either by an absolute IRI
            reference, a simple name, a qualified name, or an unsigned integer.
            <list>
              <t>relation = iri / simple-name / qualified-name / integer</t>
            </list>
            An absolute IRI reference MUST be resolved and normalized according
            to the IRI scheme. (It doesn't matter what base IRI it is resolved
            against, since it is always an absolute reference.)
          </t>

          <t>
            A simple name consists of an identifier. It is resolved to an IRI by
            looking up the empty string in the mapping from identifiers to IRIs
            in the current environment and concatenating the looked up IRI with
            the specified identifier. It is an error if the empty string is not
            present in the mapping.
            <list>
              <t>simple-name = identifier</t>
            </list>
            A qualified name consists of two identifiers separated by a colon
            (":"). It is resolved to an IRI by looking up the identifier on the
            left hand side in the mapping from identifiers to IRIs in the
            current environment and concatenating the looked up IRI with the
            identifier on the right hand side. It is an error if the identifier
            on the left hand side is not present in the mapping.
            <list>
              <t>qualified-name = identifier ":" identifier</t>
            </list>
          </t>

          <t>
            The link target is denoted by an IRI reference or represented by a
            value literal. The IRI reference may be relative or absolute and is
            resolved against the current base IRI. If the link target is null,
            the link target is an unidentified resource.
            <list>
              <t>target = iri / literal / null</t>
              <t>literal = boolean / integer / floating-point / bytes / text</t>
            </list>
          </t>

          <t>
            The list of elements in the link body (if any) MUST be processed in
            a fresh environment. The current context IRI and current base IRI in
            this environment are initially both set to the link target of the
            enclosing link. The mapping from identifiers to IRIs is initially
            set to a copy of the mapping from identifiers to IRIs in the current
            environment.
          </t>

        </section>

        <section title="Forms">

          <t>
            A form consists of the form relation type, followed by a "->" token,
            a method identifier, and a submission IRI reference, optionally
            followed by form data enclosed in square brackets ("[" and "]").
            <list>
              <t>form = relation "->" method iri ["[" form-data "]"]</t>
            </list>
          </t>

          <t>
            The form relation type is denoted in the same way as a link relation
            type; see <xref target="textual-links"/>.
          </t>

          <t>
            The method identifier refers to one of the request methods defined
            by the protocol that is identified by the scheme of the submission
            IRI. Method identifiers are constrained to US-ASCII letters and are
            case-insensitive.
            <list>
              <t>method = identifier</t>
            </list>
          </t>

          <t>
            For <xref target="RFC7231">HTTP</xref>, the set of possible method
            identifiers is maintained in the IANA HTTP Method Registry. For
            <xref target="RFC7252">CoAP</xref>, the set of possible method
            identifiers is maintained in the IANA CoAP Method Codes Registry.
          </t>

          <t>
            The submission IRI reference may be relative or absolute and is
            resolved against the current base IRI.
          </t>

          <section title="Form Data">

            <t>
              Form data consists of zero or more space-separated name-value
              pairs.
              <list>
                <t>form-data = *(form-field-name form-field-value)</t>
              </list>
            </t>

            <t>
              Form data MUST be processed in a fresh environment. The current
              context IRI and current base IRI in this environment are initially
              both set to the submission IRI of the enclosing form. The mapping
              from identifiers to IRIs is initially set to a copy of the mapping
              from identifiers to IRIs in the current environment.
            </t>

            <t>
              The form field name is denoted in the same way as a link relation
              type; see <xref target="textual-links"/>.
              <list>
                <t>form-field-name = iri / simple-name / qualified-name / integer</t>
              </list>
            </t>

            <t>
              The form field value can be an IRI reference, Boolean literal,
              integer literal, floating-point literal, byte string literal, or
              text string literal. An IRI reference may be relative or absolute
              and is resolved against the current base IRI.
              <list>
                <t>form-field-value = iri / boolean / integer</t>
                <t>form-field-value =/ floating-point / bytes / text</t>
              </list>
            </t>

          </section>

        </section>

        <section title="Directives">

          <t>
            Directives provide the ability to manipulate the environment when
            processing a list of elements. All directives start with a number
            sign ("#") followed by a directive identifier. Directive identifiers
            are constrained to US-ASCII letters and are case-insensitive.
          </t>

          <t>
            The following directives are available: Base IRI directives and
            Using directives.
            <list>
              <t>directive = base-directive / using-directive</t>
            </list>
          </t>

          <section title="Base IRI Directives">

            <t>
              A Base IRI directive consists of a number sign ("#"), followed by
              the case-insensitive identifier "base", followed by an IRI
              reference.
              <list>
                <t>base-directive = "#" "base" iri</t>
              </list>
              The directive is processed by resolving the IRI reference against
              the current context IRI and assigning the result to the current
              base IRI.
            </t>

          </section>

          <section title="Using Directives">

            <t>
              A Using directive consists of a number sign ("#"), followed by the
              case-insensitive identifier "using", optionally followed by an
              identifier and an equals sign ("="), followed by an absolute IRI
              reference. If the identifier is not specified, it is assumed to be
              the empty string.
              <list>
                <t>using-directive = "#" "using" [identifier "="] iri</t>
              </list>
              The directive is processed by resolving the IRI reference to an
              IRI, normalizing the IRI according to the IRIs scheme, and adding
              the specified identifier and resulting IRI to the mapping from
              identifiers to IRIs in the current environment. (It doesn't matter
              what the IRI reference is resolved against, since it is always an
              absolute reference.) It is an error if the identifier is already
              present in the mapping.
            </t>

          </section>

        </section>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Usage Considerations">

      <t>
        This section discusses some considerations in creating CoRAL-based
        applications and managing link and form relation types.
      </t>

      <section title="Specifying CoRAL-based Applications">

        <t>
          CoRAL-based applications implement the <xref
          target="W3C.REC-webarch-20041215">Web architecture</xref> and are
          centered around orthogonal specifications for identification,
          interaction, and representation:
          <list style="symbols">
            <t hangText="Identification:">
              Resources are identified by IRIs or represented by value literals.
            </t>
            <t hangText="Interaction:">
              Interactions are based on the hypermedia interaction model of the
              Web and the methods provided by the Web transfer protocol. The
              semantics of possible interactions are identified by link and form
              relation types.
            </t>
            <t hangText="Representation:">
              Representations are CoRAL documents encoded in the binary format
              defined in <xref target="binary"/> or the textual format defined
              in <xref target="textual"/>. Depending on the application,
              additional representation formats may be used.
            </t>
          </list>
        </t>

        <t>
          Specifications for CoRAL-based applications need to specify the
          specific protocols and vocabulary used in the application. This SHOULD
          include at least the following items:
          <list style="symbols">
            <t hangText="URI Schemes:">
              IRI schemes identifying the Web transfer protocol(s) used by the
              application.
            </t>
            <t hangText="Media Types:">
              Internet media types that identify the representation format(s)
              used by the application, including the media type(s) of the CoRAL
              serialization format(s).
            </t>
            <t hangText="Link Relation Types:">
              Link relation types that identify the semantics of links.
            </t>
            <t hangText="Form Relation Types:">
              Form relation types that identify the semantics of forms.
              Additionally, for each form relation type, the permissible request
              method(s).
            </t>
            <t hangText="Form Field Names:">
              Form field names that identify the semantics of form fields.
              Additionally, for each form field name, the permissible form field
              value(s).
            </t>
          </list>
        </t>

        <section title="Naming Resources">

          <t>
            Resource names <xref target="RFC3986"/> <xref target="RFC3987"/> are
            a cornerstone of Web-based applications. They enable uniform
            identification of resources and are used every time a client
            interacts with a server or a resource representation needs to refer
            to another resource.
          </t>

          <t>
            URIs and IRIs often include structured application data in the path
            and query components, such as paths in a filesystem or keys in a
            database. It is a common practice in many HTTP-based applications to
            make this part of the documented application interface, i.e., to
            prescribe a fixed URI template that is hard-coded in
            implementations. However, there are a number of problems with this
            practice <xref target="RFC7320"/>.
          </t>

          <t>
            In CoRAL-based applications, resource names are not part of the
            application interface; they are an implementation detail. The
            specification of a CoRAL-based application MUST NOT mandate any
            particular form of resource name structure. <xref
            target="RFC7320">RFC 7320</xref> describes the problematic practice
            of fixed URI structures in more detail and provides some acceptable
            alternatives.
          </t>

          <!--
          <t>
            Nevertheless, the design of the URI structure on a server is an
            essential part of implementing a CoRAL-based application, even
            though it is not part of the application interface. A good URI is:
            <list style="symbols">
              <t>
                Short. Short URIs are easier to remember and cause less overhead
                in requests and representations.
              </t>
              <t>
                Meaningful. A URI should describe the resource in a way that is
                meaningful and useful to humans.
              </t>
              <t>
                Consistent. URIs should follow a consistent pattern to make it
                easy to reason about the application.
              </t>
              <t>
                Bookmarkable. Cool URIs don't change <xref target="COOLURI"/>.
                However, in practice, application resource structures do change.
                That should cause URIs to change as well so they better reflect
                reality. Implementations SHOULD NOT depend on unchanging URIs.
              </t>
              <t>
                Shareable. A URI should not be context sensitive, e.g., to the
                currently logged-in user. It should be possible to share a URI
                with third parties so they can access the same resource.
              </t>
              <t>
                Extension-less. Some applications return different data for
                different extensions, e.g., for
                &lt;http://example.com/data.xml&gt; and
                &lt;http://example.com/data.json&gt;. Instead, different
                representations of a resource SHOULD be negotiated, e.g., using
                the HTTP Accept header field or the CoAP Accept option.
              </t>
            </list>
          </t>
          -->

        </section>

      </section>

      <section title="Minting New Relation Types">

        <t>
          New link relation types, form relation types, and form field names can
          be minted by defining an <xref target="RFC3987">IRI</xref> that
          uniquely identifies the item. Although the IRI can point to a resource
          that contains a definition of the semantics of the relation type,
          clients SHOULD NOT automatically access that resource to avoid
          overburdening its server. The IRI SHOULD be under the control of the
          person or party defining it, or be delegated to them.
        </t>

        <t>
          Link relation types registered in the IANA Link Relations Registry,
          such as <xref target="RFC6573">collection"</xref> or <xref
          target="W3C.REC-html51-20161101">"icon"</xref>, can be used in CoRAL
          by prepending the IRI
          &lt;http://www.iana.org/assignments/relation/&gt; to the registered
          name:
        </t>

        <figure>
          <artwork>
   #using iana = &lt;http://www.iana.org/assignments/relation/&gt;

   iana:collection &lt;/items&gt;
   iana:icon       &lt;/favicon.png&gt;
          </artwork>
        </figure>

        <t>
          A good source for link relation types for resource metadata are <xref
          target="W3C.REC-rdf11-concepts-20140225">RDF predicates</xref>. An RDF
          statement says that some relationship, indicated by a predicate, holds
          between two resources. RDF predicates and link relation types can
          therefore often be used interchangeably. For example, a CoRAL document
          could describe its maker using the <xref target="FOAF">FOAF
          vocabulary</xref> as follows:
        </t>

        <figure>
          <artwork>
   #using iana = &lt;http://www.iana.org/assignments/relation/&gt;
   #using foaf = &lt;http://xmlns.com/foaf/0.1/&gt;

   foaf:maker ? {
      iana:type       &lt;http://xmlns.com/foaf/0.1/Person&gt;
      foaf:familyName "Hartke"
      foaf:givenName  "Klaus"
      foaf:mbox       &lt;mailto:hartke@tzi.org&gt;
   }
          </artwork>
        </figure>

      </section>

      <section title="Registering Relation Types">

        <t>
          IRIs that identify link relation types, form relation types, and form
          field names do not have to be registered. The use of DNS names in them
          allows for decentralized creation of new IRIs without the risk of
          collisions. However, IRIs can be relatively verbose and can impose a
          high overhead in CoRAL representations. This can be a problem in <xref
          target="RFC7228">constrained environments</xref>.
        </t>

        <t>
          CoRAL alternatively allows the use of unsigned integers to identify
          link relation types, form relation types, and form field names. These
          impose a much smaller overhead, but need to be assigned by a registry
          to avoid collisions.
        </t>

        <t>
          This document does not create a registry for such integers. Instead,
          the media types for CoRAL documents in the binary and textual format
          are defined to have a <xref target="RFC6906">"profile"
          parameter</xref> that indicates the registry to use.
        </t>

        <t>
          The registries are identified for this purpose by a <xref
          target="RFC3986">URI</xref>. For example, a CoRAL document that uses
          the registry identified by the URI &lt;http://example.com/coral&gt;
          uses the following media type:
          <list>
            <t>application/coral+cbor; profile="http://example.com/coral"</t>
          </list>
          The URI serves only as an identifier; it does not necessarily have to
          be dereferencable (or even use a dereferencable URI scheme). It is
          permissible, though, to use a dereferencable URI and serve a
          representation that provides information about the registry in a
          human- or machine-readable way. (The format of such a representation
          is outside the scope of this document.)
        </t>

        <t>
          For simplicity, a CoRAL document can only use at most one registry at
          a time. The "profile" parameter of the CoRAL media types MUST contain
          a single URI, not a whitespace-separated list of URIs as recommended
          in <xref target="RFC6906">RFC 6906</xref>. If the "profile" parameter
          is absent, the profile specified in <xref target="default-profile"/>
          is assumed.
        </t>

        <t>
          A registry SHOULD map each unsigned integer to the full IRI that
          identifies the link relation type, form relation type, or form field
          name. The namespaces for these three kinds of identifiers are
          disjoint, i.e., the same integer may be assigned to a link relation
          type, form relation type, and form field name without ambiguity. Once
          an integer has been assigned, the assignment MUST NOT be changed or
          removed. A registry MAY provide additional information about an
          assignment (for example, whether a link relation type is deprecated).
        </t>

        <t>
          In CoAP, media types (including specific values for their parameters)
          are encoded as a small, unsigned integer, called the content format.
          For use with CoAP, each CoRAL registry needs to register a new content
          format in the IANA CoAP Content-Formats Registry. Each such registered
          content format MUST specify a CoRAL media type with a "profile"
          parameter containing the registry URI.
        </t>

      </section>

      <section title="Expressing Target Attributes">

        <t>
          Link target attributes defined for use with RFC 6690 (such as "type",
          "hreflang", "media", "ct", "rt", "if", "sz") can be expressed in CoRAL
          by nesting links under the respective link and specifying the
          attribute name appended to the IRI &lt;http://TBD/&gt;
          as the link relation type. The target of such nested links MUST be a
          text string literal:
        </t>

        <figure>
          <artwork>
   #using iana = &lt;http://www.iana.org/assignments/relation/&gt;
   #using attr = &lt;http://TBD/&gt;

   iana:item &lt;/patches/1&gt; {
      attr:type "application/json-patch+json"
      attr:ct   "51"
   }
          </artwork>
        </figure>

        <t>
          [[NOTE TO RFC EDITOR: Please replace all occurrences of
          "http://TBD/" with a RFC-Editor-controlled IRI.]]
        </t>

        <t>
          Link target attributes that actually describe the link and not the
          link target (such as "rel", "anchor", "rev", "title", and "title*") are
          excluded from this provision and MUST NOT occur in a CoRAL document.
        </t>

      </section>

      <section title="Embedding CoRAL in CBOR Structures">

        <t>
          Data items in the CoRAL binary format (<xref target="binary"/>) can be
          embedded in other <xref target="RFC7049">CBOR</xref> data structures.
          Specifications using <xref target="I-D.ietf-cbor-cddl">CDDL</xref>
          SHOULD reference the following CDDL definitions for this purpose:
          <list>
            <t>CoRAL-Body = body</t>
            <t>CoRAL-Link = link</t>
            <t>CoRAL-Form = form</t>
            <t>CoRAL-IRI = iri</t>
          </list>
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Security Considerations" anchor="security">

      <t>
        Parsers of CoRAL documents must operate on input that is assumed to be
        untrusted. This means that parsers MUST fail gracefully in the face of
        malicious inputs. Additionally, parsers MUST be prepared to deal with
        resource exhaustion that results, for example, from the allocation of
        big data items or exhaustion of the stack depth (stack overflow). See
        Section 8 of <xref target="RFC7049">RFC 7049</xref> for security
        considerations relating to parsing CBOR in particular.
      </t>

      <t>
        Implementers of the CoRAL textual format need to consider the security
        aspects of handling Unicode input. See the <xref
        target="UNICODE-UAX36">Unicode Standard Annex #36</xref> for security
        considerations relating to visual spoofing and misuse of character
        encodings. See Section 10 of <xref target="RFC3629">RFC 3629</xref> for
        security considerations relating to UTF-8.
      </t>

      <t>
        CoRAL makes extensive use of IRIs and URIs. See Section 8 of <xref
        target="RFC3987">RFC 3987</xref> for security considerations relating to
        IRIs and Section 7 of <xref target="RFC3986">RFC 3986</xref> for
        security considerations relating to URIs.
      </t>

      <t>
        CoRAL is intended to be used in conjunction with a Web transfer protocol
        such as HTTP or CoAP. See Section 9 of <xref target="RFC7230">RFC
        7320</xref>, Section 9 of <xref target="RFC7231">RFC 7231</xref>,
        etc. for security considerations relating to HTTP. See Section 11 of
        <xref target="RFC7252">RFC 7252</xref> for security considerations
        relating to CoAP.
      </t>

      <t>
        CoRAL does not define any specific mechanisms for the confidentiality
        and integrity of CoRAL documents. It relies on application layer or
        transport layer security mechanisms, such as <xref
        target="RFC5246">Transport Layer Security (TLS)</xref>.
      </t>

      <t>
        CoRAL documents and the structure of a web of resources revealed from
        automatically following links can disclose personal information and
        other sensitive information. Implementations need to prevent the
        unintentional disclosure of such information. See Section of 9 of <xref
        target="RFC7231">RFC 7231</xref> for additional considerations.
      </t>

      <t>
        The security of applications using CoRAL can depend on the proper
        preparation and comparison of internationalized strings. For example,
        such strings can be used to make authentication and authorization
        decisions, and the security of an application could be compromised if an
        entity providing a given string is connected to the wrong account or
        online resource based on different interpretations of the string. See
        <xref target="RFC6943">RFC 6943</xref> for security considerations
        relating to identifiers in IRIs and other locations.
      </t>

      <t>
        Applications using CoRAL ought to consider the attack vectors opened by
        automatically following, trusting, or otherwise using links and forms in
        CoRAL documents. In particular, a server that is authoritative for the
        CoRAL representation of a resource may not necessarily be the
        authoritative source for nested links and forms.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="IANA Considerations">

      <section title="Media Type &quot;application/coral+cbor&quot;">

        <t>
          This document registers the media type
          &quot;application/coral+cbor&quot; according to the procedures of
          <xref target="RFC6838">BCP 13</xref>.
          <list style="hanging">
            <t hangText="Type name:">
              <vspace/>application
            </t>
            <t hangText="Subtype name:">
              <vspace/>coral+cbor
            </t>
            <t hangText="Required parameters:">
              <vspace/>N/A
            </t>
            <t hangText="Optional parameters:">
              <vspace/>N/A
            </t>
            <t hangText="Encoding considerations:">
              <vspace/>binary
            </t>
            <t hangText="Security considerations:">
              <vspace/>See <xref target="security"/> of &SELF;.
            </t>
            <t hangText="Interoperability considerations:">
              <vspace/>N/A
            </t>
            <t hangText="Published specification:">
              <vspace/>&SELF;
            </t>
            <t hangText="Applications that use this media type:">
              <vspace/>See <xref target="introduction"/> of &SELF;.
            </t>
            <t hangText="Fragment identifier considerations:">
              <vspace/>As specified for "application/cbor".
            </t>
            <t hangText="Additional information:">
              <vspace/>Deprecated alias names for this type: N/A
              <vspace/>Magic number(s): N/A
              <vspace/>File extension(s): N/A
              <vspace/>Macintosh file type code(s): N/A
            </t>
            <t hangText="Person &amp; email address to contact for further information:">
              <vspace/>See the Author's Address section of &SELF;.
            </t>
            <t hangText="Intended usage:">
              <vspace/>COMMON
            </t>
            <t hangText="Restrictions on usage:">
              <vspace/>N/A
            </t>
            <t hangText="Author:">
              <vspace/>See the Author's Address section of &SELF;.
            </t>
            <t hangText="Change controller:">
              <vspace/>IESG
            </t>
            <t hangText="Provisional registration?">
              <vspace/>No
            </t>
          </list>
        </t>

      </section>

      <section title="Media Type &quot;text/coral&quot;">

        <t>
          This document registers the media type &quot;text/coral&quot;
          according to the procedures of <xref target="RFC6838">BCP 13</xref>
          and guidelines in <xref target="RFC6657">RFC 6657</xref>.
          <list style="hanging">
            <t hangText="Type name:">
              <vspace/>text
            </t>
            <t hangText="Subtype name:">
              <vspace/>coral
            </t>
            <t hangText="Required parameters:">
              <vspace/>N/A
            </t>
            <t hangText="Optional parameters:">
              <vspace/>N/A
            </t>
            <t hangText="Encoding considerations:">
              <vspace/>See <xref target="textual"/> of &SELF;.
            </t>
            <t hangText="Security considerations:">
              <vspace/>See <xref target="security"/> of &SELF;.
            </t>
            <t hangText="Interoperability considerations:">
              <vspace/>N/A
            </t>
            <t hangText="Published specification:">
              <vspace/>&SELF;
            </t>
            <t hangText="Applications that use this media type:">
              <vspace/>See <xref target="introduction"/> of &SELF;.
            </t>
            <t hangText="Fragment identifier considerations:">
              <vspace/>N/A
            </t>
            <t hangText="Additional information:">
              <vspace/>Deprecated alias names for this type: N/A
              <vspace/>Magic number(s): N/A
              <vspace/>File extension(s): .coral
              <vspace/>Macintosh file type code(s): TEXT
            </t>
            <t hangText="Person &amp; email address to contact for further information:">
              <vspace/>See the Author's Address section of &SELF;.
            </t>
            <t hangText="Intended usage:">
              <vspace/>COMMON
            </t>
            <t hangText="Restrictions on usage:">
              <vspace/>N/A
            </t>
            <t hangText="Author:">
              <vspace/>See the Author's Address section of &SELF;.
            </t>
            <t hangText="Change controller:">
              <vspace/>IESG
            </t>
            <t hangText="Provisional registration?">
              <vspace/>No
            </t>
          </list>
        </t>

      </section>

      <section title="CoAP Content Formats">

        <t>
          This document registers CoAP content formats for the media types
          &quot;application/coral+cbor&quot; and &quot;text/coral&quot;
          according to the procedures of <xref target="RFC6838">BCP 13</xref>.
          <list style="symbols">
            <t>
              Media Type: application/coral+cbor<vspace/>
              Content Coding: identity<vspace/>
              ID: TBD (maybe 63)<vspace/>
              Reference: &SELF;
            </t>
            <t>
              Media Type: text/coral<vspace/>
              Content Coding: identity<vspace/>
              ID: TBD (maybe 10063)<vspace/>
              Reference: &SELF;
            </t>
          </list>
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC2119;
      &RFC3629;
      &RFC3986;
      &RFC3987;
      &RFC4648;
      &RFC5234;
      &RFC6657;
      &RFC6838;
      &RFC6943;
      &RFC7049;
      &RFC8174;

      &I-D.ietf-cbor-cddl;
      &I-D.nottingham-rfc5988bis;

      <reference anchor="UNICODE" target="http://www.unicode.org/versions/latest/">
        <front>
          <title>The Unicode Standard</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
        <annotation>
          Note that this reference is to the latest version of Unicode, rather
          than to a specific release. It is not expected that future changes in
          the Unicode specification will have any impact on this document.
        </annotation>
      </reference>

      <reference anchor="UNICODE-UAX15" target="http://unicode.org/reports/tr15/">
        <front>
          <title>Unicode Standard Annex #15: Unicode Normalization Forms</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
      </reference>

      <reference anchor="UNICODE-UAX31" target="http://unicode.org/reports/tr31/">
        <front>
          <title>Unicode Standard Annex #31: Unicode Identifier and Pattern Syntax</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
      </reference>

      <reference anchor="UNICODE-UAX36" target="http://unicode.org/reports/tr36/">
        <front>
          <title>Unicode Standard Annex #36: Unicode Security Considerations</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
      </reference>

    </references>

    <references title="Informative References">

      &RFC5246;
      &RFC5789;
      &RFC5952;
      &RFC6573;
      &RFC6690;
      &RFC6903;
      &RFC6906;
      &RFC7228;
      &RFC7230;
      &RFC7231;
      &RFC7252;
      &RFC7320;
      &RFC8132;

      &I-D.ietf-core-links-json;

      &W3C.REC-html51-20161101;
      &W3C.REC-rdf11-concepts-20140225;
      &W3C.REC-turtle-20140225;
      &W3C.REC-webarch-20041215;

      <!--
      <reference anchor="COOLURI" target="http://www.w3.org/Provider/Style/URI.html">
        <front>
          <title>Cool URIs don't change</title>
          <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee"/>
          <date year="1998"/>
        </front>
      </reference>
      -->

      <reference anchor="FOAF" target="http://xmlns.com/foaf/spec/20140114.html">
        <front>
          <title>FOAF Vocabulary Specification 0.99</title>
          <author initials="D." surname="Brickley" fullname="Dan Brickley"/>
          <author initials="L." surname="Miller" fullname="Libby Miller"/>
          <date month="January" day="14" year="2014"/>
        </front>
      </reference>

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Core Vocabulary" anchor="core-vocabulary">

      <t>
        This section defines the core vocabulary for CoRAL. It is RECOMMENDED
        that all profiles assign an unsigned integer to each of these link
        relation types, form relation types, and form field names.
      </t>

      <t>
        [[NOTE TO RFC EDITOR: Please replace all occurrences of
        "urn:ietf:rfc:XXXX#" with a RFC-Editor-controlled IRI.]]
      </t>

      <section title="Link Relation Types">

        <t>
          <list style="hanging">
            <t hangText="&lt;http://www.iana.org/assignments/relation/type&gt;">
              <vspace/>Indicates that the link's context is an instance of the
              type specified as the link's target; see Section 6 of <xref
              target="RFC6903">RFC 6903</xref>.
            </t>
            <t>
              This link relation type serves in CoRAL the same purpose as the
              RDF predicate identified by the IRI
              &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;.
            </t>
            <t hangText="&lt;http://www.iana.org/assignments/relation/item&gt;">
              <vspace/>Indicates that the link's context is a collection and
              that the link's target is a member of that collection; see Section
              2.1 of <xref target="RFC6573">RFC 6573</xref>.
            </t>
            <t hangText="&lt;http://www.iana.org/assignments/relation/collection&gt;">
              <vspace/>Indicates that the link's target is a collection and that
              the link's context is a member of that collection; see Section 2.2
              of <xref target="RFC6573">RFC 6573</xref>.
            </t>
          </list>
        </t>

      </section>

      <section title="Form Relation Types">

        <t>
          <list style="hanging">
            <t hangText="&lt;urn:ietf:rfc:XXXX#create&gt;">
              <vspace/>Indicates that the form's context is a collection and
              that a new item can be created in that collection by submitting
              the form with a representation. This form relation type is
              typically used with the POST method <xref target="RFC7231"/> <xref
              target="RFC7252"/>.
            </t>
            <t hangText="&lt;urn:ietf:rfc:XXXX#update&gt;">
              <vspace/>Indicates that the form's context can be updated by
              submitting a representation. This form relation type is typically
              used with the PUT method <xref target="RFC7231"/> <xref
              target="RFC7252"/> or PATCH method <xref target="RFC5789"/> <xref
              target="RFC8132"/>.
            </t>
            <t hangText="&lt;urn:ietf:rfc:XXXX#delete&gt;">
              <vspace/>Indicates that the form's context can be deleted. This
              form relation type is typically used with the DELETE method <xref
              target="RFC7231"/> <xref target="RFC7252"/>.
            </t>
            <t hangText="&lt;urn:ietf:rfc:XXXX#search&gt;">
              <vspace/>Indicates that the form's context can be searched by
              submitting a search query. This form relation type is typically
              used with the POST method <xref target="RFC7231"/> <xref
              target="RFC7252"/> or FETCH method <xref target="RFC8132"/>.
            </t>
          </list>
        </t>

      </section>

      <section title="Form Field Names">

        <t>
          <list style="hanging">
            <t hangText="&lt;urn:ietf:rfc:XXXX#accept&gt;">
              <vspace/>Specifies an acceptable content type or content format
              for the request payload. There MAY be multiple form fields with
              this name. If a form does not include a form field with this name,
              the server accepts any or no request payload, depending on the
              form relation type.
            </t>
            <t>
              For HTTP, the content type MUST be specified as a text string in
              the format specified in Section 3.1.1.1 of <xref
              target="RFC7231">RFC 7231</xref>; the set of possible values is
              maintained in the IANA Media Types Registry.
            </t>
            <t>
              For CoAP, the content format MUST be specified as an unsigned
              integer; the set of possible values is maintained in the IANA CoAP
              Content-Formats Registry.
            </t>
          </list>
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Default Profile" anchor="default-profile">

      <t>
        This section defines a default registry that is assumed when a CoRAL
        media type without a "profile" parameter is used.
      </t>

      <t>
        Link Relation Types
        <list>
          <t>
            0 = &lt;http://www.iana.org/assignments/relation/type&gt;<vspace/>
            1 = &lt;http://www.iana.org/assignments/relation/item&gt;<vspace/>
            2 = &lt;http://www.iana.org/assignments/relation/collection&gt;
          </t>
        </list>
        Form Relation Types
        <list>
          <t>
            0 = &lt;urn:ietf:rfc:XXXX#create&gt;<vspace/>
            1 = &lt;urn:ietf:rfc:XXXX#update&gt;<vspace/>
            2 = &lt;urn:ietf:rfc:XXXX#delete&gt;<vspace/>
            3 = &lt;urn:ietf:rfc:XXXX#search&gt;
          </t>
        </list>
        Form Fields
        <list>
          <t>
            0 = &lt;urn:ietf:rfc:XXXX#accept&gt;
          </t>
        </list>
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="CBOR-encoded IRI References" anchor="cbor-iri">

      <t>
        <xref target="RFC3986">URI references</xref> and, secondarily, <xref
        target="RFC3987">IRI references</xref> and are the most common usage of
        resource identifiers in hypertext representation formats such as <xref
        target="W3C.REC-html51-20161101">HTML 5</xref> and the <xref
        target="RFC6690">CoRE Link Format</xref>. They encode the components of
        a resource identifier either as an absolute URI/IRI or as a relative
        reference that is resolved against a base URI/IRI.
      </t>

      <t>
        URI and IRI references are sequences of characters chosen from a limited
        subset of the repertoires of US-ASCII characters and Unicode characters,
        respectively. The individual components of a URI or IRI are delimited by
        several reserved characters. This necessitates the use of
        percent-encoding for reserved characters in a non-delimiting function.
        The resolution of references involves parsing URI/IRI references into
        their components, combining the components with those of the base
        URI/IRI, merging paths, removing dot segments, and recomposing the
        result into a URI/IRI reference string.
      </t>

      <t>
        Overall, proper URI processing can be quite complex, which can be a
        problem in particular in <xref target="RFC7228">constrained
        environments</xref> with severe code size limitations. As a result, many
        implementations in such environments choose to implement only an ad-hoc,
        informally-specified, bug-ridden, non-interoperable subset of half of
        RFC 3986 (or less).
      </t>

      <t>
        This section specifies CBOR-encoded IRI References, a serialization
        format for IRI references that encodes their components as CBOR data
        items rather than text. Given a CBOR implementation, typical operations
        on IRI references such as parsing, reference resolution and comparison
        can be implemented much more easily than with the text-based format. A
        full implementation that covers all corner cases of the specification
        can be implemented in a relatively small amount of code.
      </t>

      <t>
        CBOR-encoded IRI References are not capable of expressing all IRI
        references permitted by <xref target="RFC3987">RFC 3987</xref>. The
        supported subset includes all <xref target="RFC7252">CoAP URIs</xref> and
        most <xref target="RFC7230">HTTP URIs</xref>.
      </t>

      <section title="Data Structure">

        <t>
          The encoding is very similar to the <xref target="RFC7252">encoding of
          the request URI in CoAP messages</xref>. The components of an IRI
          reference are encoded as a sequence of <spanx>options</spanx>. Each
          option consists of an <spanx>option number</spanx> identifying the
          type of option (IRI scheme, host name, etc.) and the <spanx>option
          value</spanx>.
        </t>

<figure><artwork><![CDATA[
   iri = [?(scheme:    1, text),
          ?(host.name: 2, text //
            host.ip:   3, bytes .size 4 / bytes .size 16),
          ?(port:      4, uint .size 2),
          ?(path.type: 5, path-type),
          *(path:      6, text),
          *(query:     7, text),
          ?(fragment:  8, text)]
]]></artwork></figure>

<figure><artwork><![CDATA[
   path-type = &(absolute-path:   0,
                 append-path:     1,
                 relative-path:   2,
                 append-relation: 3)
]]></artwork></figure>

      </section>

      <section title="Options">

        <t>
          The following options are defined:
          <list style="hanging">
            <t hangText="scheme">
              <vspace/>Specifies the IRI scheme. The option value MUST match the
              "scheme" rule defined in Section 3.1 of RFC 3986.
            </t>
            <t hangText="host.name">
              <vspace/>Specifies the host of the IRI authority as a registered
              name.
            </t>
            <t hangText="host.ip">
              <vspace/>Specifies the host of the IRI authority as an IPv4
              address (4&nbsp;bytes) or an IPv6 address (16&nbsp;bytes).
            </t>
            <t hangText="port">
              <vspace/>Specifies the port number. The option value MUST be an
              unsigned integer in the range 0 to 65535 (inclusive).
            </t>
            <t hangText="path.type">
              <vspace/>Specifies the type of the IRI path for reference
              resolution. Possible values are 0 (absolute-path), 1
              (append-path), 2 (relative-path), and 3 (append-relation).
            </t>
            <t hangText="path">
              <vspace/>Specifies one segment of the IRI path. This option can
              occur more than once.
            </t>
            <t hangText="query">
              <vspace/>Specifies one argument of the IRI query. This option can
              occur more than once.
            </t>
            <t hangText="fragment">
              <vspace/>Specifies the fragment identifier.
            </t>
          </list>
          The value of the "host.name", "path", "query", and "fragment" options
          can be any Unicode string. No percent-encoding is performed.
        </t>

      </section>

      <section title="Properties">

        <t>
          A sequence of options is considered <spanx>well-formed</spanx> if:
          <list style="symbols">
            <t>
              the sequence of options is empty or starts with a "scheme",
              "host.name", "host.ip", "port", "path.type", "path", "query",
              or "fragment" option;
            </t>
            <t>
              a "scheme" option is followed by either a "host.name" or "host.ip"
              option;
            </t>
            <t>
              a "host.name" option is followed by a "port" option;
            </t>
            <t>
              a "host.ip" option is followed by a "port" option;
            </t>
            <t>
              a "port" option is followed by a "path", "query", or "fragment"
              option or is at the end of the sequence;
            </t>
            <t>
              a "path.type" option is followed by a "path", "query", or
              "fragment" option or is at the end of the sequence;
            </t>
            <t>
              a "path" option is followed by a "path", "query", or "fragment"
              option or is at the end of the sequence;
            </t>
            <t>
              a "query" option is followed by a "query" or "fragment" option or
              is at the end of the sequence; and
            </t>
            <t>
              a "fragment" option is at the end of the sequence.
            </t>
          </list>
        </t>

        <t>
          A well-formed sequence of options is considered
          <spanx>absolute</spanx> if the sequence of options starts with a
          "scheme" option. A well-formed sequence of options is considered
          <spanx>relative</spanx> if the sequence of options is empty or starts
          with an option other than the "scheme" option.
        </t>

        <t>
          An absolute sequence of options is considered
          <spanx>normalized</spanx> if the result of resolving the sequence of
          options against any base IRI reference is equal to the input. (It
          doesn't matter what it is resolved against, since it is already
          absolute.)
        </t>

      </section>

      <section title="Reference Resolution">

        <t>
          This section defines how to resolve a CBOR-encoded IRI reference that
          might be relative to a given base IRI.
        </t>

        <t>
          Applications MUST resolve a well-formed sequence of options `href`
          against an absolute sequence of options `base` by using an algorithm
          that is functionally equivalent to the following Python 3.5 code.
        </t>

<figure><artwork><![CDATA[
<CODE BEGINS>

   def resolve(base, href, relation=None):
     if not is_absolute(base) or not is_well_formed(href):
       return None
     result = []
     type = PathType.RELATIVE_PATH
     (option, value) = href[0]
     if option == Option.HOST_IP:
       option = Option.HOST_NAME
     elif option == Option.PATH_TYPE:
       href = href[1:]
       type = value
       option = Option.PATH
     if option != Option.PATH or type == PathType.ABSOLUTE_PATH:
       _copy_until(base, result, option)
     else:
       _copy_until(base, result, Option.QUERY)
       if type == PathType.APPEND_RELATION:
         _append_and_normalize(result, Option.PATH,
                               format(relation, "x"))
         return result
       if type == PathType.RELATIVE_PATH:
         _remove_last_path_segment(result)
     _copy_until(href, result, Option.END)
     _append_and_normalize(href, Option.END, None)
     return result

   def _copy_until(input, output, end):
     for (option, value) in input:
       if option >= end:
         break
       _append_and_normalize(output, option, value)

   def _append_and_normalize(output, option, value):
     if option == Option.PATH:
       if value == ".":
         return
       if value == "..":
         _remove_last_path_segment(output)
         return
     elif option > Option.PATH:
       if len(output) >= 2 and                                      \
           output[-1] == (Option.PATH, "") and                      \
           (output[-2][0] < Option.PATH_TYPE or                     \
           output[-2] == (Option.PATH_TYPE, PathType.ABSOLUTE_PATH)):
         _remove_last_path_segment(output)
       if option >= Option.END:
         return
     output.append((option, value))

   def _remove_last_path_segment(output):
     if len(output) >= 1 and output[-1][0] == Option.PATH:
       del output[-1]

<CODE ENDS>
]]></artwork></figure>

      </section>

      <section title="IRI Recomposition" anchor="recomposition">

        <t>
          This section defines how to recompose an IRI from a sequence of
          options that encodes an absolute IRI reference.
        </t>

        <t>
          Applications MUST recompose an IRI from a sequence of options by using
          an algorithm that is functionally equivalent to the following Python
          3.5 code.
        </t>

        <t>
          To reduce variability, the hexadecimal notation when percent-encoding
          octets SHOULD use uppercase letters. The text representation of IPv6
          addresses SHOULD follow the recommendations in Section 4 of <xref
          target="RFC5952">RFC 5952</xref>.
        </t>

<figure><artwork><![CDATA[
<CODE BEGINS>

   def recompose(href):
     if not is_absolute(href):
       return None
     result = ""
     no_path = True
     first_query = True
     for (option, value) in href:
       if option == Option.SCHEME:
         result += value + ":"
       elif option == Option.HOST_NAME:
         result += "//" + _encode_ireg_name(value)
       elif option == Option.HOST_IP:
         result += "//" + _encode_ip_address(value)
       elif option == Option.PORT:
         result += ":" + str(value)
       elif option == Option.PATH:
         result += "/" + _encode_path_segment(value)
         no_path = False
       elif option == Option.QUERY:
         if no_path:
           result += "/"
           no_path = False
         result += "?" if first_query else "&"
         result += _encode_query_argument(value)
         first_query = False
       elif option == Option.FRAGMENT:
         if no_path:
           result += "/"
           no_path = False
         result += "#" + _encode_fragment(value)
     if no_path:
       result += "/"
       no_path = False
     return result

   def _encode_ireg_name(s):
     return "".join(c if _is_ireg_name_char(c) else
         _encode_pct(c) for c in s)

   def _encode_ip_address(b):
     if len(b) == 4:
       return ".".join(str(c) for c in b)
     elif len(b) == 16:
       return "[" + ... + "]"  # see RFC 5952

   def _encode_path_segment(s):
     return "".join(c if _is_isegment_char(c) else
         _encode_pct(c) for c in s)

   def _encode_query_argument(s):
     return "".join(c if _is_iquery_char(c) and c != "&" else
         _encode_pct(c) for c in s)

   def _encode_fragment(s):
     return "".join(c if _is_ifragment_char(c) else
         _encode_pct(c) for c in s)

   def _encode_pct(s):
     return "".join(
         "%{0:0>2X}".format(c) for c in s.encode("utf-8"))

   def _is_ireg_name_char(c):
     return _is_iunreserved(c) or _is_sub_delim(c)

   def _is_isegment_char(c):
     return _is_ipchar(c)

   def _is_iquery_char(c):
     return _is_ipchar(c) or _is_iprivate(c) or c == "/" or c == "?"

   def _is_ifragment_char(c):
     return _is_ipchar(c) or c == "/" or c == "?"

   def _is_ipchar(c):
     return _is_iunreserved(c) or _is_sub_delim(c) or               \
            c == ":" or c == "@"

   def _is_iunreserved(c):
     return _is_alpha(c) or _is_digit(c) or                         \
            c == "-" or c == "." or c == "_" or c == "~" or         \
            _is_ucschar(c)

   def _is_alpha(c):
     return c >= "A" and c <= "Z" or c >= "a" and c <= "z"

   def _is_digit(c):
     return c >= "0" and c <= "9"

   def _is_sub_delim(c):
     return c == "!" or c == "$" or c == "&" or c == "'" or         \
            c == "(" or c == ")" or c == "*" or c == "+" or         \
            c == "," or c == ";" or c == "="

   def _is_ucschar(c):
     return c >= "\U000000A0" and c <= "\U0000D7FF" or              \
            c >= "\U0000F900" and c <= "\U0000FDCF" or              \
            c >= "\U0000FDF0" and c <= "\U0000FFEF" or              \
            c >= "\U00010000" and c <= "\U0001FFFD" or              \
            c >= "\U00020000" and c <= "\U0002FFFD" or              \
            c >= "\U00030000" and c <= "\U0003FFFD" or              \
            c >= "\U00040000" and c <= "\U0004FFFD" or              \
            c >= "\U00050000" and c <= "\U0005FFFD" or              \
            c >= "\U00060000" and c <= "\U0006FFFD" or              \
            c >= "\U00070000" and c <= "\U0007FFFD" or              \
            c >= "\U00080000" and c <= "\U0008FFFD" or              \
            c >= "\U00090000" and c <= "\U0009FFFD" or              \
            c >= "\U000A0000" and c <= "\U000AFFFD" or              \
            c >= "\U000B0000" and c <= "\U000BFFFD" or              \
            c >= "\U000C0000" and c <= "\U000CFFFD" or              \
            c >= "\U000D0000" and c <= "\U000DFFFD" or              \
            c >= "\U000E1000" and c <= "\U000EFFFD"

   def _is_iprivate(c):
     return c >= "\U0000E000" and c <= "\U0000F8FF" or              \
            c >= "\U000F0000" and c <= "\U000FFFFD" or              \
            c >= "\U00100000" and c <= "\U0010FFFD"

<CODE ENDS>
]]></artwork></figure>

      </section>

      <section title="CoAP Encoding">

        <t>
          This section defines how to construct CoAP options from an absolute,
          normalized, CBOR-encoded IRI Reference.
        </t>

        <t>
          Applications MUST construct CoAP options by recomposing the sequence
          of options to an IRI (<xref target="recomposition"/> of this
          document), mapping the IRI to an URI (Section 3.1 of RFC 3987), and
          decomposing the URI into CoAP options (Section 6.4 of RFC 7252).
        </t>

        <t>
          The following illustrative Python 3.5 code is roughly equivalent to
          this.
        </t>

<figure><artwork><![CDATA[
<CODE BEGINS>

   def coap(href, to_proxy=False):
     if not is_absolute(href):
       return None
     result = b""
     previous = 0
     for (option, value) in href:
       if option == Option.SCHEME:
         pass
       elif option == Option.HOST_NAME:
         opt = 3  # Uri-Host
         val = value.encode("utf-8")
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.HOST_IP:
         opt = 3  # Uri-Host
         if len(value) == 4:
           val = ".".join(str(c) for c in b).encode("utf-8")
         elif len(value) == 16:
           val = b"[" + ... + b"]"  # see RFC 5952
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.PORT:
         opt = 7  # Uri-Port
         val = value.to_bytes((value.bit_length() + 7) // 8, "big")
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.PATH:
         opt = 11  # Uri-Path
         val = value.encode("utf-8")
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.QUERY:
         opt = 15  # Uri-Query
         val = value.encode("utf-8")
         result += _encode_coap_option(opt - previous, val)
         previous = opt
       elif option == Option.FRAGMENT:
         pass
     if to_proxy:
       (option, value) = href[0]
       opt = 39  # Proxy-Scheme
       val = value.encode("utf-8")
       result += _encode_coap_option(opt - previous, val)
       previous = opt
     return result

   def _encode_coap_option(delta, value):
     length = len(value)
     delta_nibble = _encode_coap_option_nibble(delta)
     length_nibble = _encode_coap_option_nibble(length)
     result = bytes([delta_nibble << 4 | length_nibble])
     if delta_nibble == 13:
       delta -= 13
       result += bytes([delta])
     elif delta_nibble == 14:
       delta -= 256 + 13
       result += bytes([delta >> 8, delta & 255])
     if length_nibble == 13:
       length -= 13
       result += bytes([length])
     elif length_nibble == 14:
       length -= 256 + 13
       result += bytes([length >> 8, length & 255])
     result += value
     return result

   def _encode_coap_option_nibble(n):
     if n < 13:
       return n
     elif n < 256 + 13:
       return 13
     elif n < 65536 + 256 + 13:
       return 14

<CODE ENDS>
]]></artwork></figure>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <!--
    <section title="Acknowledgements" numbered="no">
    </section>
    -->

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
